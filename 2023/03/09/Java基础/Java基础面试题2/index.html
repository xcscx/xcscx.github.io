<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java基础面试题2 | IT蛋的个人博客</title><meta name="author" content="IT蛋"><meta name="copyright" content="IT蛋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编程导航">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础面试题2">
<meta property="og:url" content="https://xcscx.github.io/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/index.html">
<meta property="og:site_name" content="IT蛋的个人博客">
<meta property="og:description" content="编程导航">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&rs=1">
<meta property="article:published_time" content="2023-03-09T02:16:26.000Z">
<meta property="article:modified_time" content="2023-03-12T01:06:20.291Z">
<meta property="article:author" content="IT蛋">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&rs=1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xcscx.github.io/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础面试题2',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2023-03-12 09:06:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 博主</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&amp;rs=1')"><nav id="nav"><span id="blog-info"><a href="/" title="IT蛋的个人博客"><span class="site-name">IT蛋的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 博主</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础面试题2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-09T02:16:26.000Z" title="发表于 2023-03-09 10:16:26">2023-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T01:06:20.291Z" title="更新于 2023-03-12 09:06:20">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">java基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础面试题2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？"><a href="#MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？"></a>MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？</h2><p>MySQL事务有四种隔离级别：</p>
<ol>
<li><strong>读未提交</strong>（Read Uncommitted）：事务可以读取未提交的数据，可能会读到脏数据，导致幻读，不可重复读，脏读等问题</li>
<li><strong>读已提交</strong>（Read Committed）：只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复读，幻读问题</li>
<li><strong>可重复读</strong>（Repeatable Read）：保证同一事务中多次读取同一数据的结果是一致的，避免了脏读和不可重复读问题，但是可能会遇到幻读的问题</li>
<li><strong>序列化</strong>（Serializable）：最高的隔离级别，可以避免所有的并发问题，但是并发性非常低，开销很大</li>
</ol>
<p>MySQL的默认隔离级别是可重复读</p>
<p><strong>脏读</strong>指一个事务读到了另一个事务未提交的数据</p>
<p><strong>不可重复读</strong>指同一个事务多次读到同一数据的不同结果</p>
<p><strong>幻读</strong>指同一事物前后读取的数据集合不一致（按条件查询时找不到数据，插入时又已存在数据）</p>
<h2 id="讲一下-Redis-的单线程模型，IO-多路复用是什么？"><a href="#讲一下-Redis-的单线程模型，IO-多路复用是什么？" class="headerlink" title="讲一下 Redis 的单线程模型，IO 多路复用是什么？"></a>讲一下 Redis 的单线程模型，IO 多路复用是什么？</h2><p>Redis是一款基于内存的高性能键值存储系统，采用单线程模型设计。在Redis中，所有客户端的请求都是由一个单线程来处理的，这个单线程不断从客户端套接字中读取命令请求，并将命令请求放入一个请求队列中。接着，Redis的事件处理器会按照一定的规则选择一个请求进行处理，处理完之后将响应结果返回给客户端。</p>
<p>单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，简化了系统的设计和调试。此外，由于Redis的内存访问速度非常快，因此单线程处理请求也能够保证足够的性能</p>
<p>IO多路复用是指在同一个线程中同时监听多个文件描述符，一旦某个文件描述符就绪，就立刻处理对应事件。在Redis中，采用的是基于epoll的IO多路复用技术，可以实现高效的事件监听和响应</p>
<p>在Redis中，客户端的请求是由一个单线程来处理的，而IO操作却是通过epoll多路复用技术实现的。这种设计方式既能充分利用CPU的计算能力，又能够保证足够的IO处理能力，从而实现高效的键值存储服务</p>
<h2 id="什么是-BIO、NIO、AIO？"><a href="#什么是-BIO、NIO、AIO？" class="headerlink" title="什么是 BIO、NIO、AIO？"></a>什么是 BIO、NIO、AIO？</h2><p>BIO、NIO、AIO都是Java的IO模型</p>
<p>BIO（Blocking IO）：同步阻塞IO，是传统的IO模型，它在读写数据时会<strong>阻塞线程</strong>，知道数据读写完成，适用于并发不高的场景</p>
<p>NIO（Non-blocking IO）同步非阻塞IO，是Java的新IO模型，它在读写数据时不会阻塞线程，而是通过<strong>轮询</strong>的方式查询是否有数据可读写，适用于并发量较高的场景</p>
<p>AIO（Asynchronous IO）异步非阻塞IO，是JDK7开始引入的新IO模型，它读写方式与NIO相似，但在读写数据时，不<strong>需要自己动手轮询</strong>是否有数据可读写，而是交由系统完成，适用于高并发且处理较大数据量的场景。</p>
<p>总的来说，BIO的并发处理能力较差，NIO的并发处理能力较好，但使用起来较为复杂，AIO的并发处理能力最好，但也是最为复杂的一种IO模型。现在适合自己场景的IO模型时非常重要的。</p>
<h2 id="意向锁是什么？有什么作用？它是表级锁还是行级锁？"><a href="#意向锁是什么？有什么作用？它是表级锁还是行级锁？" class="headerlink" title="意向锁是什么？有什么作用？它是表级锁还是行级锁？"></a>意向锁是什么？有什么作用？它是表级锁还是行级锁？</h2><p>意向锁时一种MySQL数据库中的锁，用于表级协调多个行级锁的使用。在表级锁定一个表之前，MySQL需要先获得一个意向锁，以表明要获取的锁的类型（读锁或写锁），避免其他事务锁定一部分表时引发死锁。</p>
<p>意向锁是一种轻量级锁，他不会影响其他事务的读操作，只有在某个事务要对表进行写操作时才会加上意向锁，而其他事务在读取时只需要获取读锁，不需要等待意向锁的释放。</p>
<p>意向锁可以提高数据库并发性能，防止死锁的发生。它是表级锁，而不是行级锁。</p>
<h2 id="Spring、SpringMVC、SpringBoot-三者之间是什么关系？"><a href="#Spring、SpringMVC、SpringBoot-三者之间是什么关系？" class="headerlink" title="Spring、SpringMVC、SpringBoot 三者之间是什么关系？"></a>Spring、SpringMVC、SpringBoot 三者之间是什么关系？</h2><p>Spring，SpringMVC，SpringBoot是三个独立的框架，它们之间的关系是：</p>
<ol>
<li>Spring是一个Java轻量级应用框架，提供基于IoC和AOP的支持，用于构建企业级应用。Spring有多个模块，包括Spring Core，Spring Context，Spring JDBC，Spring Web等，每个模块提供了不同的功能。</li>
<li>SpringMVC 是 Spring框架的一部分，是基于MVC设计模式的web框架，用于构建web应用程序。它提供了控制器，数据绑定，异常处理等功能，使得开发Web应用变得更加简单。SpringMVC还支持RESTfuk架构。</li>
<li>SpringBoot是基于Spring框架的一个开发框架，用于快速构建独立的，生产级别的Spring应用程序。它通过自动配置和约定优于配置的方式，简化了Spring应用程序的配置和开发过程。SpringBoot集成了很多常用的第三方库和工具，例如SpringData，SpringSecurity，Thymeleaf，Logback等，可以极大的提高开发效率。</li>
</ol>
<p>因此，SpringBoot可以看作是在Spring的基础上，通过自动装配的约定优于配置的方式，提供了更加简单，快速的开发体验。而SpringMVC则是Spring框架中用于构建Web应用程序的模块</p>
<h2 id="Redis-基础类型中的-String-底层实现是什么？"><a href="#Redis-基础类型中的-String-底层实现是什么？" class="headerlink" title="Redis 基础类型中的 String 底层实现是什么？"></a>Redis 基础类型中的 String 底层实现是什么？</h2><p>Redis中的Spring类型底层实现是一个简单的动态字符串（SDS,Simple Dynamic String），也就是字符串动态增长实现的一种方式，SDS是Redis自己实现字符串库，相对于C语言原生的字符串，SDS在空间使用上更加灵活，而且支持O（1）复杂度的长度计算，避免了C语言字符串计算长度时的O（N）时空复杂度问题</p>
<p>SDS是一种动态字符串，它有如下特点：</p>
<ol>
<li>首先SDS对内存的分配和释放进行了封装，使得字符串的空间可以根据需要进行增长或缩短，避免了C语言字符串需要手动分配空间的问题</li>
<li>SDS除了记录字符串本身的长度外，还记录了分配给字符串的空间的长度，可以方便的计算出字符串是否需要扩容</li>
<li>SDS使用了惰性空间释放，不会再空间缩减时立刻释放空间，而是等到需要扩容时再重新分配内存</li>
<li>SDS提供了字符串的追加操作，可以在O（1）的时间内完成追加操作。</li>
</ol>
<p>在Redis中，String类型并不仅仅时字符串类型，它还支持一些其他操作，如递增&#x2F;递减操作，位运算，这些操作都是基于SDS底层实现的。</p>
<h2 id="有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？"><a href="#有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？" class="headerlink" title="有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？"></a>有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？</h2><p>在Spring框架中，常用的注入Bean的注解包括：</p>
<ol>
<li>@Autowired：自动注入，按照类型自动装配，如果有多个类型相同的Bean，则需要通过@Qualifier指定具体的Bean</li>
<li>@Resource：Java自带的注入方式，按照名称自动装配，默认是按照属性名称进行匹配，如果需要按照Bean的名称进行匹配，可以使用@Resource（name&#x3D;”beanName”）</li>
<li>@Inject：和@Autowired类似，也是按照类型进行自动装配，但是@Inject注解是JSR-330 提供的，而@Autowired 注解是 Spring 框架提供的</li>
<li>@Value：用于注入配置文件中的属性值，可以指定默认值</li>
<li>@Component：用于声明一个Bean，作用类似于XML中的&lt; bean &gt; 标签</li>
</ol>
<p>以上注解都可以用于注入Bean，不同注解之间的区别主要在于注入方式和实现方式不同。＠Autowired 和@Resource最常用，其中@Autowired按照类型自动装配更为常用，而@Resource按照名称自动装配则比较适合需要明确指定的Bean名称的情况</p>
<p>需要注意的是，注入Bean的时候最好使用接口类型作为注入对象，这样可以避免应为具体实现类变更导致注入失败的问题</p>
<h2 id="请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？"><a href="#请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？" class="headerlink" title="请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？"></a>请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？</h2><p>JVM内存模型分为一下几个区域：</p>
<ol>
<li>程序计数器（Program Counter Register）：每个线程都有自己的程序技术器，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确位置</li>
<li>虚拟机栈（JVM Stack）：也称Java方法栈，用于存储方法执行时的局部变量表，操作数栈，动态链表，方法出口等信息.每个线程正在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈</li>
<li>本地方法栈（Native Method Stack）：于虚拟机栈类似，用于存储本地方法的执行信息</li>
<li>堆（Heap）：用于存储对象实例，时JVM中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的独享实例都有一个标记用于标记对象是否存活，垃圾回收器会周期性的回收那些没有被标记为存活的对象</li>
<li>方法区（Method Area）：用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。方法区也是被所有线程共享的</li>
<li>运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池</li>
</ol>
<p>其中，程序计数器，虚拟机栈，本地方法栈是线程私有，堆，方法区，运行时常量池是线程共享的</p>
<h2 id="Linux-中的硬链接和软连接是什么，二者有什么区别？"><a href="#Linux-中的硬链接和软连接是什么，二者有什么区别？" class="headerlink" title="Linux 中的硬链接和软连接是什么，二者有什么区别？"></a>Linux 中的硬链接和软连接是什么，二者有什么区别？</h2><p>在Linux 文件系统中，硬链接（hard link）和软连接（私有mbolic link）都是一种文件链接方式，可以用于将一个文件链接到另一个文件上。它们主要区别在创建方式，所占空间和使用限制等方面</p>
<p>硬链接是通过在文件系统中创建一个新的目录项（directory entry）指向同一文件inode的位置来实现。因为硬链接实际上是指向同一inode，所以如果源文件被删除，硬链接依然能够访问到源文件的内容。硬链接的使用范围比较受限，因为硬链接只能指向一个文件系统内的文件，不能跨文件系统创建</p>
<p>软链接是通过在文件系统中创建一个新的文件来实现，该文件中包含指向另一个文件的路径。软连接可以跨文件系统创建，并且可以指向任何类型的文件。但是，当源文件被删除时，软链接会失效</p>
<p>总的来说，硬链接要更加高效，因为它只是添加了一个新的目录项，所以对磁盘空间的消耗比软链接要小。但是，硬链接不能跨文件系统，所以在实际应用中需要根据具体的需求来选择使用哪种链接方式</p>
<h2 id="如何使用-Redis-实现一个排行榜？"><a href="#如何使用-Redis-实现一个排行榜？" class="headerlink" title="如何使用 Redis 实现一个排行榜？"></a>如何使用 Redis 实现一个排行榜？</h2><p>使用Redis 可以很方便的实现一个排行榜，以下是一种实现方式：</p>
<p>使用有序集合（Sorted Set）来存储排行榜数据，以用户得分作为分数（score），用户ID作为成为（member）</p>
<p>当用户得分改变时，使用Redis的ZADD命令将用户的分数更新到有序集合中</p>
<p>获取排行榜数据时，使用Redis的ZREVRANGE命令按分数排序获得有序集合中的成员</p>
<p>可以使用Redis的ZSCORE命令获取某个用户的分数，或使用ZREVRANK命令获取某个用户的排名。例如：</p>
<pre><code class="java">import redis.clients.jedis.Jedis;
import java.util.Map;
import java.util.Set;

public class RedisRankingList &#123;
    private final Jedis jedis;

    public RedisRankingList() &#123;
        // 连接 Redis
        jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    /**
     * 添加用户分数
     */
     public void addUserScore(String userId, double score) &#123;
        jedis.zadd(&quot;ranking&quot;, score, userId);
    &#125;

    /**
     * 获取排行榜前 N 名用户信息
     */
    public void getTopN(int n) &#123;
        // 获取排行榜前 N 名用户的 ID 和分数
        Set&lt;Map.Entry&lt;String, Double&gt;&gt; rankingSet = jedis.zrevrangeWithScores(&quot;ranking&quot;, 0, n - 1);

        // 遍历集合，输出用户信息
        for (Map.Entry&lt;String, Double&gt; entry : rankingSet) &#123;
            String userId = entry.getKey();
            double score = entry.getValue();
            System.out.println(&quot;userId: &quot; + userId + &quot;, score: &quot; + score);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="什么是网关，网关有哪些作用？"><a href="#什么是网关，网关有哪些作用？" class="headerlink" title="什么是网关，网关有哪些作用？"></a>什么是网关，网关有哪些作用？</h2><p>网关（Gateway）是在计算机网络中用于连接两个独立的网络的设备，它能够在两个不同协议的网络之间传递数据。在互联网中，网关是一个可以连接不同协议的网络设备请求，比如说可以连接局域网和互联网，它可以把局域网和内部网络地址转换成互联网上的合法地址，从而使得局域网的主机可以与外界通信。</p>
<p>在计算机系统中，网关可以用于实现负载均衡，安全过滤，协议住那换等功能。具体来说，网关可以分为以下几种：</p>
<ol>
<li>应用网关：用于应用层协议的处理，如HTTP，SMTP等</li>
<li>数据库网关：用于数据库访问的控制和管理</li>
<li>通信网关：用于不同通信协议之间的数据交换，如TCP&#x2F;IP，UDP&#x2F;IP 等。</li>
<li>API网关：用于管理和转发API请求，实现API 的授权，限流，监控等功能</li>
</ol>
<p>总的来说，网关可以不同网络提供连接和通信的功能，同时也可以提供安全，性能，可靠性等方面的增强功能，是现代计算机不可或缺的一部分</p>
<h2 id="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"><a href="#线程的生命周期是什么，线程有几种状态，什么是上下文切换？" class="headerlink" title="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"></a>线程的生命周期是什么，线程有几种状态，什么是上下文切换？</h2><p>线程的生命周期通常包括物种状态：新建（New），就绪（Runnable），运行（Running），阻塞（Blocked）和终止（Terminated）。其中：</p>
<ul>
<li>新建状态是指当前线程对象创建后，就进入了新建状态。此时它已经有了相应的内存空间和其他资源，但是还没有开始运行</li>
<li>就绪状态是指当前线程对象调用start()方法后，线程进入了就绪状态。此时它已经具备了运行的条件，只等CPU分配资源，让其开始执行</li>
<li>运行状态是指当线程对象获得CPU资源后，就开始执行run() 方法中的代码，线程处于运行状态</li>
<li>阻塞状态是指线程在特定情况下会被挂起，暂时停止执行。当线程处于阻塞状态时，它并不会占用CPU 资源</li>
<li>终止状态是指线程的run() 方法执行完毕或者因异常退出时，线程进入了终止状态。此时，线程不再占有CPU资源，也不再执行任何代码。</li>
</ul>
<p>在线程的生命周期中，线程状态的转换通常时由操作系统调度和控制的。当线程的状态发生变化时，需要进行上下文切换，即保存当前线程的状态和上下文信息，并恢复另一个线程的状态和上下文信息，使其能够继续执行。上下文切换会带来一定的开销，因此需要尽可能减少线程之间的切换次数。</p>
<h2 id="MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？"><a href="#MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？" class="headerlink" title="MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？"></a>MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</h2><p>MVCC 是指多版本并发控制（Multiversion Concurrency Control），是一种并发控制机制，常用于数据库，用于实现事务的并发控制。它允许在同一时间多个事务对同一个数据集合进行读取操作，同时防止数据不一致和其他并发问题。</p>
<p>InnoDB 是 MySQL 中最常用的存储引擎之一，它的MVCC 实现是通过在每行记录中添加两个隐藏的列，分别记录行的创建时间和过期时间，以此来判断事务对该行记录的可见性。当一个事务需要读取一行记录时，InnoDB首先读取这行记录的创建时间和过期时间，并根据这些信息判断该行记录是否可见。如果创建时间早于当前事务的开始时间，且过期时间晚于当前事务的开始时间，那么该行记录对当前事务可见。</p>
<p>在InnoDB 中，MVCC 主要是通过实现以下几个机制来实现的：</p>
<ol>
<li>事务版本号：每个事务都有一个唯一的版本号，用来标识该事务的创建时间。</li>
<li>读取视图：每个事务在开始的时候都会创建一个读取视图，记录该事务开始时间和其他信息。在事务执行期间，所有读取操作都要检查该视图，以确定读取哪些版本的数据</li>
<li>undo 日志：在事务执行期间，如果对数据进行修改，那么会先将原始数据复制一份到undo日志中。这样，在回滚操作时就可以使用undo 日志中的数据来还原原始数据。</li>
<li>快照读取：在某些情况下，事务需要读取一个数据的历史版本，而不是当前版本。这是可以使用快照读取来实现，即在读取事务开始时间和undo 日志来读取历史版本的数据。</li>
</ol>
<h2 id="Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？"><a href="#Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？" class="headerlink" title="Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？"></a>Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？</h2><p>Redis 的持久化机制主要分为RDB 和AOF 两种</p>
<p>RDB 持久化机制</p>
<p>RDB 持久化机制是指将 Redis 在内存中的数据以快照的形式写入磁盘中，可以手动或自动执行快照操作，将数据集的状态保存到一个RDB文件中。RDB 机制的优点在于：</p>
<ul>
<li>RDB 机制适合在数据集比较大时进行备份操作，因为它可以生成一个非常紧凑，经过压缩的数据文件，对于备份，恢复，迁移数据都很方便</li>
<li>RDB机制在Redis 重启时比AOF 机制更快地将Redis 恢复到内存中。</li>
</ul>
<p>RDB 机制的缺点在于：</p>
<ul>
<li>RDB 机制可能会出现数据丢失，因为数据是周期性的进行备份，一旦Redis出现问题并且上一次备份之后还没有进行数据变更，那么这部分数据将会丢失</li>
<li>RDB 机制会造成一定的IO 压力，当数据集比较大时，进行备份操作可能会阻塞Redis服务进程</li>
</ul>
<p>AOF 持久化机制</p>
<p>AOF 持久化机制是指将Redis 在内存中的操作指令以追加的形式写入到磁盘中的AOF 文件，AOF 文件记录了 Redis 在内存中的操作过程，只要在Redis 重启后重新执行AOF 文件中的操作命令即可将数据恢复到内存中。AOF机制的优点在于：</p>
<ul>
<li>AOF机制比RDB 机制更加可靠，因为AOF 文件记录了Redis 执行的所有操作命令，可以确保数据不丢失。</li>
<li>AOF 机制在恢复大数据集时更加稳健，因为AOF文件记录了数据的操作过程，可以确保每一次操作都被正确执行</li>
</ul>
<p>AOF机制的缺点在于：</p>
<ul>
<li>AOF 机制生成的AOF 文件比RDB 文件更大，当数据集比较大时，AOF 文件会比RDB 文件占用更多的磁盘空间</li>
<li>AOF 机制对数据恢复的时间比RDB 机制更加耗时，因为要重新执行AOF文件中的全部命令</li>
</ul>
<p>综上所述，RDB适用于数据集较大，备份，恢复数据和迁移数据等场景，AOF适用于数据可靠性要求高，数据恢复稳健等场景。</p>
<h2 id="Nginx-是什么？它有哪些应用场景？"><a href="#Nginx-是什么？它有哪些应用场景？" class="headerlink" title="Nginx 是什么？它有哪些应用场景？"></a>Nginx 是什么？它有哪些应用场景？</h2><p>Nginx（发音为”engine-x”）是一个高性能的开源Web服务器和反向代理服务器，可以处理大量的并发连接和请求。它使用事件驱动的异步架构和多线程设计，可以高效的处理并发请求，同时也支持反向代理，负载均衡，动态HTTP缓存，SSL&#x2F;TLS终止，基于模块的扩展功能。</p>
<p>Nginx的应用场景每场广泛，以下是其中几个：</p>
<ol>
<li>Web服务器：Nginx 可以作为HTTP 服务器，处理并发的静态请求和动态请求，并且可以支持负载均衡和缓存，为网站提供高性能和高可用性</li>
<li>反向代理服务器：Nginx可以作为反向代理的服务器，接收客户端请求并且将其转发到后端服务器，同时也可以支持负载均衡和缓存。</li>
<li>邮件代理服务器：Nginx 可以作为邮件代理服务器，支持POP3，IMAP和SMTP协议，并且可以支持SSL&#x2F;TLS加密和反垃圾邮件功能</li>
<li>流媒体服务器：Nginx可以作为流媒体服务器，支持RTMP，HLS和DASH协议，可以用于实现直播，点播和视频-on-demand（VoD）等场景</li>
</ol>
<p>总之，Nginx具有高性能，可扩展性和可靠性等特点，被广泛应用于大型网站，互联网公司，云计算，视频流媒体，游戏等领域。</p>
<h2 id="Dubbo-是什么？是否了解过它的架构设计？"><a href="#Dubbo-是什么？是否了解过它的架构设计？" class="headerlink" title="Dubbo 是什么？是否了解过它的架构设计？"></a>Dubbo 是什么？是否了解过它的架构设计？</h2><p>Dubbo 是一个高性能，轻量级的开源Java RPC 框架，它提供了完整的RPC协议栈，包括服务发布，服务引用，负载均衡，容错，服务治理和服务监控等功能，同时提供了可扩展的RPC协议，数据模型，序列化和网络传输等组件，支持多语言和多协议</p>
<p>Dubbo 的架构设计主要包括服务提供者，服务消费者，注册中心和监控中心四个角色。其中，服务提供者提供服务的实现，并通过注册中心将自己注册到服务治理中心；服务消费者则通过注册中心发现可用的服务，并通过负载均衡策略选择一个服务提供者进行调用；注册中心主要负载服务的注册，发现和路由；监控中心则负责服务的统计和监控。</p>
<p>Dubbo的架构设计采用了分层架构，将不同的功能模块进行分离，以达到模块化和可扩展的目的。同时，Dubbo还提供了丰富的扩展点和插件机制，用户可以通过自定义扩展点和插件来满足不同的业务需求。</p>
<h2 id="synchronized-关键字是什么，有什么作用？"><a href="#synchronized-关键字是什么，有什么作用？" class="headerlink" title="synchronized 关键字是什么，有什么作用？"></a>synchronized 关键字是什么，有什么作用？</h2><p>synchronized 是 Java 中的一个关键字，用于实现线程同步。具体来说，</p>
<p>synchronized 用于修饰方法或代码块，使得同一时刻只能有一个线程访问被修饰的代码，其他线程需要等待当前线程执行完毕后才能访问。</p>
<p>synchronized 主要用于解决多线程并发访问共享资源时出现的线程安全问题。如果多个线程同时访问同一个共享资源，就会出现多个线程同时修改这个资源的情况，从而导致该数据不一致等问题。而使用 synchronized 可以保证同一时刻只有一个线程访问该资源，从而避免了线程安全问题</p>
<p>synchronized 的作用不仅限于线程同步，它还可以保证可见性和有序性，即保证在同一个锁上，一个线程修改了共享变量的值后，另一个线程能够立即看到修改后的值，并且在多个线程执行顺序上保持了一致性。</p>
<p>需要注意的是：使用synchronized 会带来一定的性能损失，因为每次进入同步块时都需要获得锁，这会增加线程的等待事件和上下文切换的开销。同时，如果同步块的代码执行时间很短，也会增加不必要的性能开销。因此，需要根据具体情况来判断是否需要使用synchronized 。</p>
<h2 id="如何设计一个点赞系统？"><a href="#如何设计一个点赞系统？" class="headerlink" title="如何设计一个点赞系统？"></a>如何设计一个点赞系统？</h2><p>设计一个点赞系统可以分为以下几个步骤：</p>
<ol>
<li>确定需求：需要明确点赞的对象是什么，是否需要计数等信息，同时需要考虑点赞的业务场景，如用户点赞，文章点赞等</li>
<li>数据库设计：需要设计点赞相关的数据表，可以包含点赞者ID，被点赞对象的ID，点赞时间等字段。</li>
<li>接口设计：需要设计点赞等相关的接口，包括点赞，取消点赞，查询点赞数等操作</li>
<li>业务逻辑实现：在接口中实现点赞相关的业务逻辑，包括判断点赞状态，更新点赞数，更新点赞状态等操作。</li>
<li>安全性考虑：需要考虑并发访问的情况，可以使用分布式锁来保证数据一致性和安全性</li>
<li>性能优化：如果点赞系统的访问量很高，可以使用缓存来提高性能，比如使用Redis 来缓存点赞等信息</li>
<li>监控和日志：需要对点赞系统进行监控和日志记录，以便即使发现和排查问题</li>
</ol>
<p>总之，设计一个点赞系统需要综合考虑需求，数据库设计，接口设计，业务逻辑实现，安全性，性能优化等方面，同时需要不断优化和完善。</p>
<h2 id="什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？"><a href="#什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？" class="headerlink" title="什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？"></a>什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？</h2><p>内部类是定义在另一个类中的类。Java 中内部类主要分为成员内部类，静态内部类，局部内部类和匿名内部类</p>
<ol>
<li>成员内部类：定义在另一个类的内部，并且与其他成员变量和方法平级，可以访问外部类的所有成员变量和方法。<strong>使用方法：Outer.Inner inner &#x3D; new Outer().new Inner().</strong></li>
<li>静态内部类：定义在另一个类的内部，但是要用static修饰。只能访问外部类的静态成员变量和方法：<strong>使用方法：Outer.Inner inner &#x3D; new Outer.Inner().</strong></li>
<li>局部内部类：定义在方法中，作用域仅限于方法内部。与局部变量类似，不能使用访问控制符修饰。<strong>使用方法：在方法中直接实例化</strong></li>
<li>匿名内部类：没有名字的内部类。<strong>使用方式：new接口或者抽象类(){} 或 new 父类() {}</strong></li>
</ol>
<p>内部类的优点：</p>
<ol>
<li>可以访问外部类的私有成员变量和方法</li>
<li>可以隐藏实现细节</li>
<li>便于编写和维护，提高代码的可读性和可维护性</li>
<li>内部类可以很好的解决Java中单继承的问题</li>
</ol>
<p>内部类的应用场景：</p>
<ol>
<li>需要访问外部类的私有成员变量和方法</li>
<li>需要定义一个回调函数或监听器</li>
<li>需要实现多重继承</li>
<li>需要对外部类进行扩展、</li>
</ol>
<h2 id="MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"><a href="#MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。" class="headerlink" title="MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"></a>MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。</h2><p>覆盖索引和联合索引是数据库中常见的两种索引类型</p>
<p>覆盖索引是指一个包含了所有查询需要的列的索引， 查询时可以直接从索引中渠道需要的数据，而不需要再回到表中查找，从而可以提高查询效率</p>
<p>联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描</p>
<p>最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了A，B，C三列，那么查询时只能使用A，AB 或ABC 进行匹配，而不是只是用 B 或 C 进行匹配。这是应为如果查询时使用的列不是最左前缀列，那么MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。</p>
<p>在实际的应用中，覆盖索引和联合索引可以结合使用，以提高查询效率。同时，使用最左前缀匹配原则可以让我们更加合理的设计索引，从而提高查询性能。</p>
<h2 id="Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？"><a href="#Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？" class="headerlink" title="Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？"></a>Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？</h2><p>Spring 框架中处理线程并发问题的方式包括以下几种：</p>
<ol>
<li>同步关键字 synchronized：使用synchronized 关键字可以对共享资源进行加锁，从而保证多线程访问时的同步性。但是，synchronized 会对性能产生一定的影响，并且容易导致死锁等问题</li>
<li>Lock 接口：Lock 接口提供了比 synchronized 更加灵活的加锁方式，并且可以防止死锁问题发生。但是，Lock 接口使用相对复杂，需要手动进行加锁和解锁的操作</li>
<li>ThreadLocal类：ThreadLocal 类提供了线程本地变量的功能，可以让每个线程拥有自己的变量副本，从而避免了多个线程之间的共享问题。但是，ThreadLocal 类的使用需要注意内存泄漏问题</li>
</ol>
<p>关于ThreadLocal ，它是Java 中一个非常重要的类，用于实现线程本地存储，即让每个线程都拥有自己的变量副本，从而避免多个线程之间的共享问题。在Spring 框架中，ThreadLocal 类经常用于存储一些与当前线程有关的数据，例如请求上下文，用户信息等。通过将这些数据保存到ThreadLocal 对象中，可以方便的在整个应用程序中进行访问和传递，同时避免了多个线程之间的共享问题</p>
<p>ThreadLocal 类的使用需要注意内存泄漏问题，因为线程本地变量只有在对应的线程被回收时才会被回收，如果没有及时清理，就可能导致内存泄漏问题。因此，在使用ThreadLocal 类时，需要注意在不需要存储数据时及时调用remove() 方法清理ThreadLocal 对象中的数据</p>
<h2 id="什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？"><a href="#什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？" class="headerlink" title="什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？"></a>什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？</h2><p>MySQL 执行计划是指MySQL 查询优化器生成的一份详细的查询执行计划，它展示了MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序，数据读取方式，使用的索引，使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。</p>
<p>要获取执行计划，可以在执行SQL 语句时在前面添加 explain 关键字，例如：</p>
<pre><code class="java">explain select * from table id = 1;
</code></pre>
<p>这样，MySQL 会输出该查询语句的执行计划。执行计划中的各个字段含义如下：</p>
<ul>
<li>id：每个Select 子句或者是一个操作符或者是一个查询语句</li>
<li>select_type：查询类型，标识查询的类型（简单查询，联合查询，子查询等等）</li>
<li>table：查询设计的表</li>
<li>partitions：匹配的分区</li>
<li>type：访问类型，表示MySQL在表中找到所需行的方式</li>
<li>possible_keys：表示查询可能使用到的索引</li>
<li>key：实际使用到的索引</li>
<li>key_len：使用的索引长度</li>
<li>ref：列与索引的比较</li>
<li>rows：根据表统计信息及索引选用情况，大致估算出找到所需要的记录所需要读取的行数</li>
<li>filtered：返回结果的行数占总行数的比例</li>
<li>Extra：包含MySQL解决查询的详细信息</li>
</ul>
<p>分析执行计划时，需要注意以下几个方面：</p>
<ul>
<li>扫描行数：rows字段，表示查询所需扫描的行数，如果该值过大，说明查询效率不高，需要优化</li>
<li>使用索引：key字段，表示查询使用的索引，如果没有使用索引或者使用的不是最优索引，需要考虑优化</li>
<li>排序：Extra字段，如果查询需要使用filesort排序，说明查询效率不高，需要优化</li>
<li>嵌套循环：如果查询类型时 nested loop，说明查询中包含嵌套循环，也需要考虑优化</li>
</ul>
<p>通过分析执行计划，可以确定查询优化的方法和方向，提高查询效率</p>
<h2 id="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"><a href="#什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？" class="headerlink" title="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"></a>什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？</h2><p>单例模式时一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式的目的是确保类的一个唯一实例，因此其他类可以轻松的从一个可知的地方访问它</p>
<p>单例模式的好处：</p>
<ol>
<li>节省系统资源：在系统中，如果有多个实例会造成资源浪费，而使用单例模式可以减少这种浪费</li>
<li>简化了对象访问，单例模式提供了一个全局访问的访问点，因此可以简化访问过程</li>
</ol>
<p>常用的单例模式实现方式有以下几种：</p>
<ol>
<li>饿汉式单例模式：在类加载时创建单例对象。缺点是不支持延迟加载。</li>
<li>懒汉式单例模式：在第一次使用时才创建单例对象。缺点是需要考虑线程安全问题</li>
<li>双重检查锁单例模式：在第一次使用时创建单例对象，并使用双重检查锁定来确保线程安全</li>
<li>枚举单例模式：在枚举类型中创建单例对象，可以防止反射和序列化攻击</li>
</ol>
<p>应用场景：</p>
<ol>
<li>数据库连接池：通过使用单例模式，可以确保系统中只有一个数据库连接池</li>
<li>日志记录器：可以使用单例模式记录系统日志，这样可以确保系统中只有一个日志记录器</li>
<li>配置文件管理器：可以使用单例模式来管理应用程序的配置文件，这样可以避免重复读取配置文件的开销</li>
<li>线程池：可以使用单例模式来确保系统中中只有一个线程池</li>
</ol>
<p>一个例子时Spring 框架中 ApplicationContext ，它是一个全局访问点，提供了一个管理Bean 的中央注册表。由于 Spring 中的 Bean 只需要创建一次，因此ApplicationContext 使用单例模式确保只有一个实例。</p>
<h2 id="什么是云原生？它有哪些优缺点？"><a href="#什么是云原生？它有哪些优缺点？" class="headerlink" title="什么是云原生？它有哪些优缺点？"></a>什么是云原生？它有哪些优缺点？</h2><p>云原生是一种开发和运行应用程序的方法，旨在利用云计算的弹性，可扩展性，可靠性和高可用性等优势。它通过将应用程序打包到容器中，使用容器编排工具进行管理，实现了应用程序在不同环境中的快速部署，弹性伸缩和高可用性</p>
<p>云原生的优点包括：</p>
<ol>
<li>灵活性和可扩展性：容器可以快速部署和扩展，以满足不同负载要求</li>
<li>高可用性：容器编排工具可以自动检测和恢复容器故障，提供高可用性</li>
<li>效率和成本优化：使用容器可以节省资源和成本，提高应用程序的运行效率</li>
<li>安全性：容器隔离应用程序的运行环境，减少了安全漏洞的风险</li>
</ol>
<p>云原生的缺点：</p>
<ol>
<li>学习曲线较陡峭：云原生技术较为复杂，需要学习一些新技术和工具</li>
<li>可能存在依赖问题：应用程序可能依赖于某些特定的云原生技术或工具，这可能导致一些限制或局限性。</li>
<li>管理和维护难度：容器编排工具可能需要额外的管理和维护，需要更多的操作和维护成本</li>
</ol>
<p>云原生的应用场景包括：</p>
<ol>
<li>微服务架构：云原生技术非常适合构建微服务框架，将应用程序拆分为小型，自治的服务</li>
<li>弹性伸缩：云原生技术可以根据应用程序的负载自动扩展或缩小容器数量，以适应不同负载要求</li>
<li>快速部署：使用云原生技术，可以快速的部署和更新应用程序，提高开发和部署效率</li>
<li>多云部署：云原生技术可以在多个云环境中运行，方便应用程序在不同云环境中的部署和迁移</li>
<li>数据分析和处理：云原生技术可以处理大规模的数据和分析任务，提高数据处理效率</li>
</ol>
<h2 id="TCP-和-UDP-协议有什么区别，分别适用于什么场景？"><a href="#TCP-和-UDP-协议有什么区别，分别适用于什么场景？" class="headerlink" title="TCP 和 UDP 协议有什么区别，分别适用于什么场景？"></a>TCP 和 UDP 协议有什么区别，分别适用于什么场景？</h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常用的传输层协议，它们有以下区别：</p>
<ol>
<li><strong>连接方面</strong>：TCP是面向连接的协议，而UDP是无连接协议。在TCP 中，发送方和接收方必须先建立连接，然后才能传输数据。UDP 则不需要建立连接，直接发送数据即可</li>
<li><strong>可靠性</strong>：TCP 保证数据传输的可靠性，通过序列号，确认应答和重传机制等方式来保证数据的完整性和正确性。UDP则不保证数据传输的可靠性，因为它不提供确认和重传机制</li>
<li><strong>传输速度</strong>：因为TCP 要保证数据传输的可靠性，所以在传输速度方面相对较慢。而UDP则不需要进行复杂的传输控制，因此传输速度更快</li>
<li><strong>传输内容</strong>：因为TCP 是一种面向字节流的协议，将数据看作是一连串的字节流，没有明确的边界消息。UDP 则是面向报文的协议，将数据看作是一系列的报文，每个报文是一个独立的单元，具有明确的消息边界</li>
</ol>
<p>基于以上特点，TCP 和 UDP 适用于不同场景。TCP 适用于对传输可靠性要求比较高的场景，例如网页浏览，文件传输，邮件等。而UDP则适用于对传输可靠性要求较低，传输速度要求较高的场景，例如在线游戏，视频直播等</p>
<h2 id="什么是分布式的-CAP-理论？"><a href="#什么是分布式的-CAP-理论？" class="headerlink" title="什么是分布式的 CAP 理论？"></a>什么是分布式的 CAP 理论？</h2><p>分布式的CAP 理论是指在分布式系统中，一致性（Consistency），可用性（Availability）和分区容错性（Parttion Tolerance）这三个指标无法同时满足的问题。具体来说：</p>
<ul>
<li><strong>一致性</strong>（Consistency）：指多个副本之间数据保持一致，即在一个副本上的写操作会立刻同步到其他所有副本，所有副本的数据都是最新的，保持强一致性</li>
<li><strong>可用性</strong>（Availability）：指系统在任何时候都能对外提供服务，即系统随时能够响应用户请求，不会因为节点故障或其他原因导致服务中断</li>
<li><strong>分区容错性</strong>（Partition Tolerance）：指系统在出现网络分区（节点之间失去联系）时，仍能够继续工作，保证数据的一致性和可用性</li>
</ul>
<p>CAP 理论指出，一个分布式系统只能同时满足其中的两个指标，无法同时满足三个。例如：当出现网络分区时，如果包保证一致性，就必须停止对外服务，从而失去可用性；如果要保证可用性，就必须放弃一致性，从而可能导致不同节点之间数据不一致。因此，在设计分布式系统时，需要根据具体的场景和需求来选择合适的权衡方案，比如选择CP（一致性和分区容错性）或者选择AP（可用性和分区容错性）</p>
<p>需要注意的是：CAP 理论知识一种理论框架，不能直接应用于实际的分布式系统设计。在实际应用中，还要考虑系统的具体业务需求，数据访问模式，节点规模和部署环境等因素，综合权衡之后再选择合适的分布式框架和技术方案。</p>
<h2 id="如何用-Redis-实现分布式-Session？"><a href="#如何用-Redis-实现分布式-Session？" class="headerlink" title="如何用 Redis 实现分布式 Session？"></a>如何用 Redis 实现分布式 Session？</h2><p>在分布式系统中，通常会将Session 存储在Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享Session数据。实现分布式Session 的方式有多种，其中一种常用的方式是使用Redis 的数据结构Hash 。具体的实现步骤如下：</p>
<ol>
<li>在用户登录成功后，将Session 数据存储在 Redis中</li>
<li>将Redis 的Session 数据 Key 设置为一个全局唯一的 ID，一般使用类似于“ session : token ”的格式，其中token是一个随机生成的字符串，用来表示这个Session 数据</li>
<li>在客户端返回响应的同时，将Session ID（即token）以Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个Cookie</li>
<li>在后续请求中，服务器会从客户端传递过来的Cookie 中获取 Session ID ，然后根据这个 ID 从 Redis 中获取对应的Session 数据。如果Redis 中没有找到对应的Session 数据，那么就表示这个请求无法通过认证</li>
<li>在用户退出登录或 Session 失效时，需要将Redis 中对应的Session 数据删除</li>
</ol>
<p>可以使用Redis 的EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的Session数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的Session ID等方式来提高安全性</p>
<h2 id="MySQL-支持哪些存储引擎？默认使用哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？"></a>MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？</h2><p>MySQL 支持多种存储引擎，包括 InnoDB ，M有ISAM，MEMORY，CSV 等。默认情况下，MySQL 使用的存储引擎是 InnoDB</p>
<p>MyISAM 和 InnoDB 是 MySQL 中 <strong>最常用</strong> 的两种存储引擎，它们有以下区别：</p>
<ol>
<li>锁定方式不同：MyISAM 使用表级锁定，而 InnoDB 使用行级锁定。在并发访问时，InnoDB 的锁定方式更加精确，可以避免锁定整个表，提高了并发性能</li>
<li>数据完整性不同：MyISAM 不支持事务和外键约束，而InnoDB 支持事务和外键约束，可以保证数据的完整性和一致性</li>
<li>读写性能不同：MyISAM 的读写性能相对较高，适合于读密集型应用；而 InnoDB 的写性能相对较高，适合于写密集型应用</li>
<li>空间利用率不同：MyISAM 不支持行级别的存储，存储空间利用率较低；而InnoDB 支持行级别的存储，存储空间利用率更高。</li>
</ol>
<p>在选择MyISAM 和 InnoDB 引擎时，需要考虑应用场景和需求：</p>
<ol>
<li>如果应用主要是读操作，可以考虑选择MyISAM 引擎，以提高读取性能</li>
<li>如果应用主要是写操作或需要支持事务和外键约束，可以考虑选择 InnoDB 引擎，以保证数据的完整性和一致性。</li>
<li>如果需要高性能和高可用性，可以考虑使用MyISAM 集群或使用多个副本实例，并将数据分布在不同节点上</li>
</ol>
<p>总结：MyISAM 支持多种存储引擎，MyISAM 和 InnoDB 是其中最常用的两种，它们有不同的特点和优缺点，在选择时需要根据应用场景和需求进行考虑和权衡。</p>
<h2 id="Spring-中的-BeanFactory-和-ApplicationContext-有什么区别和联系？"><a href="#Spring-中的-BeanFactory-和-ApplicationContext-有什么区别和联系？" class="headerlink" title="Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？"></a>Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？</h2><p>在 Spring 中，BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，它们区别和联系如下。</p>
<p>区别：</p>
<ol>
<li>BeanFactory 是 Spring 框架的基础设施，用于管理Bean 的生命周期和依赖关系，提供了IoC 和 DI 功能。ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化，AOP支持。</li>
<li>BeanFactory 是延迟加载的，即只有在获取Bean 时才会进行实例化，可以减少系统资源的占用。而ApplicationContext 在启动时会立即加载所有的Bean，导致启动时间较长。</li>
<li>BeanFactory 是单例模式，即在整个应用中只有一个BeanFactory 实例。而ApplicationContext 可以有多个实例，并且可以通过父子容器的方式组织起来，方便模块化开发</li>
</ol>
<p>联系：</p>
<ol>
<li>BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，可以管理Bean 的生命周期和依赖关系，提供了IoC 和DI 功能</li>
<li>ApplicationContext 是BeanFactory 的扩展，提供了更多的功能，例如国际化支持，AOP支持等，同时也支持BeanFactory 的所有功能</li>
<li>BeanFactory 和 ApplicationContext 都可以通过 XML配置文件，Java注解和Java代码等方式进行配置和管理</li>
<li>BeanFactory 和 ApplicationContext 都可以管理单例Bean 和原型 Bean，可以控制Bean 的作用域和生命周期</li>
</ol>
<p>总结：BeanFactory 是 Spring 框架的基础设施，提供了IoC 和 DI 功能，而ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能和扩展性，可以通过多种方式进行配置和管理 Spring Bean</p>
<h2 id="讲一下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？"><a href="#讲一下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？" class="headerlink" title="讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？"></a>讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？</h2><p>Redis 是一种基于内存的键数据库，鱿鱼内存有限，当Redis 占用内存到达上限时，就需要进行内存淘汰，以腾出一些内存空间</p>
<p>Redis 中的内存淘汰机制包括：</p>
<ol>
<li>定期删除：Redis 可以设置一个定时器，定期扫描空间中的键，并删除已经过期的键</li>
<li>惰性删除：当一个键过期时，Redis不会立刻删除该键，而是等到该键被访问时再删除</li>
<li>内存淘汰测略：当Redis 内存占用达到上限时，会根据内存淘汰测略来选择一些键进行删除，以腾出更多的内存空间</li>
</ol>
<p>Redis 中的内存淘汰测略包括：</p>
<ol>
<li>不删除 key ，当到达最大阈值后报错 ：<strong>noeviction</strong></li>
<li>设过期 key 中选择使用数最小的 ：<strong>volatile - lrw</strong></li>
<li>在所有 key 中选择使用数最小的 ：<strong>allkeys - lru</strong></li>
<li>过期 key 中使用 lfu 算法 ：<strong>volatile - lfu</strong></li>
<li>所有 key 用 lfu 算法 ：<strong>allkeys - lfu</strong></li>
<li>过期 key 随机删除 ：<strong>volatile - random</strong></li>
<li>所有 key 碎甲删除 ：<strong>allkeys - random</strong></li>
<li>过期 key 中最早过期的删除 : <strong>volatile - ttl</strong></li>
</ol>
<p><strong>lru：最近最少使用，实现方式：使用一个链表，被使用就放到表头，其他后推，超过表尾的就删除</strong> </p>
<p>lfu：最近最不经常使用，实现方式：使用一个计数器</p>
<p>其中，noeviction 策略是最简单的策略，但可能会导致Redis 内存占满，并导致 Redis 无法正常工作。其他策略会根据不同算法进行键的选择和删除，以尽可能保留重要的键</p>
<p>总之，Redis 中的内存淘汰机制是保证 Redis 正常运行的重要机制之一，内存淘汰策略则根据不同的场景选择合适的策略来删除不必要的键，以腾出更多的内存空间</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xcscx.github.io">IT蛋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xcscx.github.io/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/">https://xcscx.github.io/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xcscx.github.io" target="_blank">IT蛋的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&amp;rs=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/" title="java基础面试题1"><img class="cover" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java基础面试题1</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/16/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%983/" title="java基础面试题3"><img class="cover" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础面试题3</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="HashMap常见问题"><img class="cover" src="https://www.javazhiyin.com/wp-content/uploads/2019/11/HashMap-structure.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-20</div><div class="title">HashMap常见问题</div></div></a></div><div><a href="/2023/03/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/" title="java基础面试题1"><img class="cover" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&rs=1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="title">java基础面试题1</div></div></a></div><div><a href="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" title="程序设计结构"><img class="cover" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&rs=1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-11</div><div class="title">程序设计结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">IT蛋</div><div class="author-info__description">编程学习记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xcscx"><i class="fab fa-github"></i><span>博主的github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xcscx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1362067461@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"></div></div></main><footer id="footer" style="background-image: url('https://tse2-mm.cn.bing.net/th/id/OIP-C.eyZIbvHg_jBzUkFc1ffFIgHaEo?pid=ImgDet&amp;rs=1')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By IT蛋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱国,敬业,诚信,友善" data-fontsize="10px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>