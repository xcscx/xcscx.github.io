<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>D</title>
      <link href="/2023/09/01/Java%E5%9F%BA%E7%A1%80/Java%E8%A1%A5%E8%B6%B3-%E5%9F%BA%E7%A1%80/9m1d/"/>
      <url>/2023/09/01/Java%E5%9F%BA%E7%A1%80/Java%E8%A1%A5%E8%B6%B3-%E5%9F%BA%E7%A1%80/9m1d/</url>
      
        <content type="html"><![CDATA[<h3 id="System输出"><a href="#System输出" class="headerlink" title="System输出"></a>System输出</h3><p>System.err.println() : 错误输出，输出的内容为红色</p><p>System.out.println() : 常规输出，输出的内容为白色</p><h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>接口中的变量默认：public static final</p><p>方法中的变量默认：public abstract</p><h3 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h3><ol><li>数组初始化后所占空间是固定的</li><li>数组相等的判断需要使用Arrays.equals()，进行逐个对比</li><li>因为数组是对象，所以java是存储到堆中的</li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>父类静态 —— 子类金泰 —— 父类构造代码块 —— 父类构造方法 —— 子类构造代码块 —— 子类构造方法</p><h3 id="关于private"><a href="#关于private" class="headerlink" title="关于private"></a>关于private</h3><p>只有本类和反射可以访问到</p><p>注意：一个java文件不能有两个public，且子类作用域不可以访问父类私有变量</p><p>（如果父类有private属性，子类无法访问到该私有变量）</p><h3 id="Integer对比"><a href="#Integer对比" class="headerlink" title="Integer对比"></a>Integer对比</h3><p>小于127的Integer值可以相互间直接比较，会作为数值直接比较</p><p>大于127的Integer与int类型可以直接比较，会作为数值直接比较</p><p>但是大于127的Integer不可以相互比较，会作为对象进行地址比较</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传常见问题汇总</title>
      <link href="/2023/05/22/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/Git%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2023/05/22/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/Git%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Git上传常见问题"><a href="#Git上传常见问题" class="headerlink" title="Git上传常见问题"></a>Git上传常见问题</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>在 GitHub 上，一些仓库可能具有两个分支：main 和 master。如果您想将这两个分支合并成一个分支，可以按照以下步骤操作：</p><ol><li><p>确认您已经克隆了该仓库。在终端运行以下命令以克隆该仓库：</p><pre><code>Copy Codegit clone https://github.com/username/repo.git</code></pre></li><li><p>切换到 main 分支。在终端运行以下命令以切换到 main 分支：</p><pre><code>Copy Codegit checkout main</code></pre></li><li><p>将 master 分支合并到 main 分支。在终端运行以下命令以将 master 分支合并到 main 分支：</p><pre><code>Copy Codegit merge master</code></pre></li><li><p>推送变更。在终端运行以下命令以将本地变更推送到远程仓库：</p><pre><code>Copy Codegit push origin main</code></pre></li><li><p>可选：删除 master 分支。如果您已将 master 分支合并到 main 分支，并且您不再需要 master 分支，您可以删除它。在终端运行以下命令以删除 master 分支：</p><pre><code>Copy Codegit branch -d mastergit push origin --delete master</code></pre></li></ol><p>请注意，在某些情况下，您可能无法删除 master 分支。如果您收到错误消息，请检查您是否有足够的权限来执行此操作。</p><h3 id="将本地的master分支改名为main"><a href="#将本地的master分支改名为main" class="headerlink" title="将本地的master分支改名为main"></a>将本地的master分支改名为main</h3><p>在 Git 中，将默认分支从 master 改为 main 已成为一种常见的做法。您可以按照以下步骤将本地的 master 分支重命名为 main 分支：</p><ol><li><p>确保您当前在 master 分支上</p><p>在终端中，使用以下命令查看当前所在的分支：</p><pre><code>Copy Codegit branch</code></pre><p>如果 “*” 符号出现在 master 分支前面，则说明您已经在 master 分支上。否则，请使用以下命令切换到 master 分支：</p><pre><code>Copy Codegit checkout master</code></pre></li><li><p>创建一个新的 main 分支</p><p>接下来，您需要创建一个新的 main 分支。在终端中，使用以下命令创建新分支并切换到该分支：</p><pre><code>Copy Codegit branch -m master main</code></pre><p>这将会把 master 分支重命名为 main 分支，并将当前分支切换为 main 分支。</p></li><li><p>推送更改到远程仓库</p><p>最后，您需要将更改推送到您的远程仓库。在终端中，使用以下命令将本地的 main 分支推送到远程仓库：</p><pre><code>Copy Codegit push -u origin main</code></pre><p>这将会把本地的 main 分支推送到名为 origin 的远程仓库，并设置跟踪关系。</p></li></ol><p>现在，您已经成功地将您的本地 master 分支重命名为 main 分支，并将更改推送到了远程仓库。</p><h3 id="删除本地main分支，将本地new-branch改名为main"><a href="#删除本地main分支，将本地new-branch改名为main" class="headerlink" title="删除本地main分支，将本地new_branch改名为main"></a>删除本地main分支，将本地new_branch改名为main</h3><p>您可以按照以下步骤删除本地的 <code>main</code> 分支，并将本地的 <code>new_branch</code> 分支重命名为 <code>main</code> 分支：</p><ol><li><p>确定您当前所在的分支。在终端中，输入以下命令：</p><pre><code>Copy Codegit branch</code></pre><p>这将显示您当前所有的本地分支。当前所在的分支前面会有一个星号 (* )。</p></li><li><p>如果您当前所在的分支是 <code>main</code> 分支，请切换到其他分支。在终端中，输入以下命令：</p><pre><code>Copy Codegit checkout another-branch</code></pre><p>其中 <code>another-branch</code> 就是您要切换到的分支名称。</p></li><li><p>删除本地的 <code>main</code> 分支。在终端中，输入以下命令：</p><pre><code>Copy Codegit branch -d main</code></pre><p>如果出现警告信息，说明该分支还有部分提交未合并到其他分支，可以使用 <code>-D</code> 选项代替 <code>-d</code> 选项，强制删除该分支。</p></li><li><p>切换到 <code>new_branch</code> 分支。在终端中，输入以下命令：</p><pre><code>Copy Codegit checkout new_branch</code></pre></li><li><p>将 <code>new_branch</code> 分支重命名为 <code>main</code>。在终端中，输入以下命令：</p><pre><code>Copy Codegit branch -m main</code></pre><p>这将把 <code>new_branch</code> 分支重命名为 <code>main</code> 分支。</p></li></ol><p>现在您已成功删除本地的 <code>main</code> 分支，并将本地的 <code>new_branch</code> 分支重命名为 <code>main</code> 分支。请注意，这些更改不会自动同步到远程仓库。如果您想将此更改推送到远程仓库，请执行以下命令：</p><pre><code>Copy Codegit push -u origin main</code></pre><p>这会将您的本地 <code>main</code> 分支推送到远程仓库，并通过 <code>-u</code> 选项设置该分支为远程跟踪分支。</p><p>或者</p><p>手动在github上完成分支默认和删除</p><h3 id="git-push-origin-main回复-Everything-up-to-date"><a href="#git-push-origin-main回复-Everything-up-to-date" class="headerlink" title="git push origin main回复 Everything up-to-date"></a>git push origin main回复 Everything up-to-date</h3><p>如果您在使用 <code>git push origin main</code> 命令时看到 “Everything up-to-date” 的提示，这意味着您的本地 <code>main</code> 分支已经与远程仓库中的 <code>main</code> 分支保持一致，不需要再次推送更新。</p><p>这通常发生在以下两种情况下：</p><ol><li>如果您之前已经向远程仓库推送过相同的提交，并且没有进行任何本地更改，则再次运行 <code>git push origin main</code> 会显示 “Everything up-to-date” 的提示。</li><li>如果在您推送之前，其他人先于您向远程仓库推送了相同的提交，则您的推送将被视为无效，因为您试图将相同的提交再次推送到远程仓库。此时，运行 <code>git pull</code> 命令可以帮助您拉取最新的远程更改，然后再执行 <code>git push origin main</code> 命令进行推送。</li></ol><p>如果您确信本地分支存在提交未推送到远程仓库中，则可以通过 <code>git log</code> 命令查看本地分支和远程分支之间的差异。例如，输入以下命令：</p><pre><code>Copy Codegit log origin/main..main</code></pre><p>这将显示本地 <code>main</code> 分支中存在但尚未推送到远程仓库的提交。如果您想将这些提交推送到远程仓库，请再次运行 <code>git push origin main</code> 命令。</p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><h3 id="个人项目编写提交的话，Generate-new-token中需要哪些权限"><a href="#个人项目编写提交的话，Generate-new-token中需要哪些权限" class="headerlink" title="个人项目编写提交的话，Generate new token中需要哪些权限"></a>个人项目编写提交的话，Generate new token中需要哪些权限</h3><p>一般情况下，在个人项目编写提交的话，以下权限应该足够：</p><ul><li>repo - 所有仓库</li><li>workflow - 工作流程</li></ul><p>这些权限将使您能够执行各种操作，例如读取和写入您的仓库、管理工作流程等。</p><p>在创建 Personal Access Token 时，您可以勾选以下权限：</p><ul><li>repo: Full control of private repositories</li><li>workflow: Read and write access to actions, workflows, and related settings</li></ul><p>当然，如果您只需读取或写入特定存储库，则可以仅授予该存储库的相关权限，而不必授予所有仓库的权限。</p><p>请注意，这些权限越高，就越容易对您的账户造成安全风险，请根据自己的实际需求，适当选择权限。同时，也要注意妥善保管您的 Personal Access Token，不要将其泄露给他人。</p><h3 id="创建-Personal-Access-Token-时，常用的权限选项及其作用和使用场景"><a href="#创建-Personal-Access-Token-时，常用的权限选项及其作用和使用场景" class="headerlink" title="创建 Personal Access Token 时，常用的权限选项及其作用和使用场景"></a>创建 Personal Access Token 时，常用的权限选项及其作用和使用场景</h3><ul><li>repo：完全控制私有存储库。这个权限使您能够读取和写入您拥有的所有私有存储库。这个选项适用于您要在私有存储库中进行操作的情况。</li><li>admin:org：完全控制组织。这个权限使您能够对组织中的成员、存储库和团队进行完全的管理。如果您是组织所有者或管理员，这个选项非常有用。</li><li>user：读取您的个人资料信息。这个权限使您能够读取您的 GitHub 个人资料信息，例如您的用户名、电子邮件地址和用户 ID。</li><li>workflow：读取和写入操作、工作流程和相关设置。这个权限使您能够读取和写入操作、工作流程和相关设置。如果您使用 GitHub Actions 自动化持续集成和部署，这个选项非常有用。</li><li>read:packages：读取包的注册表数据。如果您使用 GitHub Packages 来管理软件包，则需要使用此权限才能读取包的注册表数据。</li><li>write:packages：上传、删除、更新和安装包。如果您使用 GitHub Packages 来管理软件包，则需要使用此权限才能上传、删除、更新和安装包。</li></ul><h3 id="在终端中将本地仓库与远程仓库关联该如何实现，-remote-repository-URL-要如何填写"><a href="#在终端中将本地仓库与远程仓库关联该如何实现，-remote-repository-URL-要如何填写" class="headerlink" title="在终端中将本地仓库与远程仓库关联该如何实现，[remote repository URL]要如何填写"></a>在终端中将本地仓库与远程仓库关联该如何实现，[remote repository URL]要如何填写</h3><p>将本地仓库与远程仓库进行关联，需要您提供一个远程仓库的 URL 地址。如果您使用的是 GitHub 等托管服务提供商，则可以在您的仓库页面上找到该地址。在 GitHub 中，可以点击绿色的“Code”按钮，然后通过复制 HTTPS 或 SSH 链接来获取该地址。</p><p>在终端中，使用以下命令将本地仓库与远程仓库进行关联：</p><pre><code>Copy Codegit remote add origin [remote repository URL]</code></pre><p>将 <code>[remote repository URL]</code> 替换为您从托管服务提供商处获得的远程仓库 URL 地址。</p><p>例如，在 GitHub 上，如果您的用户名是 <code>myusername</code>，您的项目名称是 <code>myproject</code>，则远程仓库的 HTTPS 地址可能如下所示：</p><pre><code>Copy Codehttps://github.com/myusername/myproject.git</code></pre><p>将此地址复制到 <code>git remote add origin [remote repository URL]</code> 的方括号中，如下所示：</p><pre><code>Copy Codegit remote add origin https://github.com/myusername/myproject.git</code></pre><p>然后运行该命令，即可将本地仓库与远程仓库进行关联。</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><pre><code>// 分支推送错误error: src refspec main does not match any error: failed to push some refs to &#39;https://github.com/***/aaa.git&#39;</code></pre><p>这个错误通常表示你正在尝试推送到 GitHub 仓库中不存在的分支。请确保本地 Git 项目中的分支名称与要推送到的远程分支名称相匹配。如果本地存在 <code>main</code> 分支，但是在远程 GitHub 仓库中不存在 <code>main</code> 分支，则需要在远程仓库中创建该分支：</p><pre><code>Copy Codegit push --set-upstream origin main</code></pre><p>这将在远程 GitHub 仓库中创建一个新的 <code>main</code> 分支，并将您的本地 Git 项目的更改推送到该分支上。</p><pre><code>// 合并无重合问题\* branch            main       -&gt; FETCH_HEAD fatal: refusing to merge unrelated histories</code></pre><p>出现 “fatal: refusing to merge unrelated histories” 错误是因为 Git 认为你试图合并两个没有共同祖先的分支。这通常发生在你尝试将两个独立的 Git 仓库合并到一起时。Git 希望能根据一些共同的提交点来自动合并这些历史，但是在这种情况下，这不可能。</p><p>要解决这个问题，请按照以下步骤操作：</p><ol><li><p>创建一个新的空白分支</p><p>在本地仓库中，执行以下命令创建一个新的空白分支：</p><pre><code>Copy Codegit checkout --orphan new_branch</code></pre></li><li><p>commit 空仓库</p><p>执行以下命令以提交一个空的 commit：</p><pre><code>Copy Codegit commit --allow-empty -m &quot;Initial commit&quot;</code></pre></li><li><p>合并分支</p><p>执行以下命令以合并原始分支（例如 main）到新分支中：</p><pre><code>Copy Codegit merge main --allow-unrelated-histories</code></pre></li><li><p>解决冲突</p><p>如果出现冲突，请解决它们并提交更改。</p></li><li><p>push 代码</p><p>执行以下命令将更改推送到远程仓库中：</p><pre><code>Copy Codegit push origin new_branch</code></pre></li></ol><pre><code>remote: Support for password authentication was removed on August 13, 2021. remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of a uthentication. fatal: Authentication failed for &#39;https://github.com/***/aaa.git/&#39;</code></pre><p>这个错误是因为您正在使用 HTTPS URL 作为 Git 远程仓库的地址，而不是 SSH URL。如果您使用 HTTPS URL，您需要在每次推送时输入用户名和密码。</p><p>为了避免每次都需要输入用户名和密码，并确保安全，在您的本地计算机上配置 SSH 密钥，以便您可以通过 SSH URL 连接到远程仓库。这样就不需要输入密码来验证每次 push 或 pull 操作。</p><p>以下是配置 SSH 密钥的步骤：</p><ol><li><p>生成 SSH 密钥</p><p>执行以下命令以生成 SSH 密钥：</p><pre><code>Copy Codessh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code></pre><p>将 “<a href="mailto:your_email@example.com">your_email@example.com</a>“ 替换为您的电子邮件地址，并按照提示创建 SSH 密钥。</p></li><li><p>添加 SSH 密钥到 Github</p><p>在 Github 网站上添加您的 SSH 密钥。在您的 Github 账户的设置页面中，选择 SSH 和 GPG 密钥，并添加您的公共 SSH 密钥。</p></li><li><p>设置本地 Git 配置</p><p>执行以下命令将您的 SSH 配置添加到本地 Git 配置中：</p><pre><code>Copy Codegit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your_email@example.com&quot;git config --global core.sshCommand &quot;ssh -i ~/.ssh/id_ed25519&quot;</code></pre><p>将 “Your Name” 和 “<a href="mailto:your_email@example.com">your_email@example.com</a>“ 替换为您的姓名和电子邮件地址。</p></li></ol><pre><code>// 网络问题fatal: unable to access &#39;https://github.com/***/aaa.git/&#39;:OpenSSL SSL_read: Connection was aborted, errno 10053</code></pre><p>这个错误的出现通常是由于网络连接问题引起的。其中，errno 10053 表示在套接字操作期间发生了无效的中断。</p><p>为了解决这个问题，可以采取以下一些步骤：</p><ol><li><p>检查网络连接</p><p>首先，请检查网络连接是否正常。尝试访问其他网站或使用其他应用程序来确定网络连接是否正常工作。如果您的网络连接存在问题，请尝试重新启动您的路由器或计算机，并确保您连接到一个稳定的网络。</p></li><li><p>检查代理设置</p><p>如果你使用代理服务器来访问互联网，则可能需要检查代理设置。请确保代理设置正确，并且已经设置了 HTTPS 代理。</p></li><li><p>检查防火墙设置</p><p>如果你的计算机上安装了防火墙软件，则可能会阻止 Git 进行网络连接。请确保你的防火墙允许 Git 进行网络连接，并将其添加到允许列表中。</p></li><li><p>尝试使用 SSH 协议</p><p>如果无法通过 HTTPS 协议进行推送，则可以尝试使用 SSH 协议。请使用以下命令将远程仓库的 URL 更改为使用 SSH 协议：</p><pre><code>Copy Codegit remote set-url origin git@github.com:xcscx/IBI-program.git</code></pre><p>这将把远程仓库的 URL 更改为使用 SSH 协议，而不是 HTTPS 协议。</p></li></ol><pre><code>// 超时连接fatal: unable to access &#39;https://github.com/***/aaa.git/&#39;: Failed to connect to github.com port 443 after 21057 ms: Timed out</code></pre><p>这个错误通常意味着 Git 无法连接到 GitHub 的服务器。其中，”Failed to connect to <a href="http://github.com/">github.com</a> port 443” 的部分表示无法连接到 GitHub 的默认 HTTPS 端口（端口号为 443），”Timed out after 21057 ms” 的部分表示连接超时。</p><p>要解决这个问题，请按照以下步骤进行：</p><ol><li><p>检查网络连接</p><p>首先，请确保计算机已连接到互联网，并检查网络连接是否正常工作。尝试在终端中 ping <a href="http://github.com/">github.com</a> 来测试电脑与 GitHub 的连接。</p></li><li><p>检查防火墙设置</p><p>如果计算机上安装了防火墙软件，则可能会阻止 Git 进行网络连接。请确保防火墙允许 Git 进行网络连接，并将其添加到允许列表中。</p></li><li><p>尝试使用 SSH 协议</p><p>如果无法通过 HTTPS 协议进行连接，则可以尝试使用 SSH 协议。请使用以下命令将远程仓库的 URL 更改为使用 SSH 协议：</p><pre><code>Copy Codegit remote set-url origin git@github.com:xcscx/IBI-program.git</code></pre><p>这将把远程仓库的 URL 更改为使用 SSH 协议，而不是 HTTPS 协议。</p></li><li><p>等待一段时间后重试</p><p>在某些情况下，GitHub 可能会出现连接问题或临时的服务中断。如果这是一个临时问题，请稍等一会儿，然后重试。</p></li></ol><pre><code>! [rejected]        main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/***/aaa.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code></pre><p>这个错误说明在推送代码时，您尝试推送到的 Git 分支比远程仓库中的分支要落后，而且远程仓库可能已经有了您没有的提交记录。为了解决这个问题，您需要先将远程仓库中的更改合并到本地仓库中，然后再尝试推送您的代码。</p><p>请按照以下步骤进行：</p><ol><li><p>拉取远程仓库中的更改</p><p>执行以下命令将远程仓库中的更改合并到本地仓库中：</p><pre><code>Copy Codegit pull origin main</code></pre><p>这会将远程仓库中的更改下载到本地仓库，并尝试将它们合并到您当前所在的分支中。</p></li><li><p>处理可能出现的冲突</p><p>如果发生了代码冲突，请在合并更改前处理它们。您可以使用一个文本编辑器或一些 Git 工具来解决这些冲突。</p></li><li><p>提交代码变更</p><p>一旦您处理完可能出现的冲突并修复了您的代码，就使用以下命令提交您的代码变更：</p><pre><code>Copy Codegit add .git commit -m &quot;your commit message&quot;</code></pre></li><li><p>推送您的变更</p><p>最后，执行以下命令将您的代码推送到远程仓库中：</p><pre><code>Copy Codegit push origin main</code></pre><p>这将会将您的本地代码推送到远程仓库中，从而使远程仓库保持最新。</p></li></ol><pre><code class="命令提示行">hint: You&#39;ve added another git repository inside your current repository. hint: Clones of the outer repository will not contain the contents of hint: the embedded repository and will not know how to obtain it. hint: If you meant to add a submodule, use: hint:   git submodule add &lt;url&gt; aaahint:  If you added this path by mistake, you can remove it from the hint: index with: hint:   git rm --cached IBI-frontend hint: hint: See &quot;git help submodule&quot; for more information.</code></pre><p>该错误消息意味着您试图在已经存在的 git 仓库中添加另一个 git 仓库。这通常发生在您尝试将另一个 git 仓库作为子模块添加到父仓库中，但却不是以正确的方式进行操作。</p><p>为了解决此问题，您可以按照下面的步骤之一进行操作：</p><ol><li><p>将前端代码文件夹从现有 git 仓库中删除</p><p>这是最简单的解决方案。在终端中，进入您的现有 git 仓库，然后使用以下命令将前端代码文件夹从索引中删除：</p><pre><code>Copy Codegit rm --cached IBI-frontend</code></pre><p>接下来，提交更改并将其推送到远程仓库：</p><pre><code>Copy Codegit commit -m &quot;Remove duplicate repository&quot;git push origin &lt;branch-name&gt;</code></pre><p>然后再将前端代码文件夹作为一个全新的 git 仓库添加到您的项目中。</p></li><li><p>将前端代码文件夹作为子模块添加到现有 git 仓库中</p><p>如果您确实需要将前端代码文件夹添加到现有 git 仓库中，那么最好的方法是将其作为子模块添加。在终端中，进入您的现有 git 仓库，然后使用以下命令将前端代码文件夹作为子模块添加：</p><pre><code>Copy Codegit submodule add &lt;url&gt; IBI-frontend</code></pre><p>其中，<code>&lt;url&gt;</code>是前端代码的 git 仓库 URL 地址。这将在您的现有仓库中创建一个名为 <code>IBI-frontend</code> 的新目录，其中包含前端代码的子模块。</p><p>接下来，提交更改并将其推送到远程仓库：</p><pre><code>Copy Codegit commit -m &quot;Add IBI-frontend submodule&quot;git push origin &lt;branch-name&gt;</code></pre></li></ol><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="本地git上传到github"><a href="#本地git上传到github" class="headerlink" title="本地git上传到github"></a>本地git上传到github</h3><ol><li><p>在 GitHub 上创建一个新的仓库。您可以通过访问您的 GitHub 帐户并在仓库中单击 “New” 按钮来完成此操作。</p></li><li><p>在本地计算机上打开终端或命令行，导航到您的本地 Git 项目的根目录。</p></li><li><p>运行以下命令以将其与远程 GitHub 仓库关联（请将下面的 <code>&lt;your-github-username&gt;</code> 和 <code>&lt;your-repo&gt;</code> 替换为您的 GitHub 用户名和仓库名称）：</p><pre><code>Copy Codegit remote add origin https://github.com/&lt;your-github-username&gt;/&lt;your-repo&gt;.git</code></pre></li><li><p>将代码推送到 GitHub 仓库。首先，将本地 Git 项目提交到本地分支：</p><pre><code>Copy Codegit add .git commit -m &quot;Initial commit&quot;</code></pre><p>然后，将本地分支推送到远程仓库：</p><pre><code>Copy Codegit push -u origin main</code></pre><p>如果您没有使用特定的分支名称，请将 <code>main</code> 替换为您正在使用的分支名称。</p></li><li><p>等待推送过程完成，并在 GitHub 上刷新页面，您应该能够看到您的代码已经推送到了新的仓库中。</p></li></ol><h3 id="命令行中cd-git找不到指定路径，但是dir可以显示git文件夹"><a href="#命令行中cd-git找不到指定路径，但是dir可以显示git文件夹" class="headerlink" title="命令行中cd \git找不到指定路径，但是dir可以显示git文件夹"></a>命令行中cd \git找不到指定路径，但是dir可以显示git文件夹</h3><p>在命令行中输入 <code>cd</code> 命令并添加双引号，其中包含目标路径，请确保路径正确，如下所示：</p><pre><code>Copy Codecd &quot;\git&quot;</code></pre><p>如果以上方法仍然无法解决问题，则可能是因为 Git 安装路径中包含空格。在这种情况下，可以试试使用短路径名称代替完整路径名称。首先，使用 <code>DIR /X</code> 命令列出目标路径的短路径名称：</p><pre><code>Copy Codedir /x</code></pre><p>该命令将列出所有文件和目录的详细信息，包括短路径名称。找到包含 Git 的目录并查看其短路径名称。例如，如果 Git 目录的完整路径为 <code>C:\Program Files\Git</code>，则可能的短路径名称为 <code>C:\Progra~1\Git</code>。</p><p>确定了 Git 目录的短路径名称，就可以使用该名称进行切换。例如：</p><pre><code>Copy Codecd C:\Progra~1\Git</code></pre><h3 id="本地-Git-项目的根目录是指项目地址还是git的安装地址"><a href="#本地-Git-项目的根目录是指项目地址还是git的安装地址" class="headerlink" title="本地 Git 项目的根目录是指项目地址还是git的安装地址"></a>本地 Git 项目的根目录是指项目地址还是git的安装地址</h3><p>本地 Git 项目的根目录是指在本地计算机上克隆或创建 Git 仓库时所使用的目录。这通常是存储代码文件和 Git 信息的本地目录。在使用 <code>git init</code> 命令创建新的 Git 仓库时，该命令会在当前工作目录（即在命令行中所在的目录）中创建一个空的 Git 仓库。在克隆远程 Git 仓库时，Git 将会为该仓库在所指定的目录中创建一个副本。</p><p>因此，通常情况下，本地 Git 项目的根目录是指存储代码文件和 Git 信息的本地目录，在该目录下可以找到 <code>.git</code> 目录，该目录包含 Git 仓库的所有信息。Git 的安装目录通常已经预定义在系统的 PATH 环境变量中，而不是本地 Git 项目的根目录。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java重写与重载</title>
      <link href="/2023/05/08/Java%E5%9F%BA%E7%A1%80/Java%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/05/08/Java%E5%9F%BA%E7%A1%80/Java%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><ul><li>什么是重写</li><li>什么是重载</li><li>常见的面试题</li></ul><h3 id="什么是重写"><a href="#什么是重写" class="headerlink" title="什么是重写"></a>什么是重写</h3><p>子类对父类中已有的方法进行重新定义，让子类可以根据自己需要重新实现父类继承的方法</p><p><strong>子类重新实现父类方法</strong></p><p>重写要求：</p><pre><code>        1. 子类重写方法必须与父类中被重写的方法具有相同的方法名称，返回类型和参数列表        2. 子类重写方法的访问权限不能低于父类被重写的方法的访问权限        3. 子类重写的方法不能抛出比父类被重写方法更多或更宽泛的异常        4. 子类无法重写父类中被final关键词修饰的方法</code></pre><p>需要重写的情况：</p><ol><li>子类需要根据自己的需要来重新实现父类继承的方法，来实现自己特有的功能</li><li>父类中的方法对于子类来说并不合适，需要重新实现</li><li>父类的方法存在缺陷或需要改进，子类需要重新实现以改进原有功能</li></ol><p>特殊情况：<strong>重写方法的返回值类型可以是父类方法返回值类型的子类</strong>，这个特性在java5后出现，也被称作是Java中的”协变返回类型”</p><p>需要满足：</p><pre><code>    1. 返回值类型为父类返回类型的子类    2. 方法参数列表及访问修饰符都与父类方法相同或更为宽松</code></pre><h3 id="什么是重载"><a href="#什么是重载" class="headerlink" title="什么是重载"></a>什么是重载</h3><p>在同一个类中，可以定义多个具有相同方法名但是参数类型，参数顺序或参数个数不同的方法，即不同的方法签名对应不同的方法体</p><p><strong>定义重名但是参数不同的方法</strong></p><p>重载要求：</p><pre><code>           1. 方法名必须相同           2. 参数列表必须不同，比如参数类型不同，参数顺序和参数个数           3. 方法返回类型可以不同，但这不能作为区分两个方法是否相同的依据           4. 访问修饰符和异常类型的不同不足以构成方法重载</code></pre><p>需要重载的情况：</p><ol><li>在同一个类中，需要定义多个具有相同方法名但参数类型，参数顺序或参数不同的方法，以便根据不同的参数组合来执行不同的操作</li><li>在继承体系中，子类需要重新定义父类已有的方法，并且需要使用父类方法相同的方法名，但是参数类型，参数顺序或参数个数可能不同。重载拓展了Java方法命名的灵活性和可读性，提高了程序代码的可重用性，可扩展性和维护性。依据实际需求，合理的使用方法重载可以让程序更加简洁，优雅和高效</li></ol><h3 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h3><ol><li>重载和重写的区别是什么？</li></ol><p>答：重载（Overloading）指在同一个类中，可以定义多个具有相同方法名但参数类型、参数顺序或参数个数不同的方法。而重写（Override）指在继承体系中，子类重新实现其父类中已有的方法。重载和重写的最大区别就是重载是同一个类中的方法之间的多态，而重写则是子类覆盖父类的方法实现，实现多态的一种方式。</p><ol start="2"><li>方法的返回值类型是否可以作为重载的区分标准？</li></ol><p>答：不能。重载的区分标准必须基于参数列表的不同，而不能基于方法的返回值类型。因为重载方法的返回值类型并不影响编译器调用哪个方法，它只是方法的属性之一，并不应该作为重载的区分标准。</p><ol start="3"><li>子类可以继承父类的私有方法吗？</li></ol><p>答：不可以。父类中的私有方法对子类而言是不可见的，并且没有任何继承的意义，因此子类也无法重写私有方法。如果需要在子类中使用父类中的某个方法，可以将其定义为受保护的或公共的方法。</p><ol start="4"><li>在一个类中，可以同时存在重载和重写吗？</li></ol><p>答：可以。在一个类中，可以定义多个同名方法并且它们的参数列表不同，这就是方法的重载；同时，如果子类需要重新实现父类中已有的方法，则可以通过方法的重写来实现。这两个概念并不冲突，而是Java中非常重要的面向对象编程特性。</p><ol start="5"><li>什么是抽象方法？它们可以被重载吗？</li></ol><p>答：抽象方法指在一个抽象类或接口中声明的但没有实现的方法，它没有具体的方法体，只有方法签名。因为抽象方法没有实现，所以不能直接调用，必须由子类来实现具体的方法体。因为子类需要覆盖实现父类中的抽象方法，所以它们不能被重载，只能被重写。</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java接口与抽象类</title>
      <link href="/2023/05/06/Java%E5%9F%BA%E7%A1%80/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2023/05/06/Java%E5%9F%BA%E7%A1%80/Java%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><ul><li>什么是接口</li><li>什么是抽象类</li><li>接口与抽象类的相同点</li><li>接口与抽象类的不同点</li><li>常见面试题</li></ul><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>Java 中的一种特殊数据类型，可以被看作是一个纯粹的规范或者协议，它声明了一组方法的签名，但不包含任何实现代码</p><p><strong>简单来说：负责声明方法，但不实现方法</strong></p><p>特点：interface关键字修饰，不能实例化</p><p>作用：分离接口与实现，使得代码修改时与接口本身无关</p><p>实现要求：1. 类使用 implements 关键字实现接口，实现（重写）接口中所有方法</p><p>​   2. 实现方法时：方法名称，参数列表（甚至参数顺序），返回类型都要与接口一致 </p><p>​   3. 实现类重写方法时必须使用 public 访问修饰符（重写的要求就是访问修饰符要和父类访问一致或更加宽松，接口设计初衷就是为了给外部调用，所以接口方法默认 public , 实现类也就需要是public）</p><p>​   4. 实现类不能完全实现接口时，实现类应该声明为抽象类</p><p>​   5. 一个实现类可以实现多个接口，中间使用逗号隔开</p><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><p>Java 中一种实现抽象的机制，它是一种不能直接实例化的类, 只能作为基类存在，其目的是为了让子类继承并实现其中定义的抽象方法</p><p><strong>简单来说：提取相关子类的公共行为</strong></p><p>特点：可以有成员变量和实现方法给子类用，有 abstracrt 关键字修饰，不能实例化</p><p>作用：提高代码复用</p><p>实现要求：1. 一个子类必须实现其继承抽象类的全部抽象方法，否则该子类也必须被定义为抽象类</p><p>​   2. 抽象类中实例变量和方法可以被子类直接调用</p><p>​   3. 抽象类可以有构造方法，但不能直接实例化</p><h3 id="接口与抽象类的相同点"><a href="#接口与抽象类的相同点" class="headerlink" title="接口与抽象类的相同点"></a>接口与抽象类的相同点</h3><ol><li>都不能用于实例化对象，只能用作规范或者模板</li><li>都可以被实现类或子类继承或实现</li></ol><h3 id="接口与抽象类的不同点"><a href="#接口与抽象类的不同点" class="headerlink" title="接口与抽象类的不同点"></a>接口与抽象类的不同点</h3><ol><li>实现方式不同：接口只能定义方法签名，不能包含实现，而抽象类可以包含具体的方法实现</li><li>关系不同：实现类可以同时实现多个接口，但只能够继承一个抽象类</li><li>成员变量不同：接口只能包含常量，不能包含成员变量；抽象类可以包含成员变量</li><li>构造器不同：接口没有构造器，而抽象类有构造器</li></ol><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ol><li><strong>Java抽象类可以添加final修饰符吗？</strong></li></ol><p>回答：不可以，被声明为final的类会被阻止继承，而抽象类的作用就是用于继承。</p><ol start="2"><li><strong>抽象类是否有构造函数，可以创建实例吗？</strong></li></ol><p>回答：抽象类可以有构造函数，但是不能创建实例，因为抽象类之定义了部分方法和属性，仍然存在方法需要子类去实现，所以抽象类是不完整的类，自然无法实例化</p><ol start="3"><li><strong>Java抽象类的构造函数有什么作用？</strong></li></ol><p>回答：提供给子类进行初始化操作，当创建子类对象时，会优先调用子类构造函数，再调用父类构造函数（如果父类没有无参构造函数，需要子类手动调用父类有参构造函数并传递对应参数），当然，抽象类也会有默认的无参构造函数</p><ol start="4"><li><strong>什么时候使用接口比抽象类更好</strong></li></ol><p>回答：当需要考虑到多继承时，例如目标类已经继承了其他类，而java并不支持继承多个类，但是允许实现多个接口，可以通过实现接口新增方法；合适的松耦合使得代码实现和接口分离；</p><ol start="5"><li><strong>什么时候使用抽象类比接口更好</strong></li></ol><p>回答：抽象类能提供默认的一些实现，子类继承时可以少一些公用代码，提高了代码的可维护性；构造函数的存在可以让对象实例初始化时执行操作；</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day30_比较与顺序_剑指Offer</title>
      <link href="/2023/04/19/leetCode/%E5%89%91%E6%8C%87Offer/Day30_%E6%AF%94%E8%BE%83/"/>
      <url>/2023/04/19/leetCode/%E5%89%91%E6%8C%87Offer/Day30_%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></p><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例：</strong></p><pre><code class="java">输入: n = 1输出: [1,2,3,4,5,6,7,8,9]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>扩容结果数组：n是几就扩到几位数</li><li>遍历补数据</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] printNumbers(int n) &#123;        int nSize = 1;        while(n&gt;0)&#123;            nSize *= 10;            n--;        &#125;        int[] fin = new int[nSize-1];        for(int i=0; i&lt;nSize-1; i++) &#123;            fin[i] = i+1;        &#125;        return fin;    &#125;&#125;</code></pre><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p><strong>Hard</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [7,5,6,4]输出: 5</code></pre><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    int count = 0;    public int reversePairs(int[] nums) &#123;    //利用归并排序解答，在合并的时候，当左边的大于右边，就计算逆序数。    //计算公式； mid-left+1    //定义一个全局的计数器变量        this.count = 0;        mergeSort(nums, 0, nums.length-1);        return count;    &#125;    public void mergeSort(int[] nums,int left,int right)&#123;        //当只有一个节点的时候，直接返回，退出递归        if(left &gt;= right)&#123;            return;        &#125;        int mid = (left+right)/2;        //左拆分        mergeSort(nums,left,mid);        //右拆分        mergeSort(nums,mid+1,right);        //合并        merge(nums,left,mid,right);    &#125;    public void merge(int[] nums,int left,int mid,int right)&#123;        //定义一个临时数组        int[] temp = new int[right-left+1];        //定义一个指针，指向第一个数组的第一个元素        int i = left;        //定义一个指针，指向第二个数组的第一个元素        int j = mid+1;        //定义一个指针，指向临时数组的第一个元素        int t = 0;        //当两个数组都有元素的时候，遍历比较每个元素大小        while(i &lt;= mid &amp;&amp; j &lt;= right)&#123;            //比较两个数组的元素，取较小的元素加入到，临时数组中            //并将两个指针指向下一个元素            if(nums[i] &lt;= nums[j])&#123;                temp[t++] = nums[i++];            &#125;else&#123;                //当左边数组的大与右边数组的元素时，就对当前元素以及后面的元素的个数进行统计，                //此时这个数就是，逆序数                //定义一个计数器，记下每次合并中存在的逆序数。                count += mid-i+1;                temp[t++] = nums[j++];            &#125;        &#125;        //当左边的数组没有遍历完成后，直接将剩余元素加入到临时数组中        while(i &lt;= mid)&#123;            temp[t++] = nums[i++];        &#125;        //当右边的数组没有遍历完成后，直接将剩余元素加入到临时数组中        while(j &lt;= right)&#123;            temp[t++] =nums[j++];        &#125;        //将新数组中的元素，覆盖nums旧数组中的元素。        //此时数组的元素已经是有序的        for(int k =0; k&lt; temp.length;k++)&#123;            nums[left+k] = temp[k];        &#125;    &#125;&#125;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day29_正则表达式与数字规律_剑指Offer</title>
      <link href="/2023/04/18/leetCode/%E5%89%91%E6%8C%87Offer/Day29_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%A7%84%E5%BE%8B/"/>
      <url>/2023/04/18/leetCode/%E5%89%91%E6%8C%87Offer/Day29_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><strong>Hard</strong>原题连接：<a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">正则表达式匹配</a></p><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p><strong>示例：</strong></p><pre><code class="java">输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于正则表达字符，只有三种可能：正常字符，任意字符 “.”，长度字符 “*”</p><ol><li><p>如果是正常字符，和字符对应位置比较，不同返回false，相同就s和p各往后推一位</p></li><li><p>如果是 “.”，就直接向后推</p></li><li><p>如果是 “ * ”，需要考虑是否判断，如果前一位值相同或为 “.” ，代表字符可以匹配正则的 “ * ”，字符后移；</p><p>​  如果前一位不同，代表 “ * ”取0，正则字符串后移两位</p></li></ol><p>实现：</p><ol><li><p>先判空</p><ol><li>字符为空，正则不为空，需要判断：s&#x3D;”” p&#x3D;”a*”</li><li>字符为空，正则为空，true</li><li>字符不空，正则为空，false</li></ol></li><li><p>判断当前首字符s和p的关系，如果p有后一位，记录（方便查看 “*” 的作用）</p></li><li><p>如果p下一位为 “ * ”，符合两者后移就递归，否则就当 “ * ”为0次出现，消除两个p首字段递归</p></li><li><p>如果不为 “ * ”，符合消除就两者后移递归，否则返回false</p></li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean isMatch(String s, String p) &#123;        int m = s.length();        int n = p.length();        if(m == 0) &#123;            if(n%2 != 0) return false;            int i=1;            while(i&lt;n) &#123;                if(p.charAt(i) != &#39;*&#39;) &#123;                    return false;                        &#125;                i+=2;            &#125;            return true;        &#125;        if(n == 0) return false;        char a1 = p.charAt(0), a2 = s.charAt(0), a3 = &#39;a&#39;;        if(n &gt; 1) a3 = p.charAt(1);        if(a3 == &#39;*&#39;) &#123;            if(a1 == a2 || a1 == &#39;.&#39;)                return isMatch(s.substring(1), p)                    || isMatch(s, p.substring(2));            else                return isMatch(s, p.substring(2));        &#125;else &#123;            if(a1 == a2 || a1 == &#39;.&#39;)                return isMatch(s.substring(1), p.substring(1));            else                return false;        &#125;    &#125;&#125;</code></pre><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/chou-shu-lcof/">丑数</a></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例：</strong></p><pre><code class="java">输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre><p> <strong>说明:</strong> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>丑数 &#x3D; min（一个较小的丑数  * 2 或 * 3 或 <em>5），比如 4 &#x3D; 2 * 2，5 &#x3D; 1</em> 5，9 &#x3D; 3 * 3 即拆到最细因子只包含 2，3，5</p><p>所以<strong>利用已知的丑数推导下一个丑数</strong>，比如已知 1，2，3，4，5 下一位丑数 6 &#x3D; 2*3，可为什么选2 和 3 是问题所在  </p><p>下一个丑数只可能通过以下三种形式出现</p><p>已知丑数a * 2已知丑数b * 3已知丑数c * 5</p><p>那么就从头开始记录a, b, c</p><p>当满足某一次丑数为a * 2，b * 3，c * 5，更新对应的a b c </p><p>实现：</p><ol><li>初始丑数为1，a，b，c均为0</li><li>向后递推丑数，每次的丑数等于 （第a个丑数 * 2，第b个丑数 * 3，第c个丑数 * 5）三者中的最小值</li><li>2种是谁的最小值，谁就+1，更新abc，直到推导到第n位</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int nthUglyNumber(int n) &#123;        int a = 0, b = 0, c = 0;        int[] dp = new int[n];        dp[0] = 1;        for(int i=1; i&lt; n; i++) &#123;            dp[i] = Math.min(Math.min(dp[a] * 2, dp[b] * 3), dp[c] * 5);            if(dp[i] == dp[a] * 2) a++;            if(dp[i] == dp[b] * 3) b++;            if(dp[i] == dp[c] * 5) c++;        &#125;        return dp[n-1];    &#125;&#125;</code></pre><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数</a></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例：</strong></p><pre><code class="java">输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</code></pre><p> <strong>说明:</strong> </p><ol><li>1 &lt;&#x3D; n &lt;&#x3D; 11</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>一个骰子六个面，每个面出现概率1&#x2F;6，两个骰子，共有36种组合，但是只有11种不同结果（2-12）。</p><p>以上我们可以得到的信息：</p><ol><li>每多加一个骰子，不同的结果数量就增加5个（最大值+6，最小值+1，差为5）</li><li>多加一个骰子后，<strong>原结果第i个应该影响现结果第i+1到i+6 ,先结果第 i 个应该是原结果 i - 6 到 i - 1的累计作用</strong></li><li>所谓累计作用：原本 i 的概率为 a,新加一个骰子后，i 对于 i+1 影响大了 a&#x2F;6 ,对 i+2也是a&#x2F;6,直到 i+6，相同的道理，i+1对 i+2到i+7也有相同影响</li></ol><p>简而言之，从只有一个骰子向后递推，每增加一个筛子，扩大结果数组范围，让原结果对先数组的六位累计概率</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public double[] dicesProbability(int n) &#123;        double[] ans = new double[6];        for(int i=0; i&lt;6; i++) ans[i] = 1.0/6;        for(int i=2; i&lt;=n; i++) &#123;            double[] mid = new double[5*i + 1];            for(int j=0; j&lt;ans.length; j++) &#123;                for(int k=0;k&lt;6; k++) &#123;                    mid[j+k] += ans[j]/6.0;                &#125;            &#125;            ans = mid;        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day28_序列与顺序_剑指Offer</title>
      <link href="/2023/04/17/leetCode/%E5%89%91%E6%8C%87Offer/Day28_%E5%BA%8F%E5%88%97%E4%B8%8E%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/04/17/leetCode/%E5%89%91%E6%8C%87Offer/Day28_%E5%BA%8F%E5%88%97%E4%B8%8E%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p><strong>Hard</strong>原题连接：<a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">序列化二叉树</a></p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例：</strong></p><pre><code class="java">输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如何序列化二叉树（以什么顺序序列化）<ol><li>先序遍历：<strong>根  （左）（右）</strong>的顺序，根（根左右）（根左右）,可以确定当前第一个是根节点，遍历左子树，直到叶子节点，之后是右子树</li><li>中序遍历：<strong>（左） 根 （右）</strong>的顺序，很难判断出根节点的位置，</li><li>后序遍历：<strong>（左）（右） 根</strong> 的顺序，同上不便判断出根节点和左右节点之间的区分</li></ol></li><li>二叉树有几种状态需要区别<ol><li>当前节点：直接把值当字符存储，空节点（叶子节点的子节点）使用特殊字符存储 “#”</li><li>子节点与根：使用字符连接，便于反序列化时区分各个值 “-”</li></ol></li></ol><p>综上，序列化使用先序遍历，判断是否是null，存储当前值，遍历左子树，遍历右子树</p><p>反序列化则是按顺序读取序列化的值，凭借自己拆分的字符，拆成一个个数字，按先序连接</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123;    // Encodes a tree to a single string.    public String serialize(TreeNode root) &#123;        if(root == null) return &quot;#&quot;;        StringBuilder sb = new StringBuilder();        sb.append(root.val);        sb.append(&quot;_&quot;);        sb.append(serialize(root.left));        sb.append(&quot;_&quot;);        sb.append(serialize(root.right));        String str = sb.toString();        return str;    &#125;    // Decodes your encoded data to tree.    public TreeNode deserialize(String data) &#123;        String[] values = data.split(&quot;_&quot;);        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();        for(int i = 0; i &lt; values.length; i++) &#123;            queue.add(values[i]);        &#125;        return reconOrder(queue);    &#125;    //组成树    public static TreeNode reconOrder(Queue&lt;String&gt; queue) &#123;        String value = queue.poll();        if(value.equals(&quot;#&quot;))&#123;            return null;        &#125;        TreeNode head = new TreeNode(Integer.valueOf(value));        head.left = reconOrder(queue);        head.right = reconOrder(queue);        return head;    &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root));</code></pre><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列</a></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例：</strong></p><pre><code class="java">输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>字符的所有排列，理论上，<strong>一个长度为n的字符最大排列数应该是 !n 个</strong>，但是例子中发现存在重复字符，比如 abb</p><p>思路变为每一个字符在每一个位置只能出现一次（每一个位置都设置一个hashset存储已经在这个位置站过的字符）</p><p>第一个位置会遍历n次，第二位置会遍历n-1次….最后位会遍历1次，总计 !n 次</p><p>但是，一旦出现已经在某个位置重复选过，剪枝</p><p>直至拼接长度到达目标长度</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    // 1.用什么存储    char[] sortStr;    List&lt;String&gt; ans = new LinkedList&lt;&gt;();    public String[] permutation(String s) &#123;        // 2.初始化：String 转 charArray        sortStr = s.toCharArray();        dfs(0);        return ans.toArray(new String[ans.size()]);    &#125;        // 3.dfs遍历运算，终止条件是什么，dfs如何递归    public void dfs(int index) &#123;        // 4.剪枝条件        if(index == sortStr.length-1) &#123;            ans.add(String.valueOf(sortStr));            return;        &#125;        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();        for(int i=index; i&lt;sortStr.length; i++) &#123;            if(set.contains(sortStr[i]))continue;            set.add(sortStr[i]);            swap(i, index);            dfs(index + 1);            swap(i, index);        &#125;        return;    &#125;    // 5.交换函数    public void swap(int a, int b) &#123;        char mid = sortStr[a];        sortStr[a] = sortStr[b];        sortStr[b] = mid;    &#125; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day27_滑动窗口_剑指Offer</title>
      <link href="/2023/04/16/leetCode/%E5%89%91%E6%8C%87Offer/Day27_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2023/04/16/leetCode/%E5%89%91%E6%8C%87Offer/Day27_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p><strong>Hard</strong>原题连接：<a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例：</strong></p><pre><code class="java">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <em>k</em> 总是有效的，在输入数组 <strong>不为空</strong> 的情况下，<code>1 ≤ k ≤ nums.length</code>。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>问题：</p><ol><li>需要时刻记录当前窗口中的最大值</li><li>当窗口移动时需要考虑是否移除的是之前的最大值，以及插入的新值该排在什么位置</li><li>暴力算法会超时</li></ol><p>实现：</p><ol><li>使用双端队列存储最大值信息（存储：不严格递减存储，不符合的不存）利于删除头节点（最大值），添加删除尾节点（后续的大值）</li></ol><p>​例如： 【1，6，5，2，5，3】，4 ，队列会存储【6，5，5，3】</p><ol start="2"><li>移动时删除左端：如果左端值和队列头相同，队列弹出，下一个值作为队列头返回最大值</li><li>移动时添加右端：弹出双端队列中从<strong>队尾到队头</strong>所有小于添加节点的值，再添加节点，如上述例子下一步为：1，【6，5，2，5，3，4】，队列存储【6，5，5，4】弹出了3，添加了4</li><li>利用两个循环，一个用户创建基础滑动窗口，并获得对应初始队列；一个用于滑动运算</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        if(nums.length == 0 || k == 0) return new int[0];        int[] ans = new int[nums.length -k + 1];        Deque&lt;Integer&gt; maxValue = new LinkedList&lt;&gt;();        for(int i=0; i&lt;k; i++) &#123;            while(!maxValue.isEmpty() &amp;&amp; maxValue.peekLast() &lt; nums[i]) maxValue.removeLast();            maxValue.addLast(nums[i]);        &#125;        ans[0] = maxValue.peekFirst();        for(int i=k; i&lt;nums.length; i++) &#123;            if(maxValue.peekFirst() == nums[i-k]) maxValue.removeFirst();            while(!maxValue.isEmpty() &amp;&amp; maxValue.peekLast() &lt; nums[i]) maxValue.removeLast();            maxValue.addLast(nums[i]);            ans[i-k+1] = maxValue.peekFirst();        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值</a></p><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例：</strong></p><pre><code class="java">输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2]输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1]位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>和第一题很类似，是一个不固定长度的滑动窗口</p><p>数据信息和最大排序都是用双端队列存储，每次添加数据时做判断，弹出最大排序中所有小于插入值的值</p><p>获取最大值和弹出时额外判断是否为空即可</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class MaxQueue &#123;    Deque&lt;Integer&gt; numMessage;    Deque&lt;Integer&gt; maxMessage;    public MaxQueue() &#123;        numMessage = new LinkedList&lt;&gt;();        maxMessage = new LinkedList&lt;&gt;();    &#125;        public int max_value() &#123;        if(maxMessage.isEmpty()) return -1;        return maxMessage.peekFirst();    &#125;        public void push_back(int value) &#123;        numMessage.addLast(value);            while(!maxMessage.isEmpty() &amp;&amp; maxMessage.peekLast() &lt; value) maxMessage.removeLast();        maxMessage.addLast(value);    &#125;        public int pop_front() &#123;        if(numMessage.isEmpty()) return -1;        if(maxMessage.peekFirst().equals(numMessage.peekFirst())) maxMessage.removeFirst();        int ans = numMessage.peekFirst();        numMessage.removeFirst();        return ans;    &#125;&#125;/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue obj = new MaxQueue(); * int param_1 = obj.max_value(); * obj.push_back(value); * int param_3 = obj.pop_front(); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day26_字符与数字_剑指Offer</title>
      <link href="/2023/04/15/leetCode/%E5%89%91%E6%8C%87Offer/Day26_%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E5%AD%97/"/>
      <url>/2023/04/15/leetCode/%E5%89%91%E6%8C%87Offer/Day26_%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串</a></p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>数值（按顺序）可以分成以下几个部分：</p><p><strong>若干空格</strong><br><strong>一个 小数 或者 整数</strong><br><strong>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</strong><br><strong>若干空格</strong><br><strong>小数（按顺序）</strong>可以分成以下几个部分：</p><p><strong>（可选）一个符号字符（’+’ 或 ‘-‘）</strong><br>下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字<br>一个点 ‘.’ ，后面跟着至少一位数字<br><strong>整数（按顺序）</strong></p><p>可以分成以下几个部分：</p><p><strong>（可选）一个符号字符（’+’ 或 ‘-‘）至少一位数字</strong><br>部分数值列举：[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</p><p>部分非数值列举：[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</p><p><strong>示例：</strong></p><pre><code class="java">输入：s = &quot;0&quot;输出：true输入：s = &quot;e&quot;输出：false输入：s = &quot;.&quot;输出：false输入：s = &quot;    .1  &quot;输出：true</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一个包含全部可能的最大目标大致可以分为：</p><p><strong>空格 正负 数字 小数点 数字 e&#x2F;E 正负 数字 空格</strong></p><p>从前到后依次划分部分进行检验：</p><ol><li>删除前后空格</li><li>判断首字节是否为+-</li><li>依据E&#x2F;e拆分为两个部分</li><li>前者判断是否由小数点，拆为两个部分</li><li>3中剩下的部分，4中的两个部分，检测是否为纯数字</li></ol><p>注：允许4的前半部分为空</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean isNumber(String s) &#123;        // 空格 正负 数字 小数点 数字 e/E 正负 数字 空格        // 1.将s删去前后空格，判断charAt(0)是否是正负号        s = s.trim();        if(s.length() == 0) return false;        if(s.charAt(0) == &#39;+&#39; || s.charAt(0) == &#39;-&#39;) s = s.substring(1);                // 2.将剩余string依据e/E划分为两个部分，如果第二部分长度不为零，判断charAt(0)是否为符号        s = s.replace(&#39;E&#39;,&#39;e&#39;);        if(s.indexOf(&#39;e&#39;) &gt;= 0) &#123;            int index = s.indexOf(&#39;e&#39;);            String firstStr = s.substring(0,index);            String secondStr = s.substring(index+1);            if(secondStr.length() &gt; 0) &#123;                if(secondStr.charAt(0) == &#39;+&#39; || secondStr.charAt(0) == &#39;-&#39;) secondStr = secondStr.substring(1);            &#125;            return isNum(firstStr) &amp;&amp; isInteger(secondStr);        &#125;        return isNum(s);    &#125;        // 3.由2得到的两个字符，前者做数字判断（可为小数），后者做整数判断    // 判断是否为整数（不可以为小数）    public boolean isInteger(String str) &#123;        if(str == &quot;&quot;) return false;        for(char a : str.toCharArray()) &#123;            if(a &lt; &#39;0&#39; || a &gt; &#39;9&#39;) return false;        &#125;        return true;    &#125;    // 判断是否为数（可以为小数）    public boolean isNum(String str) &#123;        if(str.indexOf(&#39;.&#39;) &gt;= 0) &#123;            int index = str.indexOf(&#39;.&#39;);            String firstStr = str.substring(0,index);            String secondStr = str.substring(index+1);            if(firstStr.length() &gt;0 &amp;&amp; secondStr.length() &gt;0) &#123;                return isInteger(firstStr) &amp;&amp; isInteger(secondStr);            &#125;else if(secondStr.length() &gt;0) &#123;                return isInteger(secondStr);            &#125;else &#123;                return isInteger(firstStr);            &#125;        &#125;        return isInteger(str);    &#125;&#125;</code></pre><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/"> 把字符串转换成整数</a></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) </p><p><strong>示例：</strong></p><pre><code class="java">输入: &quot;42&quot;输出: 42输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。输入: &quot;4193 with words&quot;输出: 4193输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。     因此无法执行有效的转换。输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>和第一题有些类似，删除空格，判断符号，遇到字母就跳出</p><p>需要注意的是，如果第一个字符是符号，数字需要从下标为1的地方开始读，如果没有符号，则从0开始读</p><p>为了避免超过int类型的最大值，可以在循环中判断，是否即将超过最大值（因为每次记录结果是将ans&#x3D; ans*10+new）</p><p>所以<strong>先判断是否依据超过了int最大值的十分之一</strong>（否则接下来进行*10运算会超过最大值）</p><p>又或者恰好为2147483648、 2147483649，刚好超过一两位，所以在ans已经相等于int最大值的十分之一时判断最后一位的值是否大于7</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int strToInt(String str) &#123;        // 1.删去str前后端的空格,并判断charAt(0)是否为符号,做记录(符号sign与数字开始位i)        str = str.trim();        if(str.length() == 0) return 0;        int sign = 1, index = 1;        if(str.charAt(0) == &#39;-&#39;) &#123;            sign = -1;        &#125;else if(str.charAt(0) != &#39;+&#39;)&#123;            index = 0;        &#125;        int ans = 0, max = Integer.MAX_VALUE/10;        // 2.循环对数每一位做判断:        for(; index &lt; str.length(); index++) &#123;            // 3.弹出条件之一:遇到不是数字的数，break            if(str.charAt(index)&lt;&#39;0&#39; || str.charAt(index)&gt;&#39;9&#39;) break;            // 4.弹出条件之二:已经超过最大值(符号已经记录，单纯看数值大小)            if(ans&gt;max || (ans==max &amp;&amp; str.charAt(index)&gt;&#39;7&#39;))                 return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;            ans = ans*10+(str.charAt(index)-&#39;0&#39;);        &#125;        return ans*sign;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day25_顺序_剑指Offer</title>
      <link href="/2023/04/14/leetCode/%E5%89%91%E6%8C%87Offer/Day25_%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/04/14/leetCode/%E5%89%91%E6%8C%87Offer/Day25_%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/"> 顺时针打印矩阵</a></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例：</strong></p><pre><code class="java">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p><strong>提示：</strong></p><ol><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>固定顺时针：向左，向下，向右，向上</p><p>实现：</p><ol><li>设立上下左右边界，在走完一边后，减少对应的边界范围（如：输出矩阵最上一行后，上边届从0转至1）</li><li>依据 <strong>向左，向下，向右，向上</strong> 循环执行输出，完成一端需要判断下一步是否有路可走（向左到端头，先判断向下是否可以走）</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] spiralOrder(int[][] matrix) &#123;        if(matrix.length == 0 || matrix[0].length == 0) return new int[0];        int[] ans = new int[matrix.length * matrix[0].length];        int size=0;        int leftNum = 0, rightNum = matrix[0].length-1;        int onNum = 0, downNum = matrix.length-1;        while(leftNum&lt;=rightNum &amp;&amp; onNum&lt;=downNum) &#123;            for(int j = leftNum; j&lt;=rightNum; j++) ans[size++] = matrix[onNum][j];            if(++onNum &gt; downNum)break;            for(int i = onNum; i&lt;=downNum; i++) ans[size++] = matrix[i][rightNum];            if(leftNum &gt; --rightNum)break;            for(int j = rightNum; j&gt;=leftNum; j--) ans[size++] = matrix[downNum][j];            if(onNum &gt; --downNum)break;            for(int i = downNum; i&gt;=onNum; i--) ans[size++] = matrix[i][leftNum];            if(++leftNum &gt; rightNum)break;        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例：</strong></p><pre><code class="java">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。</code></pre><p><strong>限制：</strong></p><ol><li><p>0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</p></li><li><p>0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</p></li><li><p>pushed 是 popped 的排列。</p></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路：</p><ol><li>使用栈存储数组信息</li><li>如果栈为空，压入条件数组的当前值</li><li>如果当前栈顶和目标数组的当前值一致，弹出，否则一直压入条件数组，直至超过范围或和目标数组一致</li><li>循环2-3，如果最终栈全部弹出，返回true，否则一定在 3 中返回false</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;        if(pushed.length == 0) return true;        int mid = 0,j = 1;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        stack.push(pushed[0]);        for(int i=0; i&lt;popped.length; i++)&#123;            mid = popped[i];            if(stack.isEmpty())&#123;                stack.push(pushed[j]);                j++;            &#125;            while(stack.peek() != mid)&#123;                if(j&gt;=pushed.length) return false;                stack.push(pushed[j]);                j++;            &#125;            stack.pop();        &#125;                       return true;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day24_数字规律_剑指Offer</title>
      <link href="/2023/04/13/leetCode/%E5%89%91%E6%8C%87Offer/Day24_%E6%95%B0%E5%AD%97%E8%A7%84%E5%BE%8B/"/>
      <url>/2023/04/13/leetCode/%E5%89%91%E6%8C%87Offer/Day24_%E6%95%B0%E5%AD%97%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剪绳子</a></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p><p><strong>示例：</strong></p><pre><code class="java">输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</code></pre><p><strong>提示：</strong></p><ol><li><code>2 &lt;= n &lt;= 58</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>总长度固定，拆成不同长短的子段，算最大乘积</p><ol><li>子段长度越相等，积越大（算术几何均值不等式）</li><li>不要分出长度为1的子段</li><li>自然对数 e 约等于 2.7</li></ol><p>所以设总长度为常数N，拆成a段长度为x，我们有：</p><p>N &#x3D; a * x ;ans &#x3D; x ^ a;</p><p>得到：ans &#x3D; ( <strong>x ^  ( 1 &#x2F; x )</strong> ) ^ N，由于N为常数，ans最终的值会趋近于 2.7 * N，但是绳子要是整数</p><p>所以目标是<strong>将绳子尽可能化成越多的3</strong></p><ol><li>当长度可以被3整除，全部转为长度为3的绳子，求值</li><li>当长度对3除余，得到2，转换为一个2和其他为3的数段，求值</li><li>当长度对3除余，得到1，转换为一个4和其他为3的数段，求值</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int cuttingRope(int n) &#123;        if(n &lt;= 3)return n-1;        int a = (int)n/3, b = n%3;        if(b == 2) return (int)Math.pow(3,a)*2;        if(b == 1) return (int)Math.pow(3,a-1)*4;        return (int)Math.pow(3,a);    &#125;&#125;</code></pre><h2 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/"> 和为s的连续正数序列</a></p><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例：</strong></p><pre><code class="java">输入：target = 9输出：[[2,3,4],[4,5]]输入：target = 15输出：[[1,2,3,4,5],[4,5,6],[7,8]]</code></pre><p><strong>限制：</strong></p><ol><li><code>1 &lt;= target &lt;= 10^5</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>连续数组首先想到滑动窗口：</p><ol><li>设立滑动窗口，左端left，右端right，得到窗口总值：sum &#x3D; left + right</li><li>判断sum与target的关系：<ol><li>sum &#x3D;&#x3D; target : 符合目标信息，存储滑动窗口中的数据，窗口小数端移动（符合题目要求：不同序列按照首数字大小排列）</li><li>sum &lt; target ：滑动窗口大数端移动</li><li>sum &gt; target ：滑动窗口小数端移动</li></ol></li><li>循环2，直至left与right相遇：（窗口最小数已经大于target的一半，无法划分了）</li></ol><pre><code class="java">// 当你需要从0开始赋值数组，但是你的值随另一个数组变动：for(int i=left; i&lt;=right; i++) &#123;    ans[i-left] = i;&#125;</code></pre><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[][] findContinuousSequence(int target) &#123;        int left = 1, right =2, sum = left + right;        List&lt;int[]&gt; ansList = new ArrayList&lt;&gt;();        while(left &lt; right) &#123;            if(sum == target) &#123;                int[] ans = new int[right - left + 1];                for(int i=left; i&lt;=right; i++) &#123;                    ans[i-left] = i;                &#125;                ansList.add(ans);            &#125;            if(sum &gt;= target) &#123;                sum -= left;                left++;            &#125;else &#123;                right++;                sum += right;            &#125;        &#125;        return ansList.toArray(new int[0][]);    &#125;&#125;</code></pre><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></p><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例：</strong></p><pre><code class="java">输入: n = 5, m = 3输出: 3输入: n = 10, m = 17输出: 2</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>约瑟夫环问题</strong>：每次都会删除环中一个节点，想知道谁留到最后，由题目提示给的数据量来看，死算是过不了的</p><p>首先，在最后一次删除后，所剩下的一个数，是当前数组的0位（因为只有一位了）</p><p>每次删除后，从下一个开始当作新的删除计数，删除 <strong>当前值+（ m % i ）</strong>, i 为当前循环中的数的总数，为了避免总数超出上线，对 i 去余</p><p>综合以上两者，可以从一位向前推到（已知最后剩下的是最后数组的0号位，能退出前一次删除的是哪个位置）</p><p>直到数组长度回复到n，返回最初0号位目前所在的位置即可</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int lastRemaining(int n, int m) &#123;        if(n == 1) return 0;        int ans = 0;        for(int i=1; i&lt;=n; i++) &#123;            ans = (ans + m) % i;        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day23_数组计算_剑指Offer</title>
      <link href="/2023/04/12/leetCode/%E5%89%91%E6%8C%87Offer/Day23_%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/04/12/leetCode/%E5%89%91%E6%8C%87Offer/Day23_%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2</code></pre><p><strong>限制：</strong></p><ol><li><code>1 &lt;= 数组长度 &lt;= 50000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>摩尔投票：记录一个值当作目标值，对比接下来的值是否和目标值一致，一致则计数加一，否则减一，当计数为零时更换目标值</p><p>使用前提：数组中<strong>一定存在超过一半的符合要求的数</strong>，否则算法不成立【1，1，4，4，4，7，7】会返回 7 而不是 4 ，当数组中一定存在超过一半的目标数，剩余的数全部对撞目标数，留下的也一定是目标数。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        //摩尔投票算法：对拼消耗        int ans = 0, maxNum = 0;        for(int num : nums) &#123;            if(maxNum == 0) &#123;                ans = num;            &#125;            if(num == ans) &#123;                maxNum++;            &#125;else &#123;                maxNum--;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组</a></p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [1,2,3,4,5]输出: [120,60,40,30,24]</code></pre><p><strong>提示：</strong></p><ol><li>所有元素乘积之和不会溢出 32 位整数</li><li><code>a.length &lt;= 100000</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目提示长度可能达到10w，循环暴力破解肯定是超时下策，但是每个数乘积又需要遍历得到，这时应该考虑复用计算结果</p><p>将计算 i 位的目标乘积分为两部分来看的话：<strong>i 以前的累乘 * i 以后的累乘</strong></p><p>计算 i 位的前 i-1 位目标乘积时，i+1 位只需要在此基础上多乘个 a[i]</p><p>计算 i 位的后 a.length - i 位乘积时，i-1 位只需要再次基础上多乘个 a[i]</p><p>实现：</p><ol><li>创建对应长度的数组，附上1便于做乘积</li><li>首次循环，计算 i 之前的累积，使用中间值mid存储累积结果</li><li>第二次循环，计算 i 之后的累积，使用中间值mid存储累积结果</li><li>返回结果</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] constructArr(int[] a) &#123;        int[] ans = new int[a.length];        int mid = 1;        for(int i=0; i&lt;ans.length; i++) &#123;            ans[i] = 1;            ans[i] *= mid;            mid *= a[i];        &#125;        mid = 1;        for(int i=ans.length-1; i&gt;=0; i--) &#123;            ans[i] *= mid;            mid *= a[i];        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day22_数组中的重复数字_剑指Offer</title>
      <link href="/2023/04/11/leetCode/%E5%89%91%E6%8C%87Offer/Day22_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2023/04/11/leetCode/%E5%89%91%E6%8C%87Offer/Day22_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例：</strong></p><pre><code class="java">输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]</code></pre><p><strong>限制：</strong></p><ol><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为题目要求了时间复杂度不能超过O(n)，空间复杂度不能超过O(1)，所以无法使用HashMap做记录统计值</p><p>前置知识：</p><ol><li>关于异或（相同返回0，不同返回1）：<strong>A^A&#x3D;0 , A^B&#x3D;B^A 和 A^0&#x3D;A</strong> ，所以<strong>A^B^A &#x3D; A^A^B &#x3D; 0^B &#x3D; B</strong></li><li>一个十位数，对应着唯一的二进制值（废话），所以如果两个数的<strong>二进制某个位置值不同，那一定是不同值</strong></li></ol><p>实现：</p><ol><li>对nums中所有数据进行异或，能得到除了重复数字之外的，两个只出现了一次的数的异或结果</li><li>找到这个异或结果的一个“1”，因为是不同值，所以异或一定不为0，找到一个异或结果为1的部分，说明两个数在这个位置二进制值一定不同</li><li>根据2得到的部位，将nums划分为两个部分分别进行异或，得到的两个值就是目标</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] singleNumbers(int[] nums) &#123;        int ans1 = 0, ans2 = 0, mid = 0, firstDif = 1;        // 1.找出两个单次出现的数字的异或结果        for(int num : nums) &#123;            mid = mid ^ num;        &#125;        // 2.找到区分位        while((mid &amp; firstDif) == 0) &#123;            firstDif = firstDif &lt;&lt; 1;        &#125;        // 3.依据区分为去异或        for(int num : nums) &#123;            if((num &amp; firstDif) == 0)ans1 = ans1 ^ num;            else ans2 = ans2 ^ num;        &#125;        return new int[]&#123;ans1, ans2&#125;;    &#125;&#125;</code></pre><h2 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a>数组中数字出现的次数 II</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例：</strong></p><pre><code class="java">输入：nums = [3,4,3,3]输出：4输入：nums = [9,1,7,9,7,9,7]输出：1</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><p>数组中出现三次，说明数字转换成二进制后，每个为1的对应位置在数组中会至少有3个1</p></li><li><p>将nums的数字全部转换为32位二进制，按对应位填入32位的数组</p></li><li><p>对该数组每一位都对3取余，只出现一次的会留下一个1</p></li><li><p>重新拼接数组为十进制数，得到结果</p></li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int singleNumber(int[] nums) &#123;        // 1.遍历数组，每一位都拆为二进制，按值放入32位数组        int[] ans = new int[32];        for(int num : nums) &#123;            int i=0;            while(num &gt;0 ) &#123;                ans[i] += num%2;                num /= 2;                i++;            &#125;        &#125;        // 2.对数组每一位都取3的模，获得结果        for(int i=0; i &lt; ans.length; i++) &#123;            ans[i] = ans[i]%3;        &#125;        // 3.将结果拼为十位数        int value = 0;        for(int i=ans.length-1; i&gt;=0; i--) &#123;            value *= 2;            value += ans[i];        &#125;        return value;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day21_二进制计算_剑指Offer</title>
      <link href="/2023/04/10/leetCode/%E5%89%91%E6%8C%87Offer/Day21_%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/04/10/leetCode/%E5%89%91%E6%8C%87Offer/Day21_%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p><strong>示例：</strong></p><pre><code class="java">输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。输入：n = 128 (控制台输入 00000000000000000000000010000000)输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>限制：</strong></p><ol><li><code>输入必须是长度为 32 的 二进制串 。</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>实现：1.判断n是否不等于0，等于0返回计数 </p><p>​2.判断n的二进制最低位是否为1，为1计数加1，否则计数不变</p><p>​3.将n左移一位，返回1判断</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">public class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        int num = 0;        while(n!=0)&#123;            num = (n&amp;1)==1 ? num+1 : num;            n = n&gt;&gt;1;        &#125;        return num;    &#125;&#125;</code></pre><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法</a></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p><p><strong>示例：</strong></p><pre><code class="java">输入: a = 1, b = 1输出: 2</code></pre><p><strong>提示：</strong></p><ol><li><code>a</code>, <code>b</code> 均可能是负数或 0</li><li>结果不会溢出 32 位整数</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>加法对于两个二进制数，可以拆成 <strong>非进位异或</strong> 和 <strong>进位与</strong>，如：</p><p>原数1     原数2      进位     原位</p><p>  0      000</p><p>  1  0    0 1</p><p>  0  1    0 1</p><p>  1  1    1 0</p><p>我们会发现<strong>原位值为前两者异或</strong>，<strong>进位值为两者与</strong>，更近的有，原位 + 进位就是原数和 推出</p><p><strong>当原位进位相加且没有进位产生时（进位与为0），和原位和进位相与和相加的效果相同</strong></p><p>所以两数相加就可以替换为：不断计算原位与进位，直至进位与为0</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int add(int a, int b) &#123;        if(b == 0) return a;        while(b != 0) &#123;            // 获得进位            int c = (a &amp; b) &lt;&lt; 1;            // 获得原位            a = a^b;            b = c;        &#125;        return a;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day19_计算与二叉树的遍历_剑指Offer</title>
      <link href="/2023/04/09/leetCode/%E5%89%91%E6%8C%87Offer/Day20_%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2023/04/09/leetCode/%E5%89%91%E6%8C%87Offer/Day20_%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例：</strong></p><pre><code class="java">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]Input: preorder = [-1], inorder = [-1]Output: [-1]</code></pre><p><strong>限制：</strong></p><ol><li><code>0 &lt;= 节点个数 &lt;= 5000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>先序遍历是指：根节点优先遍历，然后遍历左节点，再是右节点（根左右）；中序遍历是指：先遍历左节点，再遍历根节点，最后遍历右节点（左根右）</li><li>在没有单子树的前提下，对于先序遍历，根节点后一定跟着自己的左节点；对于中序遍历，根节点后一定跟着自己的右节点；且先序遍历第一位一定是总的根节点</li><li>先序遍历可以用于查找每一个子节点的根与左节点关系，而且是从第一个值开始查：数组存</li><li>中序遍历在知道某一个根节点时可以知道其根与右节点关系，但是需要提前找到根：Map存</li><li>实现：先序遍历找到一个根，确定左节点，依据这个根将中序遍历分为两个部分，确定右节点，组合节点</li><li>根据5得到的左右节点，将先序遍历数组分为两个部分：<strong>根 （左子树部分）（右子树部分）</strong>，对此两个部分重复5，6直至不可分</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    int[] preorders;    HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        this.preorders = preorder;        for(int i=0; i&lt;inorder.length; i++)&#123;            map.put(inorder[i],i);        &#125;        return fun(0,0,inorder.length-1);    &#125;    TreeNode fun(int root, int left, int right)&#123;        if(left &gt; right)return null;        TreeNode node = new TreeNode(preorders[root]);        int i = map.get(preorders[root]);    //获得根节点位置，划分左右子树        node.left = fun(root+1, left, i-1);        // 右节点在先序中的起始位置：当前位置 + 左子树数量 + 1        node.right = fun(root+(i-left)+1, i+1, right);        return node;    &#125;&#125;</code></pre><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例：</strong></p><pre><code class="java">输入：x = 2.00000, n = 10输出：1024.00000输入：x = 2.10000, n = 3输出：9.26100输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>提示：</strong></p><ol><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归进阶版</p><ol><li>统一正负次方的计算：如果n&lt;0，将n设为-n，同时返回的值为 1&#x2F;ans</li><li>暴力遍历会超时，需要使用递归乘方</li><li>1的任何次方都是1，任何数的0次方都是1</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public double myPow(double x, int n) &#123;        long times = n;        if(x == 1) return 1;        return n &gt;= 0 ? fun(x, times) : 1d/fun(x, times);    &#125;    public double fun(double x, long n) &#123;        if(n == 0) return 1;        double num = fun(x, n/2);        return n%2==0 ? num*num : x * num * num;    &#125;&#125;</code></pre><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5    / \   2   6  / \ 1   3</code></pre><p><strong>示例：</strong></p><pre><code class="java">输入: [1,6,3,2,5]输出: false输入: [1,3,2,6,5]输出: true</code></pre><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>后序遍历：先遍历左节点，再遍历右节点，最后遍历根节点</p><p>二叉搜索树：左节点值一定小于根节点，右节点值一定大于根节点</p><ol><li>如果一个序列满足<strong>可以拆成 大-小-根，其中的大和小又可以继续拆为大-小-根，直到最小单位</strong>，那这个序列就可以反向构建后续遍历搜索二叉树</li><li>因为无法确认左右子树的长度，所以判断依据是当前值是否大于根节点（大于就是仍在右子树，否则就是已经到达左子树了）</li><li>对每一个节点的判断需要：上限值，下限制，如果当前节点在上下限之间，代表一个符合条件的节点</li><li>如果序列中所有节点都符合条件，则返回true，否则返回false</li></ol><p>注意：</p><ol><li>一开始设最大最小值是为了避免过大或过小数据无法纳入计算范围</li><li>判断次数会大于实际节点数，应为不知道左右子树数量，所以对于每一个节点（除去最后的根节点）都要判断两次：<ol><li>（下限，上一节点值）：如果是上一届点的右子树，更新上限，否则保持上限</li><li>（上一节点值，上线）：如果是上一届点的左子树，更新下限，否则保持下限、</li></ol></li><li>实际上两次判断是二律背反，只有其中之一会（可能会）符合条件，不可能两者同时满足，所以如果每个节点都满足，才能说明该序列符合上述1中的条件</li></ol><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    int end;    public boolean verifyPostorder(int[] postorder) &#123;        if(postorder == null || postorder.length == 1) return true;        end = postorder.length -1;        fun(postorder, Integer.MIN_VALUE, Integer.MAX_VALUE);        return end &lt; 0;    &#125;    public void fun(int[] postorder, int min, int max) &#123;        if(end &lt; 0) return;        int mid = postorder[end];        // 判断是否还在当前子树        if(mid &gt;= max || mid &lt;= min) return;        end--;        fun(postorder, mid, max);        fun(postorder, min, mid);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day19_计算与二叉树_剑指Offer</title>
      <link href="/2023/04/08/leetCode/%E5%89%91%E6%8C%87Offer/Day19_%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/04/08/leetCode/%E5%89%91%E6%8C%87Offer/Day19_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/qiu-12n-lcof/">求1+2+…+n</a></p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>示例：</strong></p><pre><code class="java">输入: n = 3输出: 6输入: n = 9输出: 45</code></pre><p><strong>限制：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归，如果大于1，就返回 n-1在sumNum的值 + n，等于1 就直接返回1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int sumNums(int n) &#123;        if(n == 1) return 1;        if(n &gt; 1) return sumNums(n-1)+n;        return -1;    &#125;&#125;</code></pre><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例：</strong></p><pre><code class="java">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>提示：</strong></p><ol><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为已知前提是二叉搜索树，所以保证了数据的排序，我们可以有以下三个推论：</p><ol><li>当两个值一个大于当前节点，一个小于当前节点，它们最小父节点一定是当前节点</li><li>如果两个节点都小于当前节点，它们最小父节点一定是在当前节点的左子树中，相反为右子树</li><li>如果当前节点为其中一个目标节点，一定相交于当前节点</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        TreeNode big = p.val &gt; q.val ? p : q;        TreeNode sml = big == p ? q : p;        if(root.val &gt;= sml.val &amp;&amp; root.val &lt;= big.val) &#123;            return root;        &#125;else if(root.val &gt; big.val) &#123;            return lowestCommonAncestor(root.left,p,q);        &#125;else &#123;            return lowestCommonAncestor(root.right,p,q);        &#125;    &#125;&#125;</code></pre><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例：</strong></p><pre><code class="java">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>提示：</strong></p><ol><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题没有明确排序，所以需要确定子树返回到父类树的方法，向根节点左右子树遍历，找到要求的节点返回</p><p>注意，找到节点后，返回的是节点信息，也就是说，对于 4 - 3 - 2这样的一条链，当我们需要找到2的时候，首先遍历4 - 3 - 2</p><p>找到2后，将2信息返回3，再将2返回4，这样我们就能方便了解4 是2 的父节点之一</p><p>综上同时对两个需求的节点进行遍历查找，我们能得到一条从更节点到目标节点的链路，中间返回的都是目标节点值</p><p>这时候，如果链条链路有相交，那么从刚开始相交的节点开始，这个节点就应该需要同时返回两个需求节点</p><p>这样就找到了最早公共祖先</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;    if(root == null || root == p || root == q) &#123;        return root;    &#125;    TreeNode left = lowestCommonAncestor(root.left, p, q);    TreeNode right = lowestCommonAncestor(root.right, p, q);    if(left != null &amp;&amp; right != null) &#123;        return root;    &#125;    return left != null ? left : right;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部变量与全局变量</title>
      <link href="/2023/04/07/Java%E5%9F%BA%E7%A1%80/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
      <url>/2023/04/07/Java%E5%9F%BA%E7%A1%80/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><ul><li>变量的作用域</li><li>基本数据类型变量与引用数据类型变量</li></ul><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>Java中变量的作用域可以分为四个级别：<strong>类级（类变量），对象实例级（实例变量），方法级（局部变量），块级（局部变量）</strong></p><table><thead><tr><th>类型</th><th>从属于</th><th>声明位置</th><th>作用域</th><th>初始化</th></tr></thead><tbody><tr><td>类变量（静态变量）</td><td>类</td><td>类内部，方法外，static修饰</td><td>与类同在，类被加载静态变量就有效，直至类被回收机制回收时消失</td><td>必须先声明、初始化，才能使用</td></tr><tr><td>成员变量（实例变量）</td><td>对象实例</td><td>类内部，方法外</td><td>有对应的实例对象创建时创建成员变量；对象消失时，成员变量消失</td><td>不用自行初始化，默认初始值</td></tr><tr><td>局部变量</td><td>方法 &#x2F; 代码块</td><td>方法中或代码块内</td><td>从声明时开始，到所在的方法或代码块执行完毕时消失</td><td>不用自行初始化，默认初始值</td></tr></tbody></table><pre><code class="java">// 实例代码：public class Variable &#123;    // 静态变量 想使用这类变量，直接 类名.参数名     static String staticVariable = &quot;我是静态变量&quot;;    // 实例变量 想使用要先创建实例对象，如果不初始化，String会默认null，int会默认0    String instanceVariable;    int age;    void Hello() &#123;        // 局部变量 你在这个方法中声明它，那就只能在这个方法中使用它，随着方法结束，他就会消失        String name = &quot;IT蛋&quot;;        System.out.println(&quot;Hello &quot;+name);        System.out.println(Variable.staticVariable);    &#125;    public static void main(String[] args) &#123;        // 局部变量，code2尝试在代码块外定义，在代码块中赋值；code3尝试重复定义        String code2, code3;        &#123;            code2 = &quot;happy&quot;;   // 成功，赋值并输出            //String code3 = &quot;happy&quot;; 报错，已经在包含改范围的范围内定义了code3                        // 局部变量 你在这个代码块中声明它，就只能在这个代码块中使用它            String code = &quot;System.out.println(&#39;代码块内的局部变量&#39;);&quot;;        &#125;        System.out.println(Variable.staticVariable);        System.out.println(new Variable().instanceVariable);        System.out.println(new Variable().age);        new Variable().Hello();        System.out.println(code2);        // System.out.println(name)   报错，找不到属性        // System.out.println(code)   报错，找不到属性    &#125;&#125;---输出---我是静态变量null0Hello IT蛋我是静态变量happy</code></pre><p>对于局部变量，如果存在方法内部递归调用，每次在方法中的参数都是单独存在的，如下面的fun方法，方法中的mid递推了五次，因为内部递归不会影响到外部，所以我们可以看到输出的值由顺序1-5后又从5-1输出，为了区分输出语句，我在递归返回当前方法的输出中加了个 “ | “ 。</p><pre><code class="java">public class Variable2 &#123;    public static void main(String[] args) &#123;        for(int i=0; i&lt;3; i++) &#123;            // 局部变量 i            System.out.print(i + &quot; &quot;);        &#125;        // System.out.println(i);        System.out.println();        System.out.println(&quot;------------&quot;);        int[] nums = new int[]&#123;1,2,3,4,5&#125;;        fun(nums,0);    &#125;    static void fun(int[] nums, int i)&#123;        int mid = nums[i];        System.out.print(mid + &quot; &quot;);        if(i&lt;nums.length-1)            fun(nums,i+1);        System.out.print(mid + &quot;| &quot;);        return;    &#125;&#125;---输出---0 1 2 ------------1 2 3 4 5 5| 4| 3| 2| 1| </code></pre><p>实例题目：<a href="https://xcscx.github.io/2023/04/04/leetCode/%E5%89%91%E6%8C%87Offer/Day15_%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">Day15_树的遍历_剑指Offer | IT蛋的个人博客 (xcscx.github.io)</a></p><pre><code class="java">// 部分代码：对于target(形参)作用域与方法变量（局部变量）一致public void findWay(TreeNode root, int target) &#123;    ...    // 传入方法的target不论怎么变，当前的target都不会收到影响，好比是复制了一份丢给方法，本体不受影响    findWay(root.left, target);    findWay(root.right, target);    ...    &#125;</code></pre><h3 id="基本数据类型变量与引用数据类型变量"><a href="#基本数据类型变量与引用数据类型变量" class="headerlink" title="基本数据类型变量与引用数据类型变量"></a>基本数据类型变量与引用数据类型变量</h3><p>变量的属性会影响变量的传递：</p><ul><li>如果<strong>参数是基本数据类型</strong>，此时实参赋给形参的是实参<strong>真实存储的数据值</strong>。</li><li>如果<strong>参数是引用数据类型</strong>，此时实参赋给形参的是实参<strong>存储数据的地址值</strong>。</li></ul><pre><code class="java">public class Variable3 &#123;    public static void main(String[] args) &#123;        int[] nums = new int[]&#123;1,2,3,4,5&#125;;        int a = 22;        System.out.println(&quot;a = &quot; + a);        System.out.print(&quot;nums = &quot;);        for(int num : nums) System.out.print(num+&quot; &quot;);        System.out.println();        System.out.println(&quot;-----&quot;);        change(nums, a);        System.out.println(&quot;a = &quot; + a);        System.out.print(&quot;nums = &quot;);        for(int num : nums) System.out.print(num+&quot; &quot;);    &#125;    static void change(int[] nums, int a) &#123;        nums[1] = 0;        a = 100;    &#125;---输出---a = 22nums = 1 2 3 4 5 -----a = 22nums = 1 0 3 4 5 </code></pre><p>上述代码中，我们发现对于int类型的a，传递值确实如一开始说的那般，不会收到方法中修改的影响，但是int[] 的值却被修改了。</p><p>这也证明了引用类型传递的是参数的地址，所以会受到方法中修改的影响</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day18_平衡树_剑指Offer</title>
      <link href="/2023/04/07/leetCode/%E5%89%91%E6%8C%87Offer/Day18_%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2023/04/07/leetCode/%E5%89%91%E6%8C%87Offer/Day18_%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>示例：</strong></p><pre><code class="java">    3   / \  9  20    /  \   15   7返回：3</code></pre><p><strong>限制：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>获得二叉树最大深度，可以叫二叉树自根节点遍历至每一个子节点，记录最大深度并返回</p><p>也可以拆分任务：获得每一个子节点的最大深度并返回</p><p>对于每一个节点而言，获取其左右节点的深度，取大值 + 1 ( 当前节点 ) 并返回</p><p>需要额外考虑的就是叶子节点，当前遍历到叶子节点时，判断左右为null的分支深度为0即可</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root == null) return 0;        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));    &#125;&#125;</code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树</a></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例：</strong></p><pre><code class="java">    3   / \  9  20    /  \   15   7输出: True       1      / \     2   2    / \   3   3  / \ 4   4输出：False</code></pre><p><strong>提示：</strong></p><ol><li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>判断某树是否是平衡二叉树时，需要确定二叉树中任意节点的左右子树深度差不超过1</p><p>对于每一棵子树，都需要知道其左右子树深度，也需要向上返回深度+1以告知父节点当前最大深度</p><p>定义一个成员变量 flag 检测是否存在非平衡树的子树，当完成遍历后，flag 仍未改变则说明当前树为平衡二叉树</p><p>否则不是</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    boolean flag = true;    public boolean isBalanced(TreeNode root) &#123;        int ans = treeLen(root);        return flag;    &#125;    public int treeLen(TreeNode root) &#123;        if(!flag) return 0;        if(root == null) return 0;        int leftLen = treeLen(root.left);        int rightLen = treeLen(root.right);        if(leftLen - rightLen &gt;=-1 &amp;&amp; leftLen - rightLen &lt;= 1) &#123;            return 1 + Math.max(leftLen, rightLen);        &#125;        flag = false;        return 0;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day17_数组排序2_剑指Offer</title>
      <link href="/2023/04/06/leetCode/%E5%89%91%E6%8C%87Offer/Day17_%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/06/leetCode/%E5%89%91%E6%8C%87Offer/Day17_%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例：</strong></p><pre><code class="java">输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]输入：arr = [0,1,2,1], k = 1输出：[0]</code></pre><p><strong>限制：</strong></p><ol><li><p>0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000</p></li><li><p>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</p></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>排序输出前k位，取决于你希望使用哪一种算法实现排序，有现成的自然是最快的</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] getLeastNumbers(int[] arr, int k) &#123;        int[] ans = new int[k];        Arrays.sort(arr);        for(int i=0; i&lt;k; i++)&#123;            ans[i] = arr[i];        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p><strong>hard</strong>原题连接：<a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例：</strong></p><pre><code class="java">输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000]</code></pre><p><strong>提示：</strong></p><ol><li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>取中位数的值，根据题目要求，添加和分析中位数都会有50000次以内的调用，需要尽可能的降低添加和搜索的时间复杂度</p><p>单一数据结构如ArrayList，LinkedList做存储的话，在添加或搜索的复杂度上会过大 O( n )，在此使用优先队列PriorityQueue对两边分别排序则效果更好</p><p>PriorityQueue进行add的复杂度是O( logn )，弹出堆顶是常熟复杂度，自然是首选。</p><p>那么如何分配两边的值呢？（当新添加一个值时，是放前堆还是后堆）</p><p>因为使用堆的目的是维护两端长度一致，便于我们peek输出中位数，所以分配的前提是两端长度相等</p><p>其次，因为是依次添加数据，所以其实新数据添加至前端还是后端都可以，要保证两部分都是排序过的数据</p><p>排序过后，两个堆顶作为交流的通道，传递顶值，这样就会有最大堆的最小值放入最小堆，最小堆的最大值防入最大堆</p><p>因为数据是依次放入的，整个部分除去中位数的部分就都是顺序排序的，而偶数时的中位数是取中间值，不论顺序相加除2即可</p><p>当位奇数位时，新添加值会与两个中位数对比后返回</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class MedianFinder &#123;    /** initialize your data structure here. */     Queue&lt;Integer&gt; A, B;    public MedianFinder() &#123;        A = new PriorityQueue&lt;&gt;(); // 小顶堆，顺序排列，保存较大的一半，弹出最小        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，逆序排列，保存较小的一半，弹出最大    &#125;    public void addNum(int num) &#123;        if(A.size() != B.size()) &#123;            A.add(num);            B.add(A.poll());        &#125; else &#123;            B.add(num);            A.add(B.poll());        &#125;    &#125;    public double findMedian() &#123;        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;    &#125;&#125;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */</code></pre><p>其实我也没有想到PriorityQueue，不过类似的使用了堆和对应的堆排序</p><p>以下是我的代码，但是用例超时…</p><pre><code class="java">class MedianFinder &#123;    /** initialize your data structure here. */     Stack&lt;Integer&gt; A, B;    public MedianFinder() &#123;        A = new Stack&lt;&gt;(); // 顺序排列，保存较大的一半，弹出最小        B = new Stack&lt;&gt;(); // 逆序排列，保存较小的一半，弹出最大    &#125;    public void addNum(int num) &#123;        if(A.size() != B.size()) &#123;            sortBigStack(A,num);            sortSmlStack(B,A.pop());        &#125; else &#123;            sortSmlStack(B,num);            sortBigStack(A,B.pop());        &#125;    &#125;    public double findMedian() &#123;        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;    &#125;    public void sortBigStack(Stack&lt;Integer&gt; stack, int a) &#123;        Stack&lt;Integer&gt; midStack = new Stack&lt;&gt;();        while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; a) &#123;            midStack.push(stack.pop());        &#125;        stack.push(a);        while(!midStack.isEmpty())&#123;            stack.push(midStack.pop());        &#125;    &#125;        public void sortSmlStack(Stack&lt;Integer&gt; stack, int a) &#123;        Stack&lt;Integer&gt; midStack = new Stack&lt;&gt;();        while(!stack.isEmpty() &amp;&amp; stack.peek() &lt; a) &#123;            midStack.push(stack.pop());        &#125;        stack.push(a);        while(!midStack.isEmpty())&#123;            stack.push(midStack.pop());        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day16_数组排序_剑指Offer</title>
      <link href="/2023/04/05/leetCode/%E5%89%91%E6%8C%87Offer/Day16_%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/05/leetCode/%E5%89%91%E6%8C%87Offer/Day16_%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [10,2]输出: &quot;102&quot;输入: [3,30,34,5,9]输出: &quot;3033459&quot;</code></pre><p><strong>限制：</strong></p><ol><li><p>0 &lt; nums.length &lt;&#x3D; 100</p></li><li><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数</p></li><li><p>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>返回凭借的最小字符（数值），按题目示例来看，我们需要将数组高位代表的值尽可能小的排字符前方，比如同样长度，以3开头一定小于以5开头，同时也需要后</p><p>几位尽可能的小，如 3 和 30 可以组合 330 和 303，30的个位0位于组合后的十位显然比位于组合都的个位更小</p><p>简而言之，需要我们自行给数组按<strong>特定要求</strong>排序</p><ol><li><strong>实现数与数的对比，能够量化一种标准判断排序要求</strong></li></ol><p>特定要求：xy &gt; yx 时，y在前，x在后，判断返回大值</p><p>实现：构建StringBuilder类，实现 xy 与 yx ，考虑到数据过大，转为Long类型对比大小 （tips：受教Java中的BigInteger或许可以更加安全的检验）</p><p>​xy大时返回x，否则返回y</p><ol start="2"><li><strong>实现排序：相邻两两对比–可以使用冒泡排序</strong></li></ol><p>实现：遍历数组，使用冒泡排序将大值不断后送，缩短排序区间 </p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public String minNumber(int[] nums) &#123;        StringBuilder ans = new StringBuilder();        // 冒泡排序        for(int i=nums.length-1; i&gt;0; i--) &#123;            for(int j=0; j&lt;i; j++) &#123;                if(findBigOne(nums[j],nums[j+1]) == nums[j])                    swap(nums, j, j+1);             &#125;        &#125;        for(int num : nums)            ans.append(num);        return ans.toString();    &#125;    // 返回相邻两个数中，组合位于前端时后会带来更大结果的值    public int findBigOne(int m, int n) &#123;        StringBuilder a = new StringBuilder();        StringBuilder b = new StringBuilder();        a.append(m);        a.append(n);        b.append(n);        b.append(m);        return a;        if(Long.valueOf(a.toString()).compareTo(Long.valueOf(b.toString())) == 1)            return m;        return n;    &#125;    // 交换函数    public void swap(int[] nums ,int i, int j) &#123;        int mid = nums[i];        nums[i] = nums[j];        nums[j] = mid;    &#125;&#125;</code></pre><h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">扑克牌中的顺子</a></p><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [1,2,3,4,5]输出: True输入: [0,0,1,2,5]输出: True</code></pre><p><strong>提示：</strong></p><ol><li>数组长度为 5 </li><li>数组的数取值为 [0, 13] .</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>相邻且连续的五个值，且本身数值量不大（0-13），题目可以使用一点取巧的方式</p><ol><li>既然是五个连续的值，那么最大值与最小值的差一定不会超过4</li><li>需要考虑到0的存在：已有最大最小，差为4，零用于补充中间；缺少最大或最小，差小于4，零用于补两边</li><li>保证数组中不存在相同的值，否则直接返回false</li></ol><p>实现上就很好说了，找到最大和除去0的最小值，判断是否有重复值，判断差值是否大于4，都为否返回true，否则返回false</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean isStraight(int[] nums) &#123;        Arrays.sort(nums);        int min = 14;        int max = nums[nums.length - 1];        for(int i=0; i&lt;nums.length-1; i++) &#123;            if(nums[i] != 0 &amp;&amp; nums[i]&lt;min) min = nums[i];            if(nums[i] != 0 &amp;&amp; nums[i] == nums[i+1]) return false;        &#125;        if((max - min) &gt; 4)return false;        return true;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day15_树的遍历_剑指Offer</title>
      <link href="/2023/04/04/leetCode/%E5%89%91%E6%8C%87Offer/Day15_%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2023/04/04/leetCode/%E5%89%91%E6%8C%87Offer/Day15_%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></p><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><strong>示例：</strong></p><pre><code class="java">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]]输入：root = [1,2,3], targetSum = 5输出：[]输入：root = [1,2], targetSum = 0输出：[]</code></pre><p><strong>限制：</strong></p><ol><li><p>树中节点总数在范围 <code>[0, 5000]</code> 内</p></li><li><p>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p></li><li><p>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>明确题目要求，<strong>叶子节点到根节点的路径和为target</strong></p><p>写入结果判断需要满足：是叶子节点（now.left &#x3D;&#x3D; null &amp;&amp; now.right &#x3D;&#x3D; null）路径和为target</p><p>对于树结构，从根目录出发到叶子节点显然比反过来方便，值转递上也使用 target - now.val</p><p>实现：</p><ol><li>定义全局变量：ans 记录最后结论，midList记录每一条结论</li><li>先不断递归 target - now.val 直到叶子节点，途中的值写入中间变量midList</li><li>判断是否满足上述写入判断（now.left &#x3D;&#x3D; null &amp;&amp; now.right &#x3D;&#x3D; null &amp;&amp; target &#x3D;&#x3D; 0）。如果是，写入当前midList至ans</li><li>回到上一级，判断是否可以走另外的子节点，回到2判断</li><li>遍历完成，返回全局变量ans</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    LinkedList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();;    LinkedList&lt;Integer&gt; midList = new LinkedList&lt;Integer&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;        findWay(root, target);        return ans;    &#125;    public void findWay(TreeNode root, int target) &#123;        if(root == null) return;        midList.add(root.val);         target -= root.val;        if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123;            ans.add(new LinkedList(midList));        &#125;        findWay(root.left, target);        findWay(root.right, target);        midList.removeLast();        return;    &#125;&#125;</code></pre><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>我们希望将二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个</p><p>节点的后继是第一个节点。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于二叉搜索树，树中每个节点都满足：<strong>一个节点的左子树值小于根节点值，右子树值大于根节点值</strong></p><p>而对于中序遍历：<strong>先遍历左子树，再读取当前节点，最后读取右子树</strong></p><p>综合以上两者，我们会发现，中序遍历的二叉搜索树就是一个排好序的输出</p><p>实现：</p><ol><li>对于原根节点，进行中序遍历</li><li>依次遍历左节点，直至叶子节点</li><li>当前是未记录的最小值，左节点连以记录最大值，当前就是已记录的尾节点；如果当前没记录，就设未头节点（最小值）</li><li>遍历右节点，回到 2，直至完成遍历</li><li>连接头节点和尾节点</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/*// Definition for a Node.class Node &#123;    public int val;    public Node left;    public Node right;    public Node() &#123;&#125;    public Node(int _val) &#123;        val = _val;    &#125;    public Node(int _val,Node _left,Node _right) &#123;        val = _val;        left = _left;        right = _right;    &#125;&#125;;*/class Solution &#123;    Node pre, head;    public Node treeToDoublyList(Node root) &#123;        if(root == null) return null;        dfs(root);        head.left = pre;        pre.right = head;        return head;    &#125;    void dfs(Node cur) &#123;        if(cur == null) return;        dfs(cur.left);        if(pre == null) head = cur;        else pre.right = cur;        cur.left = pre;        pre = cur;        dfs(cur.right);    &#125;&#125;</code></pre><h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></p><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><p><strong>示例：</strong></p><pre><code class="java">输入: root = [3,1,4,null,2], k = 1   3  / \ 1   4  \   2输出: 4输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \     3   6    / \   2   4  / 1输出: 4</code></pre><p><strong>提示：</strong></p><ol><li>1 ≤ k ≤ 二叉搜索树元素个数</li></ol><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树：左子树值 &lt; 根节点值 &lt; 右子树值</p><p>以右，中，左的顺序遍历每一个子节点，减少方法的传参量，将第k大的要求k设定为全局参数</p><p>每递归到一位就对应减 1 ，直至到达第 k 大的数据时返回</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    int ans, k;    public int kthLargest(TreeNode root, int k) &#123;        this.k = k;        dfs(root);        return ans;    &#125;    public void dfs(TreeNode root) &#123;        if(root == null) return;        dfs(root.right);        if(k == 0) return;        if(--k == 0) ans = root.val;        dfs(root.left);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer_Day14_递归遍历</title>
      <link href="/2023/04/03/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/03/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></p><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p><p><strong>示例：</strong></p><pre><code class="java">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false</code></pre><p><strong>限制：</strong></p><ol><li><p>m &#x3D;&#x3D; board.length</p></li><li><p>n &#x3D; board[i].length</p></li><li><p>1 &lt;&#x3D; m, n &lt;&#x3D; 6</p></li><li><p>1 &lt;&#x3D; word.length &lt;&#x3D; 15</p></li><li><p>board 和 word 仅由大小写英文字母组成</p></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题其实主要需要解决两个问题：单词会从何开始，单词要怎么结束</p><p>前者可以使用暴力递归，遍历二维数组，找到符合字符串首字符的即可</p><p>后者需要以前者找到的字符串为基础，探索上下左右是否有相邻字符，直至单词结尾</p><p>需要注意的是，上下左右的探索需要排除明显超出二位数组范围的部分，和已经探索完成的部分</p><p>我使用一个临时变量，存储已经遍历的值，这使得如果单词匹配中出现了误差，需要另找开头字符，不至于将上次遍历的痕迹影响到此次</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean exist(char[][] board, String word) &#123;        // 1.如何开始找单词 -- 第一个字符组字怎么找        // 2.如果在遍历中传递对比值 -- 考虑算法需要回溯        for(int i=0; i&lt;board.length; i++) &#123;            for(int j=0; j&lt;board[0].length; j++) &#123;                if(dfs(board, i, j, word, 0)) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    public static boolean dfs(char[][] board, int i, int j, String word, int k) &#123;        int sizeA = board.length,sizeB = board[0].length;        if(i == sizeA || i == -1 || j == sizeB || j == -1 || board[i][j] != word.charAt(k)) return false;        if(k == word.length()-1) return true;        char mid = board[i][j];        // 挖空以遍历部分，防止重复读        board[i][j] = &#39; &#39;;        boolean ans = dfs(board,i+1,j,word,k+1) || dfs(board,i-1,j,word,k+1)                   || dfs(board,i,j+1,word,k+1) || dfs(board,i,j-1,word,k+1);        // 回复挖空，保证下次读        board[i][j] = mid;        return ans;    &#125;&#125;</code></pre><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><p><strong>示例：</strong></p><pre><code class="java">输入：m = 2, n = 3, k = 1输出：3输入：m = 3, n = 1, k = 0输出：1</code></pre><p><strong>提示：</strong></p><ol><li>1 &lt;&#x3D; n,m &lt;&#x3D; 100</li><li>0 &lt;&#x3D; k &lt;&#x3D; 20</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题不可以暴力遍历，考虑到机器人对目标是需要移动手段的，有些符合要求但是机器人却没法到达的部分是不能算作结果的一部分</p><p>那么较好的方法是模拟机器人，从[0,0]向左向下递归遍历，走遍相邻的符合条件的格子并计数</p><p>但是没有对应的二维数组存储已走过的路程信息，只能新new一个用于判断的二维boolean数组，避免重复计数</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int m,n,k;    public int movingCount(int m, int n, int k) &#123;       this.m = m; this.n = n; this.k = k;       boolean[][] flag = new boolean[m][n];       return dfs(flag,0,0);    &#125;    public int dfs(boolean[][] flag, int i, int j) &#123;        if(i &gt;= m || j&gt;=n || flag[i][j] || getSum(i,j)&gt;k) return 0;        flag[i][j] = true;        return 1 + dfs(flag, i+1, j) + dfs(flag, i,j+1);    &#125;    public int getSum(int i, int j) &#123;        int sum = 0;        while(i &gt; 0) &#123;            sum += i%10;            i = i/10;        &#125;        while(j &gt; 0) &#123;            sum += j%10;            j = j/10;        &#125;        return sum;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第十三天</title>
      <link href="/2023/04/02/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9_%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
      <url>/2023/04/02/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9_%E5%8F%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><p><strong>示例：</strong></p><pre><code class="java">输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 50000&#96;</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针，一头一尾向中间遍历，满足前为奇数头指针后移，满足后为偶数尾指针前移，直到两个都不可移动，交换到两个指针相交</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int n = nums.length, i = 0, j = n-1;        while(i&lt;j) &#123;            while(i &lt; n &amp;&amp; nums[i]%2==1) i++;            while(j &gt; 0 &amp;&amp; nums[j]%2==0) j--;            if(i&gt;=j) break;            swap(nums,i,j);        &#125;        return nums;    &#125;    public static void swap(int[] nums, int i, int j)&#123;        int mid = nums[i];        nums[i] = nums[j];        nums[j] = mid;    &#125;&#125;</code></pre><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字</a></p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例：</strong></p><pre><code class="java">输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2]输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10]</code></pre><p><strong>限制：</strong></p><ul><li><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</p></li><li><p>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一个递增排序的数组，就先将大于target的部分跳过，从第一个小于target的部分与头部最小数据做双指针</p><p>数字过小就头指针后移，数据过大就尾指针前移</p><p>逻辑：<strong>因为 a &lt; b &lt; c &lt; d；所以  a + c &lt; a + d &lt; b + d， a + b &lt; a + c &lt; b + c，b + c &lt; b + d &lt; c + d</strong></p><p>这说明了什么呢？</p><p>看第一个结果 <strong>a + d</strong> ，将<strong>对于a和d的结果</strong>划分为了两个部分：大于 a + d 的和小于a + d 的</p><p>看第二个结果的 <strong>a + c</strong> ，将<strong>对于a和c的结果</strong>划分为了两个部分：大于 a + c 的和小于a + c的</p><p>看第三个结果的 <strong>b+ d</strong> ，将<strong>对于b和d的结果</strong>划分为了两个部分：大于 b + d 的和小于 b + d的</p><p>也就是说，将这个相加的结果视为一个二维数组的话</p><p>​<strong>a b c d</strong></p><p><strong>a</strong>a+a a+b a+c a+d</p><p><strong>b</strong>   b+a b+b b+c b+d</p><p><strong>c</strong>c+a c+b  c+c  c+d</p><p><strong>d</strong>d+a d+b d+c d+d</p><p>这个数组满足：每一行都递增，每一列都递增</p><p>看看以前的一道题：《在二维数组中查找》</p><p><a href="https://xcscx.github.io/2023/03/25/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%BA%94%E5%A4%A9_%E6%95%B0%E7%BB%84/">leetcode剑指Offer第五天 | IT蛋的个人博客 (xcscx.github.io)</a></p><p>我们可以得到结论，要想找到某个值，可以从二维数组右上角入手，小就向左移动，大就朝下移动</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int l = 0, r = nums.length-1;        for(l=0; l&lt;r;) &#123;            if(nums[r] &gt; target) &#123;                r--;                continue;            &#125;            int mid = nums[l] + nums[r];            if(mid == target) &#123;                return new int[] &#123; nums[r], nums[l] &#125;;            &#125;else if(mid &gt; target) &#123;                r--;            &#125;else &#123;                l++;            &#125;        &#125;        return null;    &#125;&#125;</code></pre><h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序</a></p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例：</strong></p><pre><code class="java">输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><p><strong>限制：</strong></p><ul><li><p>无空格字符构成一个单词。</p></li><li><p>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></li><li><p>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>重复的车轮，其实也可以将String拆成char[]去一个个判断，被空格分隔的作为一个整体倒叙填入StringBuilder，空格跳过</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public String reverseWords(String s) &#123;        String[] strs = s.trim().split(&quot; &quot;);        StringBuilder ans = new StringBuilder();        for(int i = strs.length - 1; i &gt;= 0; i--) &#123;            if(strs[i].equals(&quot;&quot;)) continue;            ans.append(strs[i] + &quot; &quot;);        &#125;        return ans.toString().trim();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第十二天</title>
      <link href="/2023/04/01/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9_%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/04/01/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9_%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例：</strong></p><pre><code class="java">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>并行比较两边的大小，依次遍历相接</p><ol><li>对于判空，用于开始判空，如果原本的 l1 或 l2 就存在空，直接返回。也可以在遍历时，其中一边已经完成遍历全部进入排序，判空使剩下数组快速进入排序</li><li>对于比大小，首次比大小决定是使用 l1 还是 l2 作为最后组合排序的结果返回，后续遍历作为后接链表的判断</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1 == null)  return l2;        if(l2 == null)  return l1;        if(l1.val &lt;= l2.val)&#123;            l1.next = mergeTwoLists(l1.next,l2);            return l1;        &#125;else&#123;            l2.next = mergeTwoLists(l1,l2.next);            return l2;        &#125;       &#125;&#125;</code></pre><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a></p><p>输入两个链表，找出它们的第一个公共节点。</p><p><strong>示例：</strong></p><pre><code class="java">4 → 1 → 8 → 4 → 5        ↑5 → 0 → 1     输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>限制：</strong></p><ul><li><p>如果两个链表没有交点，返回 null.</p></li><li><p>在返回结果后，两个链表仍须保持原有的结构。</p></li><li><p>可假定整个链表结构中没有循环。</p></li><li><p>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>首先，假定两个链表一定有交点</strong>，那么这整个结构可以被分为三个部分：</p><ol><li>链表1不重复的部分，长度a</li><li>链表2不重复的部分，长度b</li><li>链表1和链表2重复部分，长度c</li></ol><p>限制中程序需要尽量满足O( n )时间复杂度，所以只不能对其中一边遍历：<strong>对链表1和链表2走相同长度遍历到相交节点</strong></p><p>只单独遍历两个链表自然是不大可能做到恰好a与b长度一致而返回节点，那不妨”链接“两个链表</p><p>对于链表1，在遍历完成后，继续遍历链表2，遍历长度：<strong>a+c+b+c</strong></p><p>对于链表2，在遍历完成后，继续遍历链表1，遍历长度：<strong>b+c+a+c</strong></p><p>通过上述两个式子，不难看出，如果同步遍历的话，其实只要走 a+c+b ( b+c+a )的长度就会相遇，也就是第二次遇到相交节点时相遇</p><p><strong>不过还有另一种可能：两个链表没有相交</strong></p><p>对于链表1，在遍历完成后，继续遍历链表2，遍历长度：<strong>a+b</strong></p><p>对于链表2，在遍历完成后，继续遍历链表1，遍历长度：<strong>b+a</strong></p><p>最后发现两边都为null，那就返回null</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */class Solution &#123;    ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if(headA == null || headB == null) &#123;            return null;        &#125;        ListNode A = headA, B = headB;        while(A != B) &#123;            A = A!=null ? A.next : headB;            B = B!=null ? B.next : headA;        &#125;        return A;    &#125;&#125;</code></pre><h3 id="扩展：判断一个可能带环的链表，入环节点在哪"><a href="#扩展：判断一个可能带环的链表，入环节点在哪" class="headerlink" title="扩展：判断一个可能带环的链表，入环节点在哪"></a>扩展：判断一个可能带环的链表，入环节点在哪</h3><p>印象里的一个题，做第二题的时候想到了，就顺带记录一下</p><p><strong>题目：给你一个链表，它可能带环（也可能不带），如果它带环，请返回入环节点，如果不带环，请返回null</strong></p><p>限制：如果带环，一定存在入环节点（不会是一整个环）</p><p>思路：使用快慢指针，如果快指针指到null，说明不带环；如果快慢指针相遇，将快指针指回开头，以慢指针的步调与慢指针一起移动，下次相遇一定是入环节点</p><p>Java代码：</p><pre><code class="java">class Solution &#123;    ListNode fun(ListNode head) &#123;        if(head == null || head.next == null || head.next.next == null) return null;        // A作为慢指针，B作为快指针        ListNode A = head.next, B = head.next.next;        while(A != B) &#123;            if(B.next != null &amp;&amp; B.next.next != null) &#123;                return null;            &#125;            A = A.next;            B = B.next.next;        &#125;        B = head;        while(A != B) &#123;            A = A.next;            B = B.next;        &#125;        return A;    &#125;&#125;</code></pre><p>数学证明：</p><p>1 → 2 → 3 → 4 → 5</p><p>​ ↑         ↓ </p><p>​     7     ←    6</p><p>以这个环为例：首次快慢指针相交会指向6，加上入环节点，整个结构需要注意三个部分长度：</p><ol><li>入环前长度：a （1 - 2 - 3）</li><li>入环至相交的长度：b （3 - 4 - 5 - 6）</li><li>环的长度：c （3 - 4 - 5 - 6 - 7 - 3 ）</li></ol><p>首次相交，快指针走了：a + c + b，慢指针走了：a + b，我们得到：a + c + b &#x3D; 2（a + b）,即 c &#x3D; a + b</p><p>将快指针重置会头节点，再次走向入环节点，需要走：a</p><p>此时的慢指针走向入环节点，需要走：c - b &#x3D; a</p><p>综上，证明成功</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第十一天</title>
      <link href="/2023/03/31/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9_%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/31/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>示例：</strong></p><pre><code class="java">输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p><strong>限制：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表中删除一个节点，要当前节点的上一个节点的next指向当前节点的next，如:1 → 2 → 4 删去 2 ，需要将 1 ( 2的上指针 )的next指针指向 4 ( 2的next所指 )</p><p>为了避免第一个值就是所需删除的值（不存在上一节点），可以直接返回next</p><p>时间复杂度：O( N )    空间复杂度：O( 1 )</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        if(head.val == val)return head.next;        ListNode n1 = head,n2 = head, n3 = null;        while(n1 != null)&#123;            n2 = n1.next;            if(n2.val == val)&#123;                n3 = n2.next;                n1.next = n3;                break;            &#125;            n1 = n1.next;        &#125;        return head;    &#125;   &#125;</code></pre><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><pre><code class="java">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code></pre><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以先使用一个中间节点遍历获得链表长度，再遍历至 len-K 的位置返回</p><p>又或者·：倒数第K个节点，和正数第K个节点，都是将整个链表分为了 len-K 和 K 个节点</p><p>新建两个节点，第一位先走K步到达第K个节点，还剩 len-K 个节点没走</p><p>再让两个节点同步走完 len-K 个节点，第一节点恰好走完全部，第二节点到达 len-K 处</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        if(head == null) return head;        ListNode n1 = head, n2 = head;        for(int i=0; i&lt;k; i++) &#123;            n1 = n1.next;        &#125;        while(n1 != null) &#123;            n1 = n1.next;            n2 = n2.next;        &#125;        return n2;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第十天</title>
      <link href="/2023/03/30/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E5%A4%A9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/03/30/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%8D%81%E5%A4%A9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串</a></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例：</strong></p><pre><code class="java">输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= num &lt; 231</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>从尾到头进行动态规划，如果最后两位符合26以内的值F(N) &#x3D; F(N-1)+F(N-2) 否则就只有 F(N) &#x3D; F(N-1)</strong></p><p>将0-25的数字编码为a-z的字符，既可以尝试单个数字去编码，又可以判断是否满足一定条件使得两个数字作为一个参数去编码</p><p>要求遍历完整个数字后看看有多少种编码手段。</p><p>初见题目的时候，我就觉得很像之前的青蛙跳台阶问题，可以选择一步步走，又或者一次跳两格,不过这一题多了一点条件</p><p>请思考这么一个：最后一个数进行编码时，有几种可能？</p><p>\1. 单独编码:如果最后两位&gt;25，那最后一位就只能自己编码，所以F(N) &#x3D; F(N-1)</p><p>\2. 联合编码:如果最后两位&lt;26，且最后两位可以分开编码-F(N-1)，也可以一起编码-F(N-2)即F(N) &#x3D; F(N-1)+F(N-2)</p><p>注意：因为0也是被允许的数字，但是0不可作为十位数（没有意义）所以在0作为十位时，只能返回F(N) &#x3D; F(N-1)</p><p>ps：青蛙跳台阶：<a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</a></p><p>ps2：挂了个自己的题解： <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/java-dong-tai-gui-hua-by-bold-morsezl7-jsdh/">Java-动态规划 - 把数字翻译成字符串 - 力扣（LeetCode）</a></p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int translateNum(int num) &#123;        if(num &lt; 10) return 1;        if(num % 100 &lt; 26)            if(num%100 != num%10)                return translateNum(num/10) + translateNum(num/100);        return translateNum(num/10);    &#125;&#125;</code></pre><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">最长不含重复字符的子字符串</a></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例：</strong></p><pre><code class="java">输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p><strong>限制：</strong></p><ul><li><code>s.length &lt;= 40000</code></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>不含重复字符的子串，解决这个问题可以将情况分为以下几类：</p><ol><li>这个字符没有重复过：子串长度+1</li><li>字符重复了，且在当前子串中：子串长度设置为当前重复字符间这一部分加后重复子串，如：abcdb，检查到最后一个b时，原本子串为abcd，这时因为b重复了，且在当前子串中重复，所以将子串调整为cdb，即两个b中间的部分加上后一个b</li><li>字符重复了，但是不在当前子串：子串长度+1，如abbcda，检查到最后的a时，子串应该是bcd，尽管a在整个子符中重复了，对于子串而言还是没重复的</li></ol><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        char[] str = s.toCharArray();        HashMap&lt;Character,Integer&gt; lastSameStr = new HashMap&lt;&gt;();        int ans = 0, mid = 0;        for(int i=0; i&lt;str.length; i++) &#123;            if(lastSameStr.get(str[i]) == null) &#123;                mid++;            &#125;else &#123;                if(mid &gt;= i-lastSameStr.get(str[i]))                    mid = i - lastSameStr.get(str[i]);                else                    mid++;            &#125;            lastSameStr.put(str[i],i);            ans = Math.max(ans,mid);        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第九天</title>
      <link href="/2023/03/29/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B9%9D%E5%A4%A9_%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/03/29/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B9%9D%E5%A4%A9_%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例：</strong></p><pre><code class="java">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p><strong>限制：</strong></p><ul><li>1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</li><li>-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将连续子数组视为一个数，这个数如果为负，加上后续的和一定小于后续，所以更新；如果为正，直接将后续值填入子数组再判断</p><p>循环判断完整个数组，在遍历时判断更新最大值</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int ans = Integer.MIN_VALUE;        int mid = 0;        for(int num : nums) &#123;            mid = mid&gt;0 ? mid+num : num;            ans = mid&gt;ans ? mid : ans;        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例：</strong></p><pre><code class="java">输入: [  [1,3,1],  [1,5,1],  [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt; grid.length &lt;&#x3D; 200</li><li>0 &lt; grid[0].length &lt;&#x3D; 200</li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单动态规划，因为只能向下或右行动，所以创建一个同等大小的二维数组作为最大值记录，</p><p>提前设计好第一行和第一列的数据，再遍历补完整个二维数组：取上方或左方更大的一位加上本格的值，得到每个格子最大的值，返回最下最右的值</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int maxValue(int[][] grid) &#123;        int m = grid.length, n = grid[0].length;        int[][] maxTable = new int[m][n];        maxTable[0][0] = grid[0][0];        for(int i=1; i&lt;m; i++) maxTable[i][0] = maxTable[i-1][0] + grid[i][0];        for(int i=1; i&lt;n; i++) maxTable[0][i] = maxTable[0][i-1] + grid[0][i];        for(int i=1; i&lt;m; i++) &#123;            for(int j=1; j&lt;n; j++) &#123;                maxTable[i][j] = Math.max(maxTable[i-1][j],maxTable[i][j-1])+grid[i][j];            &#125;        &#125;        return maxTable[m-1][n-1];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第八天</title>
      <link href="/2023/03/28/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%85%AB%E5%A4%A9_%E9%80%92%E5%BD%92%E6%9B%B4%E6%96%B0/"/>
      <url>/2023/03/28/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%85%AB%E5%A4%A9_%E9%80%92%E5%BD%92%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列</a></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例：</strong></p><pre><code class="java">输入：n = 2输出：1输入：n = 5输出：5</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt;&#x3D; n &lt;&#x3D; 100&#96;</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照题目要求来，设定好最初的 0 和 1对象，对接下来的递归使用F(N) &#x3D; F(N-1) + F(N-2)</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int fib(int n) &#123;        if(n == 0) return 0;        if(n == 1) return 1;        int q = 0, p = 1,r = 1;        for(int i = 2; i&lt;n; i++) &#123;            q = p;            p = r;            r = (q+p)%1000000007;        &#125;        return r;    &#125;&#125;</code></pre><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题</a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例：</strong></p><pre><code class="java">输入：n = 2输出：2输入：n = 7输出：21输入：n = 0输出：1</code></pre><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; n &lt;&#x3D; 100&#96;</li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路转换一下，其实和上一题是一个意思：</p><p>因为青蛙只能一次跳一格或两格，所以考虑青蛙在F( N )最后是跳一格还是两格</p><p>如果是跳一格，那就是先跳 F( N-1 )的格子，再跳 1 格</p><p>如果是跳两格，那就是线条 F( N-2 )的格子，再跳 2 格</p><p>最后一步是固定的，所以F ( N )其实就是 F( N-1 ) + F( N-2 )</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int numWays(int n) &#123;       if(n==0 || n==1) return 1;       int pre = 1, prepre = 1, fin = 0;       for(int i=2; i&lt;=n; i++)&#123;           fin = (pre+prepre)%1000000007;           prepre = pre;           pre = fin;       &#125;       return fin;    &#125;&#125;</code></pre><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例：</strong></p><pre><code class="java">输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归更新数据：最小值，最大差</p><p>设定初值为0（没有买入股票），每到一个节点判断是否要更新最小值，判断是否产生了最大值</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        int minPrice = Integer.MAX_VALUE, ans = 0;        for(int price : prices) &#123;            minPrice = Math.min(price, minPrice);            ans = Math.max(ans, price - minPrice);        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第七天</title>
      <link href="/2023/03/27/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%83%E5%A4%A9_%E5%AD%90%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/27/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%83%E5%A4%A9_%E5%AD%90%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><p>​      3<br>​     &#x2F; \</p><p>   4   5<br>  &#x2F; <br> 1   2<br>给定的树 B：</p><p>   4<br>  &#x2F;<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例：</strong></p><pre><code class="java">输入：A = [1,2,3], B = [3,1]输出：false输入：A = [3,4,5,1,2], B = [4,1]输出：true</code></pre><p><strong>限制：</strong></p><ol><li>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>证明一个树B是另一棵树A的子结构，按顺序要证明两点：</p><ol><li>找到 B 的根节点在 A 中的位置</li><li>在根节点正确的前提下，只要 B 不为null的地方，A 都应该与其值相同</li></ol><p>接下来就是分析遍历：</p><ol><li>明确一个rootNode函数，作用是判断传入的B节点是否是A的子结构，与主方法不同的是，前者只要判断根节点这一个节点，后者需要遍历判断整个B子树。</li><li>将子结构判断交给rootNode，主方法要做的就是遍历 A 判断和 B 根节点相同的节点：判断当前节点 - 判断左节点 - 判断右节点</li><li>rootNode函数递归判断当前节点值，左节点值，右节点值是否和 A 中一致</li></ol><p>注：主函数中最后递归 return 使用的条件是  || 或，因为只要判断是子结构就行，不用在意有几次子结构，所以如果前者返回true，后者就不用计算了，而rootNode方法则需要完整的判断B的全部节点都在A中，所以return条件为 &amp;&amp; 与</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;        if(A==null || B==null) return false;        if(A.val == B.val &amp;&amp; rootNode(A.left, B.left) &amp;&amp; rootNode(A.right, B.right)) &#123;            return true;        &#125;        return (isSubStructure(A.left, B) || isSubStructure(A.right, B));    &#125;    // 判断节点B是否为A的子结构    public boolean rootNode(TreeNode A, TreeNode B) &#123;        if(B == null) return true;        if(A == null || A.val != B.val) return false;        return (rootNode(A.left, B.left) &amp;&amp; rootNode(A.right, B.right));    &#125;&#125;</code></pre><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p>​     4</p><p>   &#x2F;   <br>  2     7<br> &#x2F; \   &#x2F; <br>1   3 6   9<br>镜像输出：</p><p>​     4</p><p>   &#x2F;   <br>  7     2<br> &#x2F; \   &#x2F; <br>9   6 3   1</p><p><strong>示例：</strong></p><pre><code class="java">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>提示：</strong></p><ol><li>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这里涉及到一个二叉树遍历问题，详情可以看我这篇博客：<a href="https://xcscx.github.io/2022/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树 | IT蛋的个人博客 (xcscx.github.io)</a></p><p>简单来说，二叉树在遍历时会三次经过当前节点，以先序遍历做例子分别是：第一次访问、从访问的左节点返回、从访问的右节点返回</p><p>对于像本题中的全反问题，其实就是从叶子节点开始，将自己的左右子树对换，递推回根节点，那么什么时候兑换呢</p><p>替换发生在第一次，或者最后一次访问当前节点较好</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        if(root == null) return root;         mirrorTree(root.right);        mirrorTree(root.left);        TreeNode mid = root.right;        root.right = root.left;        root.left = mid;        return root;    &#125;&#125;</code></pre><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>​    1</p><p>   &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>​    1</p><p>   &#x2F; <br>  2   2<br>   \   <br>   3    3</p><p><strong>示例：</strong></p><pre><code class="java">输入：root = [1,2,2,3,4,4,3]输出：true输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 节点个数 &lt;= 1000</code></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>交换判断左右子树的左右子树，即先判断左右子树是否相等，再将左子树的左右子树和右子树的右左子树递归以上判断</p><p>直到双方同时为 null 返回 true</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root == null) return true;        return isSonOk(root.left, root.right);    &#125;    public boolean isSonOk(TreeNode A, TreeNode B) &#123;        if(A == null &amp;&amp; B == null) return true;        if(A == null || B == null || A.val != B.val) return false;        return (isSonOk(A.left, B.right) &amp;&amp; isSonOk(A.right, B.left));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第六天</title>
      <link href="/2023/03/26/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%85%AD%E5%A4%A9_BFS%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/26/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%85%AD%E5%A4%A9_BFS%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>了解今天的题目前，可以去我的博客看看二叉树和BFS（宽度优先遍历）知识：<a href="https://xcscx.github.io/2022/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树 | IT蛋的个人博客 (xcscx.github.io)</a></p><h2 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树</a></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><strong>示例：</strong></p><pre><code class="java">给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回 [3,9,20,15,7]</code></pre><p><strong>限制：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树的广度优先算法，因为输出时不需要考虑节点之间的关系，所以按照从上至下，从左至右的顺序存储输出即可</p><p>二叉树的BFS（宽度优先遍历）最常见的实现方式是利用队列进行存储，因为队列是先进先出，所以在遍历每一节点时将全部子节点填入队列，这样，在子节点全部遍历完成前，子节点的子节点不会被遍历到，依次类推，直到队列为空</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int[] levelOrder(TreeNode root) &#123;                ArrayList&lt;Integer&gt; utilsArray = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;();        treeQueue.add(root);        while(null != treeQueue.element()) &#123;            TreeNode mid = treeQueue.element();            if(mid.left != null) &#123;                treeQueue.add(mid.left);            &#125;            if(mid.right != null) &#123;                treeQueue.add(mid.right);            &#125;            utilsArray.add(treeQueue.poll().val);        &#125;        int[] ans = new int[utilsArray.size()];        for(int i=0; i&lt;utilsArray.size(); i++)&#123;            ans[i] = utilsArray.get(i);        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>示例：</strong></p><pre><code class="java">给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层次遍历结果：     [  [3],  [9,20],  [15,7]]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>同样是宽度优先遍历，但是要求记录每一层节点的长度，或者说记录每一层节点的最后一个节点是谁</p><p>本来实现是通过新增两个TreeNode节点，一个记录当前层最后一个节点，一个记录下一层最后一个节点</p><p>后者在每一个子节点添加时做更新，当节点来到当前层的最后节点，输出数组并更新当前最后节点为下一层最后节点值</p><p>不过实现确实过于冗长了…</p><p>这里展示另一位大佬的思路：因为每次遍历完一层，<strong>队列中就只剩下下一层的全部节点</strong>，我们可以借由此作为下一层读取节点的个数，以此类推</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        if(root != null) treeQueue.add(root);                while(!treeQueue.isEmpty()) &#123;            List&lt;Integer&gt; mid = new ArrayList&lt;&gt;();            for(int i=treeQueue.size(); i&gt;0; i--) &#123;                TreeNode midNode = treeQueue.peek();                if(midNode.left != null) treeQueue.add(midNode.left);                if(midNode.right != null) treeQueue.add(midNode.right);                mid.add(treeQueue.poll().val);            &#125;            ans.add(mid);        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">从上到下打印二叉树 III</a></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><strong>示例：</strong></p><pre><code class="java">给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层次遍历结果：[  [3],  [20,9],  [15,7]]</code></pre><p><strong>限制：</strong></p><ul><li><code>节点总数 &lt;= 1000</code></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路和上一题差不多，同样是分层输出的宽度优先，不过有一个输出顺序需要考虑</p><p>这里首先考虑到每层遍历时的输入，说白了就是一个正序一个倒序，只要在每一层输入时一个正着输入一个倒着输入就好</p><p>适用每层遍历后，结果的长度判断什么时候正序什么时候倒序</p><p>将原本用于存储的List<Integer> 转为 LinkedList<Integer> 适用头插尾插方法实现</Integer></Integer></p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;&gt;();        if(root != null) treeQueue.add(root);        while(!treeQueue.isEmpty()) &#123;            LinkedList&lt;Integer&gt; mid = new LinkedList&lt;&gt;();            for(int i=treeQueue.size(); i&gt;0; i--) &#123;                TreeNode midNode = treeQueue.peek();                if(midNode.left != null) treeQueue.add(midNode.left);                if(midNode.right != null) treeQueue.add(midNode.right);                if(ans.size()%2 == 0) mid.addLast(treeQueue.poll().val);                else mid.addFirst(treeQueue.poll().val);            &#125;            ans.add(mid);        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第五天</title>
      <link href="/2023/03/25/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%BA%94%E5%A4%A9_%E6%95%B0%E7%BB%84/"/>
      <url>/2023/03/25/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%BA%94%E5%A4%A9_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例：</strong></p><pre><code class="java">现有数组：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><p><strong>限制：</strong></p><p>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; m &lt;&#x3D; 1000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在遍历数组时，需要注意遍历顺序和要求，如本题而言，如果总左上角开始遍历，你会发现其左侧和下侧都是大于本数，是一种暴力遍历</p><p>但是如果从右上角开始遍历，你会发现其左侧是小于自己的数，下面是大于自己的数，这就将数组划为了两个部分，取满足条件的一端能更快的搜到数据</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;            return false;        &#125;        int rows = matrix.length, columns = matrix[0].length;        int row = 0, column = columns - 1;        while (row &lt; rows &amp;&amp; column &gt;= 0) &#123;            int num = matrix[row][column];            if (num == target) &#123;                return true;            &#125; else if (num &gt; target) &#123;                column--;            &#125; else &#123;                row++;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p><strong>示例：</strong></p><pre><code class="java">输入：numbers = [3,4,5,1,2]输出：1输入：numbers = [2,2,2,0,1]输出：0</code></pre><p><strong>提示：</strong></p><p>n &#x3D;&#x3D; numbers.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5000<br>-5000 &lt;&#x3D; numbers[i] &lt;&#x3D; 5000<br>numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分 + 斜率判断</p><p>因为进行了1 - n次旋转，所以在数组中间（而非两端）一定存在一个“断点”，以这个断点作为二分查找的要素查找即可</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int minArray(int[] numbers) &#123;        //对于数组最右侧的数字a来说，最小值右侧数据一定小于a，最小值左侧数据一定大于a        //1.利用双指针指向首尾，并依次取出中间值与尾数值比较        //2.中间值大于尾数值：最小值位于中间值右侧，首指针指向中间值        //3.中间值小于尾指针，最小值位于中间值左侧, 尾指针指向中间值        //4.中间值等于尾指针，不可确定，将尾指针前移一位再做判断        if(numbers.length == 1) return numbers[0];        int first = 0, last = numbers.length-1;        while(last &gt; first) &#123;            int mid = first + (last - first)/2;            if(numbers[last]&gt;numbers[mid]) &#123;                last = mid;            &#125;else if(numbers[last]&lt;numbers[mid]) &#123;                first = mid+1;            &#125;else &#123;                last--;            &#125;        &#125;        return numbers[first];    &#125;&#125;</code></pre><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">第一个只出现一次的字符</a></p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例：</strong></p><pre><code class="java">输入：s = &quot;abaccdeff&quot;输出：&#39;b&#39;输入：s = &quot;&quot; 输出：&#39; &#39;</code></pre><p><strong>限制：</strong></p><ul><li>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目比较死板，总字符也就26个，暴力算了</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public char firstUniqChar(String s) &#123;        // ---- 方法一 ----        int[] fin = new int[26];        char[] strs = s.toCharArray();        if(strs.length == 0) return &#39; &#39;;        for(char i : strs)fin[i - &#39;a&#39;]++;        for(char i : strs)&#123;            if(fin[i-&#39;a&#39;]==1)return i;        &#125;        return &#39; &#39;;        // ---- 方法二 ----        // char[] strs = s.toCharArray();        // int[] flag = new int[strs.length];        // if(strs.length == 0) return &#39; &#39;;        // char thisIs = strs[0];        // for(int i = 0; i&lt;strs.length; i++)&#123;        //     if(flag[i] == 1)continue;        //     for(int j=i+1; j&lt;strs.length; j++)&#123;        //         if(strs[i] == strs[j])&#123;        //             flag[i] = 1;        //             flag[j] = 1;        //         &#125;        //     &#125;        // &#125;        // for(int i=0; i&lt;flag.length; i++)&#123;        //     if(flag[i]==0)return strs[i];        // &#125;        // return &#39; &#39;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第四天</title>
      <link href="/2023/03/24/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%9B%9B%E5%A4%A9_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/03/24/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E5%9B%9B%E5%A4%A9_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="从数组中重复的数字"><a href="#从数组中重复的数字" class="headerlink" title="从数组中重复的数字"></a>从数组中重复的数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例：</strong></p><pre><code class="java">输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 </code></pre><p><strong>提示：</strong></p><p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 方法一：已知总数组长度和数范围，直接创建对应大小的空数组，遍历总数组，增加空数组中对应位值，判断值是否到2，到2返回（简单，空数组浪费空间）</p><p>方法二：遍历总数组，利用HashSet存储以及查看过的数据，在每次遍历时查看HashSet是否已经存储，已存储就返回</p><p>方法三：遍历数组，将nums[n] 的位置放入 n 值，如果已经放过了却还需要放（重复）就返回该值。（时间复杂：O( N ), 空间复杂：O( 1 ) ）</p><p>方法三思路：数组长度为n，数字范围为1-n，因为存在重复项，所以数组与数字是存在一对多的关系。对于一个nums[ i ]，只有两种可能：nums[ i ] &#x3D; i ，即他的值就是当前位置的数组偏移量（数组下标），又或者不是；前者我们不做改动，后者我们交换它与 nums[ nums[ i ] ] 位置的值，使得 nums[ nums[ i ] ]成为前者，再判断当前位置，直到成为前者，继续遍历或者发现同一个位置又两个 i ，返回 i ，比如：在数组中有两个3时，nums[ 3 ]的位置会需要填入两个3，我们在第一次发现3的时候会将其填入，再次发现3的时候，对比已经知道了nums[ 3 ] &#x3D; 3，所以3重复，返回3</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int findRepeatNumber(int[] nums) &#123;        int i=0;        while(i &lt; nums.length) &#123;            // 位置值本就正确            if(nums[i] == i) &#123;                i++;                continue;            &#125;else &#123;                // 要交换的位置已经是正确的了，发现重复                if(nums[i] == nums[nums[i]]) &#123;                    return nums[i];                &#125;                // 将nums[ nums[i] ]转为正确对应，i没有++，继续判断该位置                swap(nums, i, nums[i]);            &#125;        &#125;        return -1;    &#125;        // 注：这个是交换方法，用于交换nums中a,b位置的值，因为是引用传递所以不用返回    // 更加注意：这个方法只能用于你确定nums中你要交换的部分一定不存在相同的值，毕竟a^a=0,a^0=a    public void swap(int[] nums, int a, int b)&#123;        nums[a] = nums[a]^nums[b];        nums[b] = nums[a]^nums[b];        nums[a] = nums[a]^nums[b];    &#125;&#125;/**O(n) O(n)方法一：数组存储存储        int[] fin = new int[nums.length];        for(int i =0; i&lt; nums.length; i++) &#123;            fin[nums[i]]++;            if(fin[nums[i]]&gt;1) return nums[i];        &#125;        return -1;        O(n) O(n)方法二：HashSet存储        HashSet&lt;Integer&gt; sets = new HashSet&lt;&gt;();        for(int i =0; i&lt; nums.length; i++) &#123;            if(sets.contains(nums[i])) return nums[i];            sets.put(nums[i]);        &#125;        return -1; */</code></pre><h2 id="查找：二分查找"><a href="#查找：二分查找" class="headerlink" title="查找：二分查找"></a>查找：二分查找</h2><p>在分析下面两题前，先复习一下 <strong>二分查找</strong> 以及其边界问题吧</p><p>首先，什么时候能用上二分：数组满足某种要求，你能<strong>确定存在一条线将数组划分为两个部分</strong>，一个满足要求，一个不满足</p><p>最常见的就是在排序数组中找到某个边界</p><pre><code class="java">// 在nums中找到target的位置public static int bs(int[] nums , int target) &#123;    int l = 0, r = nums.length-1;    while(l&lt;=r) &#123;        // 取中间值        int mid = l+(r-l)&gt;&gt;1;        // 中间值大，取左边        if(nums[mid] &gt; target) &#123;            r = mid - 1;           // 中间值小，取右边        &#125;else if(nums[mid] &lt; target) &#123;            l = mid + 1;        // 正好，取了        &#125;else &#123;            return mid;        &#125;       &#125;    // 没有对应target的值    return -1;&#125;</code></pre><p>这个二分有什么问题？<strong>target的值需要唯一</strong>，试想一个[ 1,2,3,3,3,4,5 ]，我们希望找出大于等于3的位置，就不能如上述来写二分</p><p>如上面的小例子，当我们需要了解对某个范围的第一个&#x2F;最后一个的位置问题，首先要明白二分中左右边界，即 l 和 r 的作用。</p><p>对于一段符合要求的数组，现在可以<strong>被两条线分为三个部分</strong>：【小于target的部分 <strong>1</strong> | <strong>2</strong> 等于target的部分 <strong>3</strong> | <strong>4</strong> 大于target的部分】</p><p>你可能注意到我标上的四个数字了，其中，<strong>1和3代表的就是最后一个的位置问题（1 最后一个小于target的数，3 最后一个小于等于target的数），2和4代表的是第一个位置问题（2 第一个大于等于target的数， 4 第一个大于target的数）</strong></p><h3 id="第一个大于-x2F-大于等于target的值的位置问题"><a href="#第一个大于-x2F-大于等于target的值的位置问题" class="headerlink" title="第一个大于&#x2F;大于等于target的值的位置问题"></a>第一个大于&#x2F;大于等于target的值的位置问题</h3><pre><code class="java">// 在nums中找到第一个大于target的位置public static int bs(int[] nums , int target) &#123;    int l = 0, r = nums.length-1;    while(l&lt;=r) &#123;        int mid = l+(r-l)&gt;&gt;1;        // 注意，此处的 = 判断，加上了=就是将target当作右边界，也就是在上述的1 2中做判断        if(nums[mid] &gt;= target) &#123;            r = mid - 1;        &#125;else &#123;            l = mid + 1;        &#125;    &#125;    // 试想一下 l 的变化，每次都取mid中间值+1的位置，mid作为中间值，mid+1自然是第一个大于mid的位置    return l;&#125;</code></pre><h3 id="最后一个小于-x2F-小于等于target的值的位置问题"><a href="#最后一个小于-x2F-小于等于target的值的位置问题" class="headerlink" title="最后一个小于&#x2F;小于等于target的值的位置问题"></a>最后一个小于&#x2F;小于等于target的值的位置问题</h3><pre><code class="java">// 在nums中找到第一个小于等于target的位置public static int bs(int[] nums , int target) &#123;    int l = 0, r = nums.length-1;    while(l&lt;=r) &#123;        int mid = l+(r-l)&gt;&gt;1;        // 注意，对比上面的代码，这里没加= ，就是将target当作左边界，也就是在上述的3 4中做判断        if(nums[mid] &gt; target) &#123;            r = mid - 1;        &#125;else &#123;            l = mid + 1;        &#125;    &#125;    // 试想一下 r 的变化，每次都取mid中间值-1的位置，mid作为中间值，mid-1自然是最后一个小于mid的位置    return r;&#125;</code></pre><p>当然，上述证明还是口述化了一点，不过大家可以实际结合题目试试</p><p>综上，简单来说，l 用于判断 <strong>第一个</strong> 符合条件的位置，r 用于判断 <strong>最后一个</strong> 符合条件的位置，判断中的 <strong>&#x3D;</strong> 判断target作为左边界还是右边界（前提是target存在） </p><h2 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字 I</a></p><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例：</strong></p><pre><code class="java">输入: nums = [5,7,7,8,8,10], target = 8输出: 2输入: nums = [5,7,7,8,8,10], target = 6输出: 0</code></pre><p><strong>提示：</strong></p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>找到最后一个小于等于target的值，找到第一个大于target的值，两者取差-1</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;       // 非递减数组，找到最后一个小于等于target的值，找到第一个大于target的值，差值-1即可       // 二分查找       int i, j;       for(i=0,j=nums.length-1; i&lt;=j; ) &#123;           int mid = i+(j-i)&gt;&gt;1;           if(nums[mid] &gt; target) &#123;               j = mid-1;           &#125;else &#123;               i = mid+1;           &#125;       &#125;       int lastSmo = i;        for(i=0,j=nums.length-1; i&lt;=j; ) &#123;           int mid = i+(j-i)&gt;&gt;1;            System.out.println(mid);           if(nums[mid] &gt;= target) &#123;               j = mid-1;           &#125;else &#123;               i = mid+1;           &#125;       &#125;       int FirsBig = j;       return lastSmo - FirsBig - 1;    &#125;&#125;</code></pre><h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字</a></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例：</strong></p><pre><code class="java">输入: [0,1,3]输出: 2输入: [0,1,2,3,4,5,6,7,9]输出: 8</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>找到第一个nums[i] &gt; i 的位置</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public int missingNumber(int[] nums) &#123;        if(nums[0] &gt; 0) return 0;        int i=0, j=nums.length-1;        for(;i&lt;=j;) &#123;            int mid = i+(j-i)&gt;&gt;1;            if(nums[mid] &gt; mid) &#123;                j = mid-1;            &#125;else &#123;                i = mid+1;            &#125;        &#125;        return i;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第三天</title>
      <link href="/2023/03/23/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%89%E5%A4%A9_%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/03/23/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%89%E5%A4%A9_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">替换空格</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例：</strong></p><pre><code class="txt">输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将字符对象转变为char[]类型对象，再遍历替换目标子字符串</p><p>最后组合成StringBuilder类型返回toString</p><p>不过，有现成方法就不用再重复造轮子了，理解万岁</p><pre><code class="java">// String中的replace方法public String replace(char oldChar, char newChar) &#123;    // 替换前后字符串一致就不用转换了    if (oldChar != newChar) &#123;        // 判断对象是否是拉丁文（就是好不好转码）调用不同编码的实现方式做转换        String ret = isLatin1() ? StringLatin1.replace(value, oldChar, newChar)                                : StringUTF16.replace(value, oldChar, newChar);        if (ret != null) &#123;            return ret;        &#125;    &#125;    return this;&#125;    // 这里以StringLatin1的replace作为例子分析/*    String.value属性:  private final byte[] value;  The value is used for character storage.*/  // 参数分别是String的值，需要被替换的值和要用于替换的值  public static String replace(byte[] value, char oldChar, char newChar) &#123;        // 判断能不能编码        if (canEncode(oldChar)) &#123;            int len = value.length;            int i = -1;            // 用于后续判断是否需要进行替换，如果需要替换就找到第一个需要替换的点位            while (++i &lt; len) &#123;                if (value[i] == (byte)oldChar) &#123;                    break;                &#125;            &#125;            // 如果i不小于len 就是字符中没有要被替换的子字符串            if (i &lt; len) &#123;                // 用于替换的字符可以正常编码                if (canEncode(newChar)) &#123;                    byte[] buf = StringConcatHelper.newArray(len);                    for (int j = 0; j &lt; i; j++) &#123;    // TBD arraycopy?                        buf[j] = value[j];                    &#125;                    // 替换实现                    while (i &lt; len) &#123;                        byte c = value[i];                        buf[i] = (c == (byte)oldChar) ? (byte)newChar : c;                        i++;                    &#125;                    return new String(buf, LATIN1);                &#125; else &#123;                // 用于替换的字符不能正常编码                    byte[] buf = StringUTF16.newBytesFor(len);                    // inflate from latin1 to UTF16                    inflate(value, 0, buf, 0, i);                    // 替换实现                    while (i &lt; len) &#123;                        char c = (char)(value[i] &amp; 0xff);                        StringUTF16.putChar(buf, i, (c == oldChar) ? newChar : c);                        i++;                    &#125;                    return new String(buf, UTF16);                &#125;            &#125;            // 没有要被替换的子字符，不用做处理        &#125;        // 不能编码都是假的，做不了处理        return null; // for string to return this;    &#125;</code></pre><p>做了操作的部分就是String判断是否可编码，常数级复杂度</p><p>Latin1中是否需要替换，O(n)复杂度遍历 + 常熟复杂度判断</p><p>遍历替换：O(n)复杂度</p><p>以上操作是串行，所以总的来说时间复杂度还是O(n)</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        return s.replace(&quot; &quot;,&quot;%20&quot;);    &#125;&#125;</code></pre><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><strong>Easy</strong>原题：<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/"> 左旋转字符串</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例：</strong></p><pre><code class="java">输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot;    输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot;</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>有轮子+1，不过还是读读原码</p><pre><code class="java">// String中的subStirng方法// 殊途同归public String substring(int beginIndex) &#123;    return substring(beginIndex, length());&#125;public String substring(int beginIndex, int endIndex) &#123;    int length = length();    checkBoundsBeginEnd(beginIndex, endIndex, length);    int subLen = endIndex - beginIndex;    // 从头返回到尾:不变    if (beginIndex == 0 &amp;&amp; endIndex == length) &#123;        return this;    &#125;    // 符合裁剪要求，判断是否可以编码    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)                      : StringUTF16.newString(value, beginIndex, subLen);&#125;// 这里以StringLatin1的newString作为例子分析// 额，拼接public static String newString(byte[] val, int index, int len) &#123;    return new String(Arrays.copyOfRange(val, index, index + len),                      LATIN1);&#125;</code></pre><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class Solution &#123;    public String reverseLeftWords(String s, int n) &#123;        return s.substring(n)+s.substring(0, n);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第二天</title>
      <link href="/2023/03/22/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%BA%8C%E5%A4%A9_%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/22/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%BA%8C%E5%A4%A9_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><p><strong>示例：</strong></p><pre><code class="java">输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>提示：</strong></p><p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 从尾到头输出，也就是遍历，时间复杂度最小为O(n)，那么空间复杂度越小越好</p><p>首先想到的是反转链表，空间复杂度为O(1)，时间复杂度O(n)</p><p>反转列表需要三个Node变量，记录上一个节点方便向前连接，记录当前节点用于改变next、指向第一个节点代表的前节点、记录原本的后续节点</p><p>先记录下一个节点的信息，再将next指向前节点，以此类推，反转链表</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        if(head == null) return new int[0];        ListNode a1 = head;        ListNode a2 = head.next;        ListNode a3 = head;        int s1 = 1;        while(a2!=null)&#123;            a3 = a2.next;            a2.next = a1;            a1 = a2;            a2 = a3;            s1++;        &#125;        int[] arr = new int[s1];        for(int i=0; i&lt;s1; i++)&#123;            arr[i] = a1.val;            a1 = a1.next;        &#125;        return arr;    &#125;&#125;</code></pre><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><strong>Easy</strong>原题连接：<a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例：</strong></p><pre><code class="java">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>提示：</strong></p><p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>同第一题思路</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        //处理边界条件        if(head == null || head.next == null) return head;        //记录后续指针和        ListNode n1 = head, n2 = head, n3 = null;        while(n1 != null)&#123;            n1 = n2.next;            n2.next = n3;            n3 = n2;            n2 = n1;        &#125;        return n3;    &#125;&#125;</code></pre><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>medium</strong>原题连接：<a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p><strong>示例：</strong></p><pre><code class="java">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]    输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]    输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。</code></pre><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个问题同样涉及遍历列表，所以时间复杂度最低为O(n)，那么空间复杂度越低越好，而空间适用问题在于存储链表节点信息</p><p>可以考虑适用HashMap&lt;Node, Node&gt;存储原值和复制值，再依次get传递random连接</p><p>又或者直接复制节点在源节点后，遍历三次：</p><p>第一次创建复制节点并后接：1 - 1copy - 2 - 2copy - 3 - 3copy-…（复制当前节点以存储后继节点，当前节点指向复制节点，节点调制复制节点的后继节点）</p><p>第二次连接对应的random链接（复制节点获得当前节点的random所指的节点的后继节点，即复制节点指向复制random）</p><p>第三次拆开链表：1 - 2 - 3 - ..     1copy - 2copy - 3copy - ..（每个节点都指向后继的后继）</p><h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">/*// Definition for a Node.class Node &#123;    int val;    Node next;    Node random;    public Node(int val) &#123;        this.val = val;        this.next = null;        this.random = null;    &#125;&#125;*/class Solution &#123;    public Node copyRandomList(Node head) &#123;        // 判空        if(head == null) return head;        // 1. 复制链表在原节点后: 1-1`-2-2`-3-3-...        Node mid, copy;        for(mid = head; mid != null; mid = copy.next) &#123;            copy = new Node(mid.val);            copy.next = mid.next;            mid.next = copy;        &#125;        // 2. 复制节点的random连接        for(mid = head; mid != null; mid = mid.next.next) &#123;            copy = mid.next;            if(mid.random != null) &#123;                copy.random = mid.random.next;            &#125;        &#125;        // 3. 分离链表: 1-2-3-..  1`-2`-3`-..        Node copyList = head.next;        for(mid = head; mid.next != null;) &#123;            copy = mid.next;            mid.next = copy.next;            mid = copy;        &#125;        return copyList;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode剑指Offer第一天</title>
      <link href="/2023/03/21/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%80%E5%A4%A9_%E6%A0%88/"/>
      <url>/2023/03/21/leetCode/%E5%89%91%E6%8C%87Offer/%E7%AC%AC%E4%B8%80%E5%A4%A9_%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p><strong>Esay</strong>原题连接：<a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例：</strong></p><pre><code class="txt">输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[],[]]输出：[null,null,3,-1,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li>最多会对<code>appendTail、deleteHead</code>进行<code> 10000</code> 次调用</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>栈的特点在于后进先出，那么一个作为主要栈，负责存储和正确输出数据，另一个作为添加数据时的辅助栈，将数据添入的顺序倒转</p><p>初始化时就新建两个栈对象</p><p>添加时直接添加至辅助栈，再输出至存储栈</p><p>删除时先看存储栈是否存在数据可以直接删除，可以则直接执行删除，因为顺序是正确的，否则判断辅助站是否存在数据，存在则输入至存储栈，再执行删除，若两个栈都为空则依题返回-1</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class CQueue &#123;    Stack&lt;Integer&gt; A,B;    public CQueue() &#123;        A = new Stack&lt;&gt;();        B = new Stack&lt;&gt;();    &#125;    public void appendTail(int value) &#123;        A.push(value);    &#125;    public int deleteHead() &#123;        if(!B.empty()) return B.pop();        if(A.empty()) return -1;        while(!A.empty()) B.push(A.pop());        return B.pop();    &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */</code></pre><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p><strong>Easy</strong>原题：<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例：</strong></p><pre><code class="java">MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.</code></pre><p><strong>提示：</strong></p><ol><li>各函数的调用总次数不超过 20000 次</li></ol><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于栈而言，因为是固定尾进头出，所以pop和push的复杂度本来就是O(1) 时间复杂度，而min实现则需要遍历栈，是O(n)时间复杂度</p><p>最小值会在插入时判断是否更新，在删除时判断是否改变</p><p>因为是栈的最小值查询，而栈的添加和删除顺序是确定的，所以最小值的变化一定是确定的</p><p>利用一个辅助栈来存储每添加一个数据后的最小值，当加入的数据和当前最小值一致或更小时，添加入辅助栈，否则不变</p><p>当删除的数据和辅助栈值一致时，删除原数据同时删除辅助栈</p><p>显示min就直接输出辅助栈的栈尾，表示到目前位置的最小值</p><p>你可以理解为：辅助栈是一个，以存储栈第一个值为基础，此后每一个值都不严格小于（小于等于）前一个值的递减数组，删除存储栈数据时，较大的数和这个递减数组没关系，那么最小值不会受到影响，辅助栈不变；相反则会连着辅助栈栈尾巴一起删，因为存储时是按顺序存储的小值就会同时存入辅助栈</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code class="java">class MinStack &#123;    Stack&lt;Integer&gt; nor, fMin;    /** initialize your data structure here. */    public MinStack() &#123;        nor = new Stack&lt;Integer&gt;();        fMin = new Stack&lt;Integer&gt;();    &#125;        public void push(int x) &#123;        if(fMin.empty() || fMin.peek() &gt;= x) &#123;            fMin.push(x);        &#125;        nor.push(x);    &#125;        public void pop() &#123;        if(fMin.peek().equals(nor.peek())) &#123;            fMin.pop();        &#125;        nor.pop();    &#125;        public int top() &#123;        return nor.peek();    &#125;        public int min() &#123;        return fMin.peek();    &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题3</title>
      <link href="/2023/03/16/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%983/"/>
      <url>/2023/03/16/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-6-0-之后为何引入了多线程？6-0-之前为什么不使用多线程？"><a href="#Redis-6-0-之后为何引入了多线程？6-0-之前为什么不使用多线程？" class="headerlink" title="Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使用多线程？"></a>Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使用多线程？</h2><p>在Redis 6.0 之前，Redis 是单线程的，这是因为Redis 的主要瓶颈是在 CPU 上。但是随着硬件的发展，现代服务器的CPU 核心数已经达到了几十个， 这就导致Redis 单线程模型无法充分利用多核处理器的性能。因此，Redis 6.0 引入了多线程，以提高 Redis 在多核处理器上的性能</p><p>Redis 6.0 之前为什么不使用多线程，主要有以下几个原因：</p><ol><li>Redis 单线程模型相对简单，容易维护和调试，代码逻辑也比较清晰</li><li>Redis 的主要瓶颈在于CPU，而不是I&#x2F;O ，因此采用多线程模型并不能显著提高性能</li><li>Redis 是一个内存型数据库，它的性能主要受到CPU 和内存带宽的限制。采用多线程模型会增加线程之间的竞争和锁等开销，反而可能降低Redis 的性能</li></ol><p>但是随着硬件的发展，多核处理器已经成为了现代服务器的标配，因此Redis 引入多线程的举措可以更好的发挥硬件性能，提高Redis 的吞吐量和响应速度</p><h2 id="HTTP-协议中-GET-和-POST-有什么区别？分别适用于什么场景？"><a href="#HTTP-协议中-GET-和-POST-有什么区别？分别适用于什么场景？" class="headerlink" title="HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？"></a>HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？</h2><p>HTTP 协议中GET 和 POST 是两种常用的请求方法，它们的区别如下：</p><ol><li>参数传递方式不同：GET 请求参数是在URL中以键值对的形式传递的，例如：<a href="http://www.example.com/?key1=value1&amp;key2=value2">http://www.example.com/?key1=value1&amp;key2=value2</a> 而POST 请求参数是在请求体中以键值对的形式传递的</li><li>参数传递大小不同：GET 请求参数有大小限制，因为URL 长度有限制，不同的浏览器和服务对象对URL 长度的限制不同，一般为 2048 个字符。而POST 请求参数没有大小限制，因为它们是以请求体的形式传递的</li><li>安全性不同：GET 请求是明文传输的，因为参数在URL中，如果涉及敏感信息（如密码），容易被窃取或暴露在浏览器历史记录、代理服务器日志等地方。而POST 请求的参数在请求体中传输，相对安全一些，但是也需要注意参数加密和防止CSRF攻击等问题。</li></ol><p>GET 和 POST 适用场景不同等问题：</p><ol><li>GET 请求适用于获取数据，如浏览网页，搜索等。因为GET 请求参数以明文形式传输，容易被拦截和篡改，所以不适用于提交铭感信息</li><li>POST 请求适用于提交数据，如登录，注册，发布内容等。因为POST 请求参数在请求体中传输，相对安全一些，可以提交敏感信息，但是需要注意参数加密和防止CSRF 攻击等问题。</li></ol><h2 id="什么是零拷贝？说一说你对零拷贝的理解？"><a href="#什么是零拷贝？说一说你对零拷贝的理解？" class="headerlink" title="什么是零拷贝？说一说你对零拷贝的理解？"></a>什么是零拷贝？说一说你对零拷贝的理解？</h2><p>零拷贝（Zero-Copy）是一种高效的数据传输技术，它可以将数据从内核空间直接传出到应用程序的内存空间中，避免不了必要的数据拷贝，从而提高了数据传输的效率和性能。</p><p>在传统的数据传输方式中，当应用程序需要从磁盘，网络等外部设备中读取数据时，操作系统需要先将数据从外部设备拷贝到内核空间的缓冲区，然后再将数据从内核空间拷贝到应用程序的内存空间中，这个过程中需要进行两次数据拷贝，浪费了大量的CPU 时间和内存带宽。</p><p>而使用零拷贝技术，数据可以直接从外部设备复制到应用程序的内存空间中，避免了中间的内核空间缓冲区，减少了不必要的数据拷贝，提高了数据传输的效率和性能</p><p>在网络编程中，零拷贝技术可以用于大文件传输，网络文件系统的读写，数据库查询等场所中，提高数据传输的效率和响应速度。同时，零拷贝技术也可以减少系统内存的开销，提高系统的稳定性和可靠性</p><h2 id="什么是-RPC？目前有哪些常见的-RPC-框架？实现-RPC-框架的核心原理是什么？"><a href="#什么是-RPC？目前有哪些常见的-RPC-框架？实现-RPC-框架的核心原理是什么？" class="headerlink" title="什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？"></a>什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？</h2><p>RPC（Remote Procedure Call）是一种远程协议，允许一台计算机通过网络调用另一台计算机上的服务或方法。它可以让开发人员想本地方法一样调用远程方法，将网络通信细节封装起来，提高了分布式系统中各模块之间的耦合性。</p><p>目前常见的RPC框架有：</p><ol><li>Dubbo：阿里巴巴开源的分布式RPC框架，支持多种协议和负载均衡策略</li><li>gRPC：Google 开源的高性能RPC框架，支持多种语言</li><li>Thrift：Facebook 开源的跨语言 RPC 框架，支持多传输协议和数据编码解码方式</li><li>Spring Cloud Netfilx：Spring Cloud 的子项目之一，提供了基于Netfilex OSS 开源组件的微服务解决方案，包括服务发现，负载均衡，熔断器等功能。</li></ol><p>RPC 框架的核心原理是基于网络传输协议实现的远程方法调用。RPC 框架通常由服务提供者和服务消费者两部分组成，服务提供者将本地方法暴露成远程服务，服务消费者通过远程代理对象调用远程方法</p><p>在实现远程方法调用时，需要进行序列化和反序列化。序列化将对象转换为二进制数据流，以便于在网络中传输；反序列化则将收到的二进制数据流转换为对象</p><p>为了提高性能，一些RPC 框架使用了二进制协议，如Dubbo 使用的 Hessian 2 协议和gRPC使用的 Protocol Buffers协议，与基于文本的协议（如XML 和 JSON）相比，二进制协议具有更小的传输体积和更高的解析速度，能够减少网络传输的开销。</p><h2 id="设计模式可以分为哪几类？一共有多少种主流的设计模式？"><a href="#设计模式可以分为哪几类？一共有多少种主流的设计模式？" class="headerlink" title="设计模式可以分为哪几类？一共有多少种主流的设计模式？"></a>设计模式可以分为哪几类？一共有多少种主流的设计模式？</h2><p>设计模式可以分为三类：</p><ol><li>创建型模式：这类模式关注对象创建的机制，包括单例模式，工厂模式，抽象工厂模式，建造者模式和原型模式等</li><li>结构型模式：这类模式关注对象之间的组合关系，包括适配器模式，装饰器模式，代理模式，组合模式，桥接模式，外观模式和享元模式</li><li>行为型模式：这类模式关注对象之间的通信方式和协作方式，包括模板方法模式，策略模式，命令模式，职责链模式，状态模式，观察者模式，中介者模式和访问者模式</li><li>目前主流的设计模式有23种：</li></ol><p>单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，适配器模式，装饰模式，代理模式，外观模式，桥接模式，组合模式，享元模式，策略模式，模板方法模式，观察者模式，迭代器模式，职责链模式，命令模式，备忘录模式，状态模式，访问者模式，中介模式，解释器模式</p><h2 id="如何在-10-亿个数据中找到最大的-1-万个？（提示：最小堆）"><a href="#如何在-10-亿个数据中找到最大的-1-万个？（提示：最小堆）" class="headerlink" title="如何在 10 亿个数据中找到最大的 1 万个？（提示：最小堆）"></a>如何在 10 亿个数据中找到最大的 1 万个？（提示：最小堆）</h2><p>在 10亿个数据中找到最大的 1万个，可以使用最小堆（Min-Heap）算法实现。</p><p>最小堆是一种特殊的二叉树结构，每个节点的值都小于或等于其左右子节点的值。在使用最小堆来查找最大的1万个数据时，可以先创建一个大小为1万的最小堆，然后将10亿个数据逐个加入堆中。当堆的大小超过了1万时，将堆顶的元素（最小值弹出，再将当前元素加入堆中。当遍历完所有数据后，堆中剩余的1万个元素就是最大的1万个值）</p><p>这种方法的时间复杂度为 O(n log k)，其中 n 是数据总数，k 是要查找的元素数量。因为要维护一个大小为 1万的最小堆，所以空间的复杂度也为O( k ).</p><p>#java不一定好实现这种数据处理，可以试试python#</p><h2 id="讲一讲-Spring-框架中-Bean-的生命周期？"><a href="#讲一讲-Spring-框架中-Bean-的生命周期？" class="headerlink" title="讲一讲 Spring 框架中 Bean 的生命周期？"></a>讲一讲 Spring 框架中 Bean 的生命周期？</h2><p>在Spring 框架中，Bean 的生命周期包括以下几个阶段：</p><ol><li>实例化（Instantitaion）：在这个阶段，Spring 将根据配置文件或注解等方式创建Bean 实例，并将其存储在容器中</li><li>属性赋值（Populate Properties）：在这个阶段，Spring 将会自动将Bean 的属性值从配置文件或注解等方式注入到Bean 实例中</li><li>初始化（Initialization）：在这个阶段，Spring 会调用Bean 实例的init-method 方法，完成一些初始化的操作，例如建立数据库连接等。</li><li>使用（In Use）：在这个阶段，Bean 实例已经可以正常使用，供应用程序调用</li><li>销毁（Destruction）：在这个阶段，Spring 会调用 Bean 实例的 destory-method 方法，完成一些资源的释放和清理操作，例如关闭数据库连接等</li></ol><p>具体的实现方法可以通过实现 BeanPostProocessor 和 BeanFactoryProcessor 接口来进行扩展。其中，BeanPostProcessor 接口定义了两个方法</p><p>postProcessBeforeInitialization 和 postProcessAfterInitialization，分别在Bean 的初始化前后被调用，用于扩展Bean 初始化过程；BeanFactoryPostProcessor 接口则定义了一个方法 postProcessBeanFactory，用于在Bean 工程实例化 Bean 定义后对其进行修改。</p><p>总之，Spring 的 Bean 的生命周期通过上述阶段进行管理，开发者可以通过实现相关接口和方法来扩展和定制Bean 的创建和销毁过程，以满足各种业务需求。</p><h2 id="Redis-有哪些数据类型？基础数据结构有几种？你还知道哪些-Redis-的高级数据结构？"><a href="#Redis-有哪些数据类型？基础数据结构有几种？你还知道哪些-Redis-的高级数据结构？" class="headerlink" title="Redis 有哪些数据类型？基础数据结构有几种？你还知道哪些 Redis 的高级数据结构？"></a>Redis 有哪些数据类型？基础数据结构有几种？你还知道哪些 Redis 的高级数据结构？</h2><p>Redis 支持多种数据类型，不同的数据类型可以满足不同的需求。下面是Redis 中常用的数据类型：</p><ol><li>String（字符串）：Redis 中最基本的数据类型，可以存储任何形式的数据，例如整数，浮点数，二进制数据等</li><li>Hash（哈希）：Redis 中的一种键值对类型，可以存储多个键值对，每个键值对又是一个加键值结构</li><li>List（列表）：Redis 中的一个有序列表类型，可以存储多个元素，每个元素都有一个索引，支持多种列表操作，例如插入，删除，查找等。</li><li>Set（集合）：Redis 中的一种无序集合类型，可以存储多个元素，每个元素都是唯一的，支持多种集合操作：如交集，并集，差集等</li><li>Sorted Set（有序集合）：Redis 中的一种有序集合类型，可以存储多个元素，每个元素都有一个分值，支持根据分值进行排序和查询等操作。</li></ol><p>Redis 的基础数据结构有三种：字符串，列表和哈希，其他的数据类型都是基于这三种数据结构进行的扩展和衍生的。例如，Redis 的 Set 数据类型就是基于字符串实现的，除了基础数据结构之外，Redis 还提供了多种高级数据结构，例如：</p><ol><li>HyperLogLog：一种基数估计算法，用于估计一个数据集合的基数</li><li>GeoHash：一种地理位置编码算法，可以对地理位置信息进行编码和查询</li><li>Pub&#x2F;Sub：一种消息队列机制，可以实现消息的订阅和发布</li><li>Bitmaps：一种位图数据结构，可以进行高效的位运算，用于统计用户在线时长，网站访问量等</li><li>Lua脚本：Redis 中可以使用Lua 脚本进行扩展和定制，可以实现一些复杂的业务逻辑和算法。</li></ol><h2 id="有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？"><a href="#有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？" class="headerlink" title="有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？"></a>有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？</h2><ol><li>RabbitMQ 优点：可靠性高，性能优秀，支持多种协议，有完善的管理界面。缺点：部署和维护较为复杂。使用场景：使用高可靠性，高吞吐量，多协议，多语言的分布式系统场景。</li><li>Kafla 优点：性能优秀，可扩展性好，可靠性高，支持多种数据处理模式。缺点：管理界面不够完善，复杂度较高。适用场景：适用于高吞吐量，高并发，数据处理流程复杂的场景，例如大数据处理，实时日志处理等。</li><li>ActiveMQ 优点：功能齐全，易于使用，支持多种协议。缺点：性能相对较低，可靠性不如RabbitMQ。适用场景：需要适用多种协议，支持多种消息类型的场景，例如Web服务，企业应用集成等</li><li>RocketMQ 优点：性能优秀，可靠性高，支持海量数据存储和传输。缺点：社区相对较小，功能不够完善。适用场景：适用于海量数据存储和数据传输，例如电商，金融等领域</li><li>Redis 优点：速度极快，支持多种数据结构，支持事务操作，支持发布&#x2F;订阅模式。缺点：可靠性不如RabbtMQ 和 Kafka。适用场景：适用于对性能要求极高，需要使用多种数据结构和事务操作的场景，例如缓存，计数器，实时消息等。</li></ol><p>总的来说，选择适合自己的消息队列需要根据具体业务和场景进行综合评估和选择。</p><h2 id="Spring-支持哪几种事务管理类型，Spring-的事务实现方式和实现原理是？"><a href="#Spring-支持哪几种事务管理类型，Spring-的事务实现方式和实现原理是？" class="headerlink" title="Spring 支持哪几种事务管理类型，Spring 的事务实现方式和实现原理是？"></a>Spring 支持哪几种事务管理类型，Spring 的事务实现方式和实现原理是？</h2><p>Spring 支持的事务管理类型包括：</p><ol><li>编程式事务管理：在代码中显式地编写事务管理相关代码，如开启事务，提交事务，回滚事务等。</li><li>声明式事务管理：适用AOP技术，在代码中通过配置进行声明，从而实现对事务管理的控制</li><li>注解式事务管理：基于声明式事务管理，适用注解的方式进行事务的管理</li></ol><p>Spring 的事务管理实现方式采用了模板方式，通过模板模式实现了业务的封装。Spring 事务管理实现原理主要是通过AOP 和代理模式来实现的。在适用声明式事务管理时，Spring 通过拦截器和代理对象来实现对方法调用的拦截和控制。当方法被调用时，Spring 会在方法调用前开启一个新事务，如果方法执行成功，Spring 会提交事务，否则回滚事务。在使用注解式事务管理时，Spring 会扫描带有事务注解的方法，并在运行时使用动态代理为这些方法生成代理对象，在代理对象的方法调用前后进行事务管理的操作。</p><h2 id="Redis-为什么快？"><a href="#Redis-为什么快？" class="headerlink" title="Redis 为什么快？"></a>Redis 为什么快？</h2><p>Redis 之所以快，主要有以下几个方面的原因：</p><ol><li>内存存储：Redis 的数据都是存储在内存中的，相比于硬盘存储的数据库，内存存储速度更快</li><li>单线程模型：Redis 使用单线程模型处理所有的请求，避免了多线程之间的线程切换和竞争等开销，提高了处理请求的效率</li><li>非阻塞I&#x2F;O：Redis 使用非阻塞I&#x2F;O 处理网络通信，当一个客户端请求到来时，Redis 不会一致等待客户端的响应，而是会先处理其他请求，这样就避免了I&#x2F;O阻塞带来的性能问题</li><li>精简高效的数据结构：Redis 内置了多种高效的数据结构，如哈希表，跳表等，这些数据结构的实现非常精简高效，减少了Redis 对内存和CPU 的占用，从而提高了Redis 的性能</li><li>持久化策略：Redis 支持多种持久化策略，如RDB（快照）和AOF（追加式文件）等，这些策略可以将内存中的数据保存到硬盘中，以保证数据的持久性和安全性，同时，Redis 可以将数据以压缩的方式存储在硬盘中，减少了硬盘的占用，提高了数据的读写速度。</li></ol><p>综上所述，Redis之所以快，主要得益于其内存存储，单线程模型，非阻塞I&#x2F;O，高性能的数据结构和灵活的持久化策略等方面的设计与实现</p><h2 id="简述-TCP-三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手？"><a href="#简述-TCP-三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手？" class="headerlink" title="简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手？"></a>简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手？</h2><p>TCP 三次握手和四次挥手是TCP 协议中建立和终止连接的过程</p><p>三次握手流程如下：</p><ol><li>客户端向服务器发送SYN包，表示请求建立连接，此时客户端进入SYN_SENT状态</li><li>服务器接收到SYN包后，回应一个SYN-ACK包，表示同意建立连接，此时服务器进入SYN-RECEIVED 状态</li><li>客户端接收到SYN-ACK 包后，向服务器回应一个ACK 包，表示确认建立连接，此时客户端进入ESTABLISHED 状态。服务器收到ACK 包后也进入 ESTABLISHED 状态。</li></ol><p>四次挥手的流程如下：</p><ol><li>客户端向服务器发送FIN 包，表示希望关闭连接，此时客户端进入 FIN-WAIT-1 状态</li><li>服务器收到FIN 包后，向客户端回应一个ACK 包，表示已经收到了关闭请求，此时服务器进入 CLOSE-WAIT状态，客户端收到ACK 包后进入FIN-WAIT-2 状态</li><li>服务器关闭连接后，向客户端发送一个FIN 包，表示可以关闭连接，此时服务器进入LAST-ACK 状态</li><li>客户端收到服务器的FIN 包后，向服务器回应一个ACK 包，表示已经收到关闭请求，此时客户端进入 TIME-WAIT状态，等待2MSL（最大报文生存时间）后，关闭连接。服务器收到ACK 包后也进入CLOSED 状态</li></ol><p>三次握手是为了确保客户端和服务器都能够收到对方的请求和回应，防止因为网络原因导致请求或回应丢失而建立不了连接。四次挥手则是为了确保连接的正常关闭，防止应为网络原因导致连接无法关闭或出现连接断开后还能够收到数据的情况</p><h2 id="什么是-Spring-的依赖注入，依赖注入的基本原则以及好处？"><a href="#什么是-Spring-的依赖注入，依赖注入的基本原则以及好处？" class="headerlink" title="什么是 Spring 的依赖注入，依赖注入的基本原则以及好处？"></a>什么是 Spring 的依赖注入，依赖注入的基本原则以及好处？</h2><p>依赖注入（Dependency Injection，简称DI）是Spring框架中的一种设计模式，用于实现控制反转（Inversion of Control，简称IoC）。它是一种将对象之间的依赖关系从硬编码中解耦的方法。通过依赖注入，Spring框架可以在运行时自动为类的属性，构造函数或方法参数提供所需的依赖对象，从而实现对象之间的松耦合</p><p>依赖注入的基本原则：</p><ol><li>高层模块不应该依赖底层模块。它们都应该依赖抽象</li><li>抽象不应该依赖具体实现，具体实现应该依赖抽象</li></ol><p>依赖注入的好处：</p><ol><li>解耦：依赖注入降低了组件之间的耦合度，使得组件可以独立的进行开发，测试和维护。通过将组件的创建和管理交给IoC容器，组件之间的依赖关系变得更加清晰，有助于提高代码的可维护性</li><li>提高代码的可测试性：依赖注入使得对组件进行单元测试变得更加容易。通过使用依赖注入，我们可以轻松的为组件提供模拟（Mock）的依赖对象，从而实现组件在隔离环境中的测试</li><li>更好的代码重用：由于组件之间的依赖关系变得更加清晰，这有助于提高代码的可重用性。组件可以在不同的上下文重用，而无需对其进行修改。</li><li>更简洁的代码：依赖注入使得代码更加简洁，因为组件不需要直接处理依赖对象的创建和管理。这使得开发人员可以更加专注于组件的核心功能，从而提高开发效率</li><li>更容易进行配置管理：依赖注入允许我们将组件的配置与实现代码分离，从而使得配置管理变得更加容易。通过使用外部组件或注解，我们可以在不修改代码的情况下，调整组件之间的依赖关系。</li></ol><h2 id="什么是注册中心？如何实现一个注册中心？"><a href="#什么是注册中心？如何实现一个注册中心？" class="headerlink" title="什么是注册中心？如何实现一个注册中心？"></a>什么是注册中心？如何实现一个注册中心？</h2><p>注册中心（Service Registry）是微服务架构中的一个关键组件，负责管理服务实例的信息，包括服务实例的地址，端口，元数据等。它允许服务实例在启动时注册自己，并在关闭时注销。服务消费者可以通过查询注册中心来发现可用的服务提供者，并根据负载均衡策略选择合适的服务实例进行调用</p><p>实现一个注册中心需要以下几个关键功能：</p><ol><li>服务注册：允许服务实例在启动时将自己的信息注册到注册中心，包括地址，端口，元数据等</li><li>服务注销：允许服务实例在关闭时从注册中心注销自己</li><li>服务发现：允许服务消费者查询可用的服务实例列表，以便找到合适的服务实例进行调用</li><li>健康检查：注册中心需要定期检查已经注册的服务实例的健康状态，以确保服务实例列表的准确性。如果发现某个服务实例不再可用，注册中心应将其从列表中移除。</li></ol><p>实现一个简单的注册中心可用参考以下步骤：</p><ol><li>选择一个合适的数据结构（例如哈希表）存储服务实例的信息</li><li>实现一个HTTP API，允许服务实例在启动时向注册中心发送注册请求，将自己的信息添加到数据结构中</li><li>实现一个HTTP API，允许服务实例在关闭时向注册中心发送注销请求，将自己的信息从数据结构中移除</li><li>实现一个HTTP API，与匈奴服务消费者查询可用的服务实例列表</li><li>实现一个定时人物，定期检查已注册的服务实例的健康状况，如果发现某个服务实例不再可用，将其从数据结构中移除</li></ol><p>然而，实现一个可靠，高性能，可扩展的注册中心是一个复杂的任务。在实际应用中，通常推荐使用现有的成熟的注册中心组件，例如Eureka，Consul，Zookeeper等。这些注册中心提供了丰富的功能，包括高可用性，数据持久化，动态配置等。</p><h2 id="什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？"><a href="#什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？" class="headerlink" title="什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？"></a>什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？</h2><p>工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种封装对象创建过程的方法。工厂模式将对象的创建和使用分离，让一个专门的工厂类负责创建对象实例，而不是在代码中直接使用new操作符。这有助于降低代码的耦合度，提高可维护性和可扩展性</p><p>使用工厂模式的好处：</p><ol><li>降低耦合度：工厂模式将对象的创建与使用分离，使得客户端代码不直接依赖具体的类，降低了耦合度</li><li>提高可扩展性：当需要添加或修改产品类时，只需要修改工厂类，而不需要修改客户端代码，提高了系统的可扩展性</li><li>提高可维护性：通过集中管理对象的创建，提高了代码的可维护性</li><li>提高代码的复用性：工厂类可用被多个客户端代码复用，减少了重复代码</li></ol><p>工厂模式可用分为以下几类：</p><ol><li>简单工厂模式（Simple Factory Patten）：一个工厂类根据传入参数决定创建哪个具体产品类的实例。简单工厂模式适用于产品种类较少且不易变化的场景。应用场景：例如：一个简单的图形绘制工具，可用根据传入的参数创建不同类型的图形（如圆形，矩形等）</li><li>工厂方法模型（Factory Method Patten）：定义一个接口或抽象类来创建对象，将实际创建对象的工作推迟到子类中。工厂方法模式适用于产品种类较多且可能增加的场景。应用场景：例如：一个日志记录器，一颗根据不同的需求哦i（例如文件日志，数据库日志）使用不同的工厂子类创建相应的日志记录器实例</li><li>抽象工厂模式（Abstract Factory Patten）：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。抽象工厂模式适用于产品族的场景。应用场景：例如：跨平台UI框架，可以为不同平台（如Windows，maxOS等）提供不同的UI控件实现，通过抽象工厂来创建对应平台的一系列UI控件</li></ol><p>各种工厂模式的应用场景取决于实际需求，需要更具具体问题来选择合适的工厂模式</p><h2 id="什么是-AOP？Spring-AOP-和-AspectJ-AOP-有什么区别？有哪些实现-AOP-的方式？"><a href="#什么是-AOP？Spring-AOP-和-AspectJ-AOP-有什么区别？有哪些实现-AOP-的方式？" class="headerlink" title="什么是 AOP？Spring AOP 和 AspectJ AOP 有什么区别？有哪些实现 AOP 的方式？"></a>什么是 AOP？Spring AOP 和 AspectJ AOP 有什么区别？有哪些实现 AOP 的方式？</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它旨在解决软件开发中的横切关注点（cross-cutting concerns）问题横切关注点是那些分布于多个模块或对象的功能，例如日志记录，安全检查，事务管理等。AOP通过将横切关注点与业务逻辑分离，从而提高了代码的模块化程度，使得开发更加简洁，易于维护</p><p>Spring AOP 和 AspectJ AOP 是两种不同的AOP 实现</p><ol><li>Spring AOP：是Spring 框架中的AOP 实现，基于动态代理实现。Spring AOP主要用于解决Spring 容器中Bean的横切面关注点问题。由于它使用了动态代理，所以只支持方法级别的切面（即横切关注点只能织入方法的执行）。Spring AOP 的性能略逊于AspectJ，但对于大部分应用来说，性能影响不大</li><li>AspectJ AOP：是一个独立的，功能更强大的AOP实现，不仅支持方法级别的切面，还支持字段，构造器等其他切面。AspectJ 可以通过编译时织入（编译时修改字节码）或加载时织入（在类加载时修改字节码）的方式实现AOP。Spring 可以与AspectJ 结合使用，以提供更强大的AOP 功能。</li></ol><p>实现AOP 的方式主要有以下几种：</p><ol><li>动态代理：通过代理模式，为对象目标生成一个代理对象，然后在代理对象中实现横切关注点的织入。动态代理可以分为JDK 动态代理（基于接口）和 CGLIB 动态代理（基于类）</li><li>编译时织入：在编译阶段，通过修改字节码实现AOP，AspectJ 的编译时织入就是这种方式</li><li>类加载时织入：在类加载阶段，通过修改字节码实现AOP。AspectJ 的类加载时织入就是这种方式</li></ol><p>AOP 的实现方式取决于具体需求和技术选型。对于Spring 应用来说，通常可以使用Spring AOP 满足大部分需求，如果需要更强大的AOP 功能，可以考虑使用AspectJ</p><h2 id="什么是分布式的-BASE-理论，它与-CAP-理论有什么联系？"><a href="#什么是分布式的-BASE-理论，它与-CAP-理论有什么联系？" class="headerlink" title="什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？"></a>什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？</h2><p>BASE 理论是分布式系统中用于描述数据一致性的一个概念。它是一个缩写，分别代表：</p><ol><li>基本可用（Basic Availability）：分布式系统在出现故障时，依然能够保证系统的可用性，但可能会出现部分功能或性能降低的情况</li><li>软状态（Soft State）：由于分布式系统中各个节点的状态可能会有一定的延迟，系统允许在一定时间内存在数据不一致的情况</li><li>最终一致性（Eventual Consistency）：在一段时间内，分布式系统中的数据可能不一致，但最终会到达一致的状态。这个过程可能需要一定的时间</li></ol><p>CAP 理论是另一个关于分布式系统的理论，它指出在分布式系统中，不能同时满足以下三个属性：</p><ol><li>一致性（Consistency）：在分布式系统中的所有节点，在同一时刻具有相同的数据</li><li>请求性（Availability）：分布式系统在任何时候都能对外提供服务，响应用户请求</li><li>区分容错性（Partition Tolerance）：分布式系统在遇到网络区分（部分节点之间通信中断）的情况下仍然能够正常运行</li></ol><p>BASE 理论和CAP 理论之间的关系是：BASE理论实际上是对 CAP 理论的一种实践和解释。在CAP 理论中，由于无法同时满足三个属性，因此在实际的分布式系统设中，通常需要在一致性和可用性之间做出权衡。BASE理论就是这种权衡的一种体现，它强调基本的可用性，软状态和最终一致性，而不是追求强一致性。在很多场景中，采用BASE 理论能够带来更高的系统可用性和更好的性能表现</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>使用Redis实现分布式锁的基本思路是使用Redis 的原子操作来确保在多个客户端之间只有一个客户端可用成功获取锁。以下是使用Redis 实现分布式锁的步骤：</p><ol><li><p>获取锁：客户端尝试获取锁，可用使用Redis 的SET 命令结合 NX 和 EX 选项来实现。SET 命令用于设置一个键值对， NX 选项表示只有在键不存在时才设置，EX 选项表示一个过期时间（单位为秒）。</p><p>示例： SET lock_key unique_value NX EX 30。这个命令表示如果lock_key 不存在，就设置它的值为unique_value， 并设置30秒的过期时间。如果设置成功，表示获取锁成功；如果设置失败，表示锁已经被其他客户端持有，需要等待或重试</p></li><li><p>持有锁：在持有锁的客户端执行临界区代码。在此期间，其他客户端无法获取锁。</p></li><li><p>释放锁：在临界区代码执行完毕后，需要释放锁以供其他客户端使用。为例避免误解锁的情况（例如，由于执行时间过长导致锁过期，然后被其他客户端获取），在释放锁时需要检查锁的值是否与获取锁时设置的值相同。这可以通过Redis的EVAL 命令来实现，使用Lua 脚本进行原子性操作。</p><p>示例：EVAL “if redis.call(‘get’, key[1])&#x3D;&#x3D; ARGV[1] then return redis.call(‘del’, key[1]) else return 0 and 1 lock_key unique_value “ 这个命令表示检查lock_key 的值是否为unique_value ，如果是，则删除lock_key 以释放锁；否则不执行任何操作</p></li></ol><p>通过以上步骤，可以实现一个基本的Redis 分布式锁。在实际应用中，还需要考虑一些其他因素，例如获取锁的重试策略，锁的续期等</p><h2 id="如何用-Redis-中的-HyperLogLog-统计页面-UV"><a href="#如何用-Redis-中的-HyperLogLog-统计页面-UV" class="headerlink" title="如何用 Redis 中的 HyperLogLog 统计页面 UV?"></a>如何用 Redis 中的 HyperLogLog 统计页面 UV?</h2><p>在Redis 中， HyperLogLog 是一种<strong>基数估算算法</strong>，可以用于快速计算一个集合中的不同元素数量的近似值。</p><p>在使用 HyperLogLog 统计页面 UV 时，我们可以将每个访问者的 IP 地址作为一个元素加到HyperLogLog中，然后通过计算HyperLogLog 中的元素数量的近似值来估计页面的唯一访问者数量</p><p>以下是一个示例代码，展示如何使用 Redis 的 HyperLogLog 实现页面 UV 统计：</p><pre><code class="java">import redis// 连接 Redis 服务器    r = redis.Redis(host=&#39;localhost&#39;, port=6379)// 记录访问者IP地址    ip_address = &#39;192.168.0.1&#39;// 将IP地址加入到HyperLogLog中    r.pfadd(&#39;page_views&#39;, ip_address)// 获取HyperLogLog 中元素数量的近似值    uv = r.pfcount(&#39;page_views&#39;)// 输出页面 UV        print(&#39;页面UV: &#39;, uv)</code></pre><p>在上面的示例代码中，我们使用Redis 的 pfadd() 方法将每个访问者的IP 地址加入到名为page_views 的HyperLogLog中。然后，我们使用pfcount() 方法获取page_views 中元素数量的近似值，并将其作为页面UV 的估计值输出到控制台<br>需要注意的是，由于HyperLogLog 是一种基数估算算法，其结果是一个近似值，并不是精确值。因此，在实际使用中，需要根据具体情况调整参数和精确等级，以获得更准确的结果</p><h2 id="有哪些常见的消息队列模型？分别适用于什么场景？"><a href="#有哪些常见的消息队列模型？分别适用于什么场景？" class="headerlink" title="有哪些常见的消息队列模型？分别适用于什么场景？"></a>有哪些常见的消息队列模型？分别适用于什么场景？</h2><p><strong>消息队列</strong>是一种在分布式系统中用于<strong>异步通信</strong>的模型，它允许不同的组件通过将消息发送到队列来实现解耦和灵活性。以下是常见的消息队列模型以及其适用场景：</p><ol><li><strong>点对点模型</strong>（Point-to-Point Model）：这种模型中，消息生产者将消息发送到一个队列中，消息消费者从该队列中接收消息，<strong>一个消息只会被一个消费者接收</strong>，消费者处理完消息之后会将其从队列中删除它。这种模型适用于<strong>需要保证消息只会被一个消费者处理</strong>的场景，例如<strong>订单系统，日志处理</strong></li><li><strong>发布-订阅模型</strong>（Publish-Subscribe Model）：这种模型中，消息生产者将消息发送到一个主题（Topic）中，多个消息消费者可以订阅这个主题并接收到所有的消息。<strong>每个消息可以被多个消费者接收，消费者在处理完消息之后不会从主题中删除它</strong>，这种模型适用于需要<strong>将消息广播给多个消费者</strong>的场景，例如<strong>新闻订阅，实时数据分析</strong>等</li><li><strong>请求-应答模型</strong>（Request-Response Model）：这种模型中，消息生产者发送一个请求到一个队列中，消息消费者从该队列中接收请求并返回一个响应消息。<strong>一个请求只会被一个消费者接收并处理，处理完成后返回响应消息给消息生产者</strong>。这种模型适用于需要<strong>请求-响应</strong>模式的场景，例如<strong>远程过程调用，微服务通信</strong>等。</li><li><strong>推拉模型</strong>（Push-Pull Model）：这种模型中，消息生产者将消息推送到一个队列中，消息消费者从该队列中拉取消息。<strong>消息生产者将消息发送到队列中，消费者按需从队列中拉去消息进行处理</strong>。这种模型适用于需要<strong>灵活控制消息消费速度</strong>的场景，例如<strong>数据采集，视频流传输</strong>等</li></ol><p>需要注意的是：以上模型并不是完全独立的，实际使用中可以更具具体场景组合适用不同的模型。例如，可以将点对点模型和请求-应答模型结合适用，实现异步的RPC调用。另外，在选择消息队列模型的时候，还需要考虑消息传输的可靠性，顺序性，延迟等因素</p><h2 id="有几台机器存储着几亿的淘宝搜索日志，假设你只有一台-2g-的电脑，如何选出搜索热度最高的十个关键词？"><a href="#有几台机器存储着几亿的淘宝搜索日志，假设你只有一台-2g-的电脑，如何选出搜索热度最高的十个关键词？" class="headerlink" title="有几台机器存储着几亿的淘宝搜索日志，假设你只有一台 2g 的电脑，如何选出搜索热度最高的十个关键词？"></a>有几台机器存储着几亿的淘宝搜索日志，假设你只有一台 2g 的电脑，如何选出搜索热度最高的十个关键词？</h2><p>针对 <strong>top k l类文本问</strong>题，通常比较好的方案是 【<strong>分治 + trie树&#x2F;hash + 小顶堆</strong>】，即先对数据集按照hash 方法分解成多个小数据集，然后适用 trie 树 或者 hash 统计每个小数据集中 query 词频，之后用小顶堆求出每个数据集中出现频率最高的前k个数，最后在所有Top K中求出最终的 top K。</p><p><strong>拆分成 n 多个文件：以首字母区分</strong>，不同的字母放在不同文件，长度仍过长的继续按照首字母进行拆分。这样一来，每个文件的每个数据长度相同且首字母尾字母也相同，就能保证数据被独立的分为了n个文件，且各个文件中不存在的关键字的交集</p><p><strong>分词频统计</strong>：对于每个文件，适用hash 或者 Trie 树进行词频统计</p><p><strong>小顶堆排序</strong>：依次处理每个文件，并逐渐更新最大的十个词</p><h2 id="什么是双亲委派模式？有什么作用？"><a href="#什么是双亲委派模式？有什么作用？" class="headerlink" title="什么是双亲委派模式？有什么作用？"></a>什么是双亲委派模式？有什么作用？</h2><p>双亲委派模式（Parent-Delegate Model）是Java类加载器（ClassLoader）在加载类时所采用的一种设计模式。这种模式的核心思想是：当一个类加载器收到类加载请求时，首先不会尝试自己加载这个类，而是将请求委派给其父类加载器。依次递归，直到最顶层的启动类加载器（Bootstrap ClassLoader）；如果父类加载器无法加载该类，子类加载器才会尝试自己去加载。</p><p>双亲委派模式的作用主要有以下几点：</p><ol><li><strong>避免类的重复加载</strong>：通过委派给父类加载器加载类。可以确保同一个类不会被多个类加载器重复加载。者有助于节省内存资源，并确保类之间的互操作性</li><li><strong>保护Java核心类库</strong>：由于双亲委派模式的存在，用户自定义的类加载器无法直接加载Java核心类库（如Java.lang.Object等）。这有助于确保Java核心类库的安全性，防止恶意代码篡改或破坏Java核心类</li><li><strong>维护类加载器的层次结构</strong>：双亲委派模式使得各级类加载器可以按照一定层次结构来组织和管理。这有助于降低类加载器的复杂性，简化类加载过程。</li></ol><p>双亲委派模式在java类加载器中的应用是一种优秀的设计原则，它有助于确保类加载过程的稳定性，安全性和可维护性</p><p>然而，在某些特殊场景下（如OSGi，Java热加载等），双亲委派模式可能无法满足需求，需要采用其他类加载策略。在这些场景下，开发者需要充分了解类的加载机制，以避免产生意外的问题</p><h2 id="什么是正向代理和反向代理，如何使用-Nginx-做反向代理？"><a href="#什么是正向代理和反向代理，如何使用-Nginx-做反向代理？" class="headerlink" title="什么是正向代理和反向代理，如何使用 Nginx 做反向代理？"></a>什么是正向代理和反向代理，如何使用 Nginx 做反向代理？</h2><p>正向代理和反向代理都是代理服务器的两种应用场景，它们在网络请求的处理过程中扮演不同角色</p><p>正向代理（Forward Proxy）：正向代理位于客户端和目标服务器之间，客户端通过正向代理来访问目标服务器。正向代理代表客户端发起的请求，隐藏客户端的真实身份。常见的应用场景包括科学上网，访问内网资源，缓存和过滤等</p><p>反向代理（Reverse Proxy）：反向代理位于客户端和目标服务器之间，客户端直接访问反向代理服务器，反向代理将请求转发给目标服务器。反向代理代表目标服务器接收请求，隐藏目标服务器的真实身份。常见的应用场景包括：负载均衡，安全防护，缓存和SSL终端等</p><p>使用Nginx作为反向代理的方法如下：</p><p>安装Nginx：根据操作系统的需求选择合适的Nginx版本进行安装。安装完成后，启动Nginx</p><p>配置反向代理：编辑Nginx 的配置文件（通常位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 或 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default），在http 或 server块中添加反向代理配置。</p><p>示例配置：</p><pre><code class="yaml">http &#123;    ...    server &#123;        listen 80;# 监听的端口号        server_name example.com;# 反向代理的域名                    location / &#123;            proxy_pass http://backend_server;# 将请求转发给目标服务器            proxy_set_header Host $host;# 设置请求头部信息            proxy_set_header X-Real-IP $remote_addr            proxy_set_header X-Forwarded-For $proxt_add_x_forward_for;        &#125;    &#125;&#125;</code></pre><p>在这个示例中，将客户端的请求转发给名为backend_server的目标服务器。同时设置了一些请求头部信息，以便目标服务器获取客户端的真实IP地址</p><p>重启Nginx：保存配置文件并重启Nginx，使配置生效。通常可以使用nginx -s reload 或 systemctl restart nginx命令重启Nginx。</p><p>完成以上步骤后，Nginx就被配置为反向代理服务器，可以将客户端的请求转发给目标服务器</p><h2 id="什么是-Git-的-fork-命令？它和-clone-命令有什么区别"><a href="#什么是-Git-的-fork-命令？它和-clone-命令有什么区别" class="headerlink" title="什么是 Git 的 fork 命令？它和 clone 命令有什么区别"></a>什么是 Git 的 fork 命令？它和 clone 命令有什么区别</h2><p>实际上，Git本身并没有一个名为fork 命令。Fork 是一种在代码托管平台（如github，gitlab等）上进行协作开发的概念</p><p>Fork 操作的本质是复制一个仓库到自己账户下，这样你就能在自己的仓库中进行修改，而不影响原始仓库。当你对自己仓库中的代码进行了修改，并希望将这些修改合并到原始仓库时，可以发起一个Pull Requset。仓库的所有者可以审核你的修改，并选择是否将其合并到原始的仓库中。</p><p>git clone命令是一个Git 命令，用于将远程仓库克隆到本地计算机上。当你克隆一个仓库时，Git 会将远程仓库的所有提交历史，分支和标签下载到本地。这样你就可以在本地进行开发，修改和提交操作</p><p>Fork 和 Clone 的区别如下：</p><ol><li>操作层面：Fork是在代码托管平台上进行的操作，它会在你的账户下创建一个新的仓库，与原始仓库相互独立。而Clone是在本地计算机上进行的操作，用于将远程仓库的内容复制到本地</li><li>目的：Fork 主要用于协作开发，它让你可以在自己的仓库中进行修改，然后通过Pull Request 将修改提交给原始仓库。而Clone 用于将远程仓库的内容下载到本地，以便你可以在本地进行开发和在修改</li><li>权限：Fork操作不需要原始仓库的写权限，只需要读权限。而clone操作通常需要在本地提交修改后，将修改推送到远程仓库。这可能需要原始仓库的写权限（除非你在自己Fork的仓库中进行开发）</li></ol><p>总之，Fork和Clone 是两个不同层面的操作，它们在协作开发和版本管理中扮演不同的角色。在实际应用中，你可能需要同时使用Fork和Clone来协同开发。例如，在Github上，你可以先Fork一个仓库到自己的账户下，然后使用git clone命令将Fork的仓库克隆到本地进行开发</p><h2 id="常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？"><a href="#常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？" class="headerlink" title="常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？"></a>常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？</h2><p>常见的垃圾回收算法有以下几种类型：</p><ol><li><strong>标记-清楚算法</strong>（Mark-Sweep）：分为标记和清除两个阶段。标记阶段遍历所有活动对象并打上标记，清楚阶段将未被标记的对象删除。优点是不需要连续内存空间，缺点是清楚后可能会产生内存碎片。</li><li><strong>复制算法</strong>（Copying）：将可用内存分为两块，只使用其中一块，当这一块满了后，将存活对象复制到另一块未被使用的空间，然后清楚使用的那块。优点是简单高效，没有内存碎片问题，缺点是需要额外的空间来存储复制后的对象</li><li><strong>标记-整理算法</strong>（Mark-Compact）：在标记阶段和标记-清除算法类似，但在清除阶段将存活对象整理到内存的一端，然后清除边界以的所有对象。优点是不会产生内存碎片，缺点是比较慢</li><li><strong>分代收集算法</strong>（Generational）：根据对象存货时间将内存分为几个区域，每个区域采用不同的回收策略。一般将新生代分为Eden区和两个Survivor区，采用复制算法回收；将老年代采用标记-清除或标记-整理算法回收。优点是提高了回收效率，缺点是需要额外的维护成本</li></ol><p>这些算法各有优缺点，适用于不同场景。标记-清除算法简单，但可能会产生内存碎片；复制算法适用于短时间内产生大量垃圾的场景，但需要额外的空间存储复制后的对象；标记-整理算法不会产生内存碎片，但比较慢；分代收集算法提高了回收效率，但需要额外的维护成本</p><p>对于一个应用程序，选择合适的垃圾回收算法需要综合考虑应用场景，内存需求，性能要求等多个因素，以便达到最佳效果</p><h2 id="CC-攻击是什么？什么叫-DDOS-攻击？什么是网站数据库注入？"><a href="#CC-攻击是什么？什么叫-DDOS-攻击？什么是网站数据库注入？" class="headerlink" title="CC 攻击是什么？什么叫 DDOS 攻击？什么是网站数据库注入？"></a>CC 攻击是什么？什么叫 DDOS 攻击？什么是网站数据库注入？</h2><p>CC 攻击（CC Attack）是一种网络攻击方式，全称为“压力测试（Concurrent Connections）攻击”。它通常是指对服务器进行大量并发请求的攻击，从而导致服务器的瘫痪。攻击者通过使用大量的机器或网络中的代理服务器，想目标服务器发送大量请求，以消耗服务器的带宽和资源，从而使其无法正常提供服务。CC攻击可以是攻击者自己编写的脚本，也可以是专门的CC攻击工具</p><p>DDOS 攻击（Distributed Denial of Service Attack）是一种网络攻击方式，它通常是指利用大量计算机或网络中的代理服务器，同时向目标服务器发送大量请求，从而导致目标服务器的瘫痪。DDOS攻击可以采用多种实现方式，如SYN攻击，UDP攻击，ICMP攻击等</p><p>网站数据库注入（SQL Injection）是一种利用Web 应用程序漏洞的攻击方式，攻击者通过及那个恶意SQL 代码插入到Web 应用程序的输入字段中，从而获取对数据库的未授权访问。网站数据库注入攻击可以导致许多问题，如破坏数据库的完整性，泄漏敏感数据，执行未经授权的操作。常见的防御措施包括输入验证，参数化查询，使用安全的API等</p><h2 id="你是否了解过新版本的-Java-特性？对-Java-未来的发展有什么看法？"><a href="#你是否了解过新版本的-Java-特性？对-Java-未来的发展有什么看法？" class="headerlink" title="你是否了解过新版本的 Java 特性？对 Java 未来的发展有什么看法？"></a>你是否了解过新版本的 Java 特性？对 Java 未来的发展有什么看法？</h2><p>Java 8（2014）：</p><ul><li>Lambda 表达式：简化函数式编程</li><li>Stream API：用于处理集合，支持函数式操作，如过滤，映射和聚合</li><li>默认方法：在接口中提供默认实现，提高接口的灵活性</li><li>Optional类：减少空指针异常，提高代码可读性</li></ul><p>Java 9（2017年）：</p><ul><li>模块系统（Project-Jigsaw）：将Java 的庞大代码库划分为可重用的模块，简化大型应用的构建和维护</li><li>JShell：Java的交互式命令行工具，用于快速尝试和测试Java 代码片段</li><li>新的集合工厂方法：方便的创建不可变集合，如List.of()，Set.of() 和 Map.of()。</li></ul><p>Java 10（2018年）：</p><ul><li>局部变量类型推断：使用var关键字自动推断局部变量的类型，简化代码</li><li>垃圾回收器接口改进：提高了垃圾收集器的可插拔性和灵活性</li></ul><p>Java 11 （2018年，长期支持版本）：</p><ul><li>新的HTTP客户端API：支持HTTP&#x2F;2 和 WebSocket，提供了更现代化的编程方式。</li><li>改进的垃圾收集：引入了ZGC和Eplion 垃圾收集器</li><li>String类的新方法：如lines()，isBlank()，strip()等</li></ul><p>Java 12 - 17的部分新特性：</p><ul><li>Switch 表达式：简化switch语句的编写，支持使用箭头的语法</li><li>文本块：简化多行字符串字面量的表示</li><li>Record：简化数据类的定义，自动为其生成构造函数，getter，hashCode，equals，toString方法</li><li>Pattern Matching for instanceof（预览功能）：简化instanceof操作符的使用，避免显式类型转换</li><li>密封类</li><li>删除实验性 AOT 和 JIT 编译器</li><li>特定于上下文的反序列化过滤器</li></ul><p>Java未来的发展趋势将会更加注重性能，安全和可靠性。以下是一些可能会影响Java未来发展的趋势</p><ol><li>云计算和容器化：Java非常适合在云环境中使用，因为它具有高度的可移植性和跨平台性。Java的未来将会更加注重云计算和容器化的支持</li><li>数据科学和人工智能：Java 16中的 Record 和 Sealed Classes 是一种更简洁的语法，未来Java可能会继续简化语法以提高代码的可读性和可维护性</li></ol><p>总之，Java未来将会继续发展和改进，以适应不断变化的编程环境和需求</p><h2 id="什么是-Git-的-cherry-pick？"><a href="#什么是-Git-的-cherry-pick？" class="headerlink" title="什么是 Git 的 cherry-pick？"></a>什么是 Git 的 cherry-pick？</h2><p>Git 的 cherry-pick 是一种将指定的提交（commit）应用到当前分支的操作。它可以帮助我们将某个分支上的某次提交复制到另一个分支上，而无需将整个分支合并过来。</p><p>通常，我们在使用 Git 进行版本控制时，会在不同分支上进行不同的开发工作。有时候，我们需要将某个分支上的某次提交（commit）应用到当前分支上，这时候就可以使用check-pick 操作</p><p>使用cherry-pick 操作，我们可以复制指定的提交，然后将其应用到当前分支上，这个提交就成为了当前分支上的一个新的提交。cherry-pick 操作可以方便将某个分支上的某个功能或修复应用到另一个分支上，而无需将整个分支合并过来</p><p>cherry-pick 操作的使用方法如下</p><pre><code class="git">git cherry-pick &lt;commit-id&gt;</code></pre><p>其中，指定了要复制的提交的ID，这个命令将会复制指定的提交，然后将其应用到当前分支上</p><p>需要注意的是，使用 cherry-pick 操作时，可能会出现冲突，这时候需要手动解决冲突，并提交一个新的提交来解决冲突。因此，在使用cherry-pick 操作之前，我们需要仔细考虑哪些提交需要复制，以及是否会产生冲突等问题</p><h2 id="如何在-Linux-中查看系统资源使用情况？比如内存、CPU、网络端口。"><a href="#如何在-Linux-中查看系统资源使用情况？比如内存、CPU、网络端口。" class="headerlink" title="如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。"></a>如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口。</h2><p>在Linux中，可以使用一些命令和工具来查看系统资源使用情况。下面介绍一些常用的命令和工具：</p><ol><li>top：top命令可以实时的显示系统中各个进程的资源使用情况，包括CPU使用率，内存使用率，进程ID等信息。可以通过top命令来查看当前系统的CPU 和内存使用情况</li><li>free：free命令可以查看系统中的内存使用情况，包括总内存使用量，已使用内存量和可用内存量等。可以通过free命令来查看当前系统的内存使用情况。</li><li>df：df命令可以查看系统中磁盘的使用情况，包括磁盘总容量，已使用空间和可用空间等，可用通过df命令查看当前系统的磁盘使用情况</li><li>iostat：iostat 命令可以查看系统的CPU 和磁盘I&#x2F;O 使用情况。可以通过iostat命令来查看当前系统的CPU 和 磁盘I&#x2F;O 使用情况。</li><li>netstat：netstat 命令可以查看系统中的网路连接情况，包括本地地址，远程地址，连接状态等信息，可以通过netstat命令来查看当前网络连接情况</li><li>lsof：lsof 命令可以查看系统中打开的文件和网络连接情况，包括文件名，文件描述符，进程ID，进程名等信息，可以通过lsof 命令查看当前系统的文件和网路连接情况。</li></ol><p>这些命令和工具都可以帮助我们了解当前系统资源的使用情况，方便我们对系统进行优化和管理。同时，也可以通过一些其他工具，如htop，iotop等，来查看系统资源使用情况</p><h2 id="如何用-Nginx-做限流，有几种限流算法，分别如何实现？"><a href="#如何用-Nginx-做限流，有几种限流算法，分别如何实现？" class="headerlink" title="如何用 Nginx 做限流，有几种限流算法，分别如何实现？"></a>如何用 Nginx 做限流，有几种限流算法，分别如何实现？</h2><p>Nignx 可以通过配置限制每个客户端请求的速率来实现限流。具体来说，Nginx 有两中限流方式：基于请求速率限制和基于连接速率限制</p><p>下面分别介绍这两种方式以及常用的限流算法。</p><ol><li><p>基于请求速率限制：基于请求限制是指限制每个客户端的请求速率，常用的限流算法有以下几种：</p><ul><li>漏桶算法：在单位时间内处理一定数量的请求，多余的请求则会放入一个”漏桶“中，随后以固定速率处理</li><li>令牌桶算法：在每个单位时间内，讲一定数量的”令牌“放入桶中，每次请求需要获得一个令牌才能被处理，当桶中没有令牌时，请求将被拒绝</li><li>计数器算法：简单的对请求计数，并限制每个客户端在单位时间内最多考研处理的请求数量</li></ul><p>在Nginx 中实现基于请求速率的限流通常需要使用模块，入ngx_http_limit_req_module，ngx_http_limit_conn_module等。</p></li><li><p>基于连接速率限制：基于连接速率限制时指限制每个客户端的连接速率，常用的限流算法有以下几种：</p><ul><li>并发连接数：限制每个客户端同时能够建立的连接数，以此来限制连接速率</li><li>队列长度：将每个连接加入到一个队列这中，限制队列中同时存在的连接数量，以此来限制连接速率</li></ul><p>在Nginx 中实现基于连接速率的限流通常需要使用模块，如 ngx_http_limit_conn_module等</p></li></ol><p>要实现基于请求速率或连接速率的限流，我们需要在Nginx 配置文件中设置相应的限流规则。以下是一个基于漏桶算法的Nginx 配置示例：</p><pre><code class="nginx">http &#123;    limit_req_zone $binary——remote_addr zone=one:10m rate=10r/s;        server &#123;        localtion / &#123;            limit_req zone=one burst=20;            proxy_pass http://backend;        &#125;    &#125;&#125;</code></pre><p>其中，limit_req_zone 指定了一个名为one 的共享内存区间，用于存储请求的统计信息，同时指定了速率为10r&#x2F;s 。在localtion 中，limit_req 指定了限流规则，并将请求转发到后端服务器</p><p>需要注意的是，不同的限流算法适用于不同的场景，我们需要根据实际情况选择合适的算法和配置参数。同时，在实际应用中，为了防止恶意攻击和DDOS攻击，通常需要将多种限流算法组合起来适用</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题2</title>
      <link href="/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
      <url>/2023/03/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？"><a href="#MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？"></a>MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？</h2><p>MySQL事务有四种隔离级别：</p><ol><li><strong>读未提交</strong>（Read Uncommitted）：事务可以读取未提交的数据，可能会读到脏数据，导致幻读，不可重复读，脏读等问题</li><li><strong>读已提交</strong>（Read Committed）：只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复读，幻读问题</li><li><strong>可重复读</strong>（Repeatable Read）：保证同一事务中多次读取同一数据的结果是一致的，避免了脏读和不可重复读问题，但是可能会遇到幻读的问题</li><li><strong>序列化</strong>（Serializable）：最高的隔离级别，可以避免所有的并发问题，但是并发性非常低，开销很大</li></ol><p>MySQL的默认隔离级别是可重复读</p><p><strong>脏读</strong>指一个事务读到了另一个事务未提交的数据</p><p><strong>不可重复读</strong>指同一个事务多次读到同一数据的不同结果</p><p><strong>幻读</strong>指同一事物前后读取的数据集合不一致（按条件查询时找不到数据，插入时又已存在数据）</p><h2 id="讲一下-Redis-的单线程模型，IO-多路复用是什么？"><a href="#讲一下-Redis-的单线程模型，IO-多路复用是什么？" class="headerlink" title="讲一下 Redis 的单线程模型，IO 多路复用是什么？"></a>讲一下 Redis 的单线程模型，IO 多路复用是什么？</h2><p>Redis是一款基于内存的高性能键值存储系统，采用单线程模型设计。在Redis中，所有客户端的请求都是由一个单线程来处理的，这个单线程不断从客户端套接字中读取命令请求，并将命令请求放入一个请求队列中。接着，Redis的事件处理器会按照一定的规则选择一个请求进行处理，处理完之后将响应结果返回给客户端。</p><p>单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，简化了系统的设计和调试。此外，由于Redis的内存访问速度非常快，因此单线程处理请求也能够保证足够的性能</p><p>IO多路复用是指在同一个线程中同时监听多个文件描述符，一旦某个文件描述符就绪，就立刻处理对应事件。在Redis中，采用的是基于epoll的IO多路复用技术，可以实现高效的事件监听和响应</p><p>在Redis中，客户端的请求是由一个单线程来处理的，而IO操作却是通过epoll多路复用技术实现的。这种设计方式既能充分利用CPU的计算能力，又能够保证足够的IO处理能力，从而实现高效的键值存储服务</p><h2 id="什么是-BIO、NIO、AIO？"><a href="#什么是-BIO、NIO、AIO？" class="headerlink" title="什么是 BIO、NIO、AIO？"></a>什么是 BIO、NIO、AIO？</h2><p>BIO、NIO、AIO都是Java的IO模型</p><p>BIO（Blocking IO）：同步阻塞IO，是传统的IO模型，它在读写数据时会<strong>阻塞线程</strong>，知道数据读写完成，适用于并发不高的场景</p><p>NIO（Non-blocking IO）同步非阻塞IO，是Java的新IO模型，它在读写数据时不会阻塞线程，而是通过<strong>轮询</strong>的方式查询是否有数据可读写，适用于并发量较高的场景</p><p>AIO（Asynchronous IO）异步非阻塞IO，是JDK7开始引入的新IO模型，它读写方式与NIO相似，但在读写数据时，不<strong>需要自己动手轮询</strong>是否有数据可读写，而是交由系统完成，适用于高并发且处理较大数据量的场景。</p><p>总的来说，BIO的并发处理能力较差，NIO的并发处理能力较好，但使用起来较为复杂，AIO的并发处理能力最好，但也是最为复杂的一种IO模型。现在适合自己场景的IO模型时非常重要的。</p><h2 id="意向锁是什么？有什么作用？它是表级锁还是行级锁？"><a href="#意向锁是什么？有什么作用？它是表级锁还是行级锁？" class="headerlink" title="意向锁是什么？有什么作用？它是表级锁还是行级锁？"></a>意向锁是什么？有什么作用？它是表级锁还是行级锁？</h2><p>意向锁时一种MySQL数据库中的锁，用于表级协调多个行级锁的使用。在表级锁定一个表之前，MySQL需要先获得一个意向锁，以表明要获取的锁的类型（读锁或写锁），避免其他事务锁定一部分表时引发死锁。</p><p>意向锁是一种轻量级锁，他不会影响其他事务的读操作，只有在某个事务要对表进行写操作时才会加上意向锁，而其他事务在读取时只需要获取读锁，不需要等待意向锁的释放。</p><p>意向锁可以提高数据库并发性能，防止死锁的发生。它是表级锁，而不是行级锁。</p><h2 id="Spring、SpringMVC、SpringBoot-三者之间是什么关系？"><a href="#Spring、SpringMVC、SpringBoot-三者之间是什么关系？" class="headerlink" title="Spring、SpringMVC、SpringBoot 三者之间是什么关系？"></a>Spring、SpringMVC、SpringBoot 三者之间是什么关系？</h2><p>Spring，SpringMVC，SpringBoot是三个独立的框架，它们之间的关系是：</p><ol><li>Spring是一个Java轻量级应用框架，提供基于IoC和AOP的支持，用于构建企业级应用。Spring有多个模块，包括Spring Core，Spring Context，Spring JDBC，Spring Web等，每个模块提供了不同的功能。</li><li>SpringMVC 是 Spring框架的一部分，是基于MVC设计模式的web框架，用于构建web应用程序。它提供了控制器，数据绑定，异常处理等功能，使得开发Web应用变得更加简单。SpringMVC还支持RESTfuk架构。</li><li>SpringBoot是基于Spring框架的一个开发框架，用于快速构建独立的，生产级别的Spring应用程序。它通过自动配置和约定优于配置的方式，简化了Spring应用程序的配置和开发过程。SpringBoot集成了很多常用的第三方库和工具，例如SpringData，SpringSecurity，Thymeleaf，Logback等，可以极大的提高开发效率。</li></ol><p>因此，SpringBoot可以看作是在Spring的基础上，通过自动装配的约定优于配置的方式，提供了更加简单，快速的开发体验。而SpringMVC则是Spring框架中用于构建Web应用程序的模块</p><h2 id="Redis-基础类型中的-String-底层实现是什么？"><a href="#Redis-基础类型中的-String-底层实现是什么？" class="headerlink" title="Redis 基础类型中的 String 底层实现是什么？"></a>Redis 基础类型中的 String 底层实现是什么？</h2><p>Redis中的Spring类型底层实现是一个简单的动态字符串（SDS,Simple Dynamic String），也就是字符串动态增长实现的一种方式，SDS是Redis自己实现字符串库，相对于C语言原生的字符串，SDS在空间使用上更加灵活，而且支持O（1）复杂度的长度计算，避免了C语言字符串计算长度时的O（N）时空复杂度问题</p><p>SDS是一种动态字符串，它有如下特点：</p><ol><li>首先SDS对内存的分配和释放进行了封装，使得字符串的空间可以根据需要进行增长或缩短，避免了C语言字符串需要手动分配空间的问题</li><li>SDS除了记录字符串本身的长度外，还记录了分配给字符串的空间的长度，可以方便的计算出字符串是否需要扩容</li><li>SDS使用了惰性空间释放，不会再空间缩减时立刻释放空间，而是等到需要扩容时再重新分配内存</li><li>SDS提供了字符串的追加操作，可以在O（1）的时间内完成追加操作。</li></ol><p>在Redis中，String类型并不仅仅时字符串类型，它还支持一些其他操作，如递增&#x2F;递减操作，位运算，这些操作都是基于SDS底层实现的。</p><h2 id="有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？"><a href="#有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？" class="headerlink" title="有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？"></a>有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？</h2><p>在Spring框架中，常用的注入Bean的注解包括：</p><ol><li>@Autowired：自动注入，按照类型自动装配，如果有多个类型相同的Bean，则需要通过@Qualifier指定具体的Bean</li><li>@Resource：Java自带的注入方式，按照名称自动装配，默认是按照属性名称进行匹配，如果需要按照Bean的名称进行匹配，可以使用@Resource（name&#x3D;”beanName”）</li><li>@Inject：和@Autowired类似，也是按照类型进行自动装配，但是@Inject注解是JSR-330 提供的，而@Autowired 注解是 Spring 框架提供的</li><li>@Value：用于注入配置文件中的属性值，可以指定默认值</li><li>@Component：用于声明一个Bean，作用类似于XML中的&lt; bean &gt; 标签</li></ol><p>以上注解都可以用于注入Bean，不同注解之间的区别主要在于注入方式和实现方式不同。＠Autowired 和@Resource最常用，其中@Autowired按照类型自动装配更为常用，而@Resource按照名称自动装配则比较适合需要明确指定的Bean名称的情况</p><p>需要注意的是，注入Bean的时候最好使用接口类型作为注入对象，这样可以避免应为具体实现类变更导致注入失败的问题</p><h2 id="请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？"><a href="#请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？" class="headerlink" title="请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？"></a>请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？</h2><p>JVM内存模型分为一下几个区域：</p><ol><li>程序计数器（Program Counter Register）：每个线程都有自己的程序技术器，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确位置</li><li>虚拟机栈（JVM Stack）：也称Java方法栈，用于存储方法执行时的局部变量表，操作数栈，动态链表，方法出口等信息.每个线程正在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈</li><li>本地方法栈（Native Method Stack）：于虚拟机栈类似，用于存储本地方法的执行信息</li><li>堆（Heap）：用于存储对象实例，时JVM中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的独享实例都有一个标记用于标记对象是否存活，垃圾回收器会周期性的回收那些没有被标记为存活的对象</li><li>方法区（Method Area）：用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。方法区也是被所有线程共享的</li><li>运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池</li></ol><p>其中，程序计数器，虚拟机栈，本地方法栈是线程私有，堆，方法区，运行时常量池是线程共享的</p><h2 id="Linux-中的硬链接和软连接是什么，二者有什么区别？"><a href="#Linux-中的硬链接和软连接是什么，二者有什么区别？" class="headerlink" title="Linux 中的硬链接和软连接是什么，二者有什么区别？"></a>Linux 中的硬链接和软连接是什么，二者有什么区别？</h2><p>在Linux 文件系统中，硬链接（hard link）和软连接（私有mbolic link）都是一种文件链接方式，可以用于将一个文件链接到另一个文件上。它们主要区别在创建方式，所占空间和使用限制等方面</p><p>硬链接是通过在文件系统中创建一个新的目录项（directory entry）指向同一文件inode的位置来实现。因为硬链接实际上是指向同一inode，所以如果源文件被删除，硬链接依然能够访问到源文件的内容。硬链接的使用范围比较受限，因为硬链接只能指向一个文件系统内的文件，不能跨文件系统创建</p><p>软链接是通过在文件系统中创建一个新的文件来实现，该文件中包含指向另一个文件的路径。软连接可以跨文件系统创建，并且可以指向任何类型的文件。但是，当源文件被删除时，软链接会失效</p><p>总的来说，硬链接要更加高效，因为它只是添加了一个新的目录项，所以对磁盘空间的消耗比软链接要小。但是，硬链接不能跨文件系统，所以在实际应用中需要根据具体的需求来选择使用哪种链接方式</p><h2 id="如何使用-Redis-实现一个排行榜？"><a href="#如何使用-Redis-实现一个排行榜？" class="headerlink" title="如何使用 Redis 实现一个排行榜？"></a>如何使用 Redis 实现一个排行榜？</h2><p>使用Redis 可以很方便的实现一个排行榜，以下是一种实现方式：</p><p>使用有序集合（Sorted Set）来存储排行榜数据，以用户得分作为分数（score），用户ID作为成为（member）</p><p>当用户得分改变时，使用Redis的ZADD命令将用户的分数更新到有序集合中</p><p>获取排行榜数据时，使用Redis的ZREVRANGE命令按分数排序获得有序集合中的成员</p><p>可以使用Redis的ZSCORE命令获取某个用户的分数，或使用ZREVRANK命令获取某个用户的排名。例如：</p><pre><code class="java">import redis.clients.jedis.Jedis;import java.util.Map;import java.util.Set;public class RedisRankingList &#123;    private final Jedis jedis;    public RedisRankingList() &#123;        // 连接 Redis        jedis = new Jedis(&quot;localhost&quot;);    &#125;    /**     * 添加用户分数     */     public void addUserScore(String userId, double score) &#123;        jedis.zadd(&quot;ranking&quot;, score, userId);    &#125;    /**     * 获取排行榜前 N 名用户信息     */    public void getTopN(int n) &#123;        // 获取排行榜前 N 名用户的 ID 和分数        Set&lt;Map.Entry&lt;String, Double&gt;&gt; rankingSet = jedis.zrevrangeWithScores(&quot;ranking&quot;, 0, n - 1);        // 遍历集合，输出用户信息        for (Map.Entry&lt;String, Double&gt; entry : rankingSet) &#123;            String userId = entry.getKey();            double score = entry.getValue();            System.out.println(&quot;userId: &quot; + userId + &quot;, score: &quot; + score);        &#125;    &#125;&#125;</code></pre><h2 id="什么是网关，网关有哪些作用？"><a href="#什么是网关，网关有哪些作用？" class="headerlink" title="什么是网关，网关有哪些作用？"></a>什么是网关，网关有哪些作用？</h2><p>网关（Gateway）是在计算机网络中用于连接两个独立的网络的设备，它能够在两个不同协议的网络之间传递数据。在互联网中，网关是一个可以连接不同协议的网络设备请求，比如说可以连接局域网和互联网，它可以把局域网和内部网络地址转换成互联网上的合法地址，从而使得局域网的主机可以与外界通信。</p><p>在计算机系统中，网关可以用于实现负载均衡，安全过滤，协议住那换等功能。具体来说，网关可以分为以下几种：</p><ol><li>应用网关：用于应用层协议的处理，如HTTP，SMTP等</li><li>数据库网关：用于数据库访问的控制和管理</li><li>通信网关：用于不同通信协议之间的数据交换，如TCP&#x2F;IP，UDP&#x2F;IP 等。</li><li>API网关：用于管理和转发API请求，实现API 的授权，限流，监控等功能</li></ol><p>总的来说，网关可以不同网络提供连接和通信的功能，同时也可以提供安全，性能，可靠性等方面的增强功能，是现代计算机不可或缺的一部分</p><h2 id="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"><a href="#线程的生命周期是什么，线程有几种状态，什么是上下文切换？" class="headerlink" title="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"></a>线程的生命周期是什么，线程有几种状态，什么是上下文切换？</h2><p>线程的生命周期通常包括物种状态：新建（New），就绪（Runnable），运行（Running），阻塞（Blocked）和终止（Terminated）。其中：</p><ul><li>新建状态是指当前线程对象创建后，就进入了新建状态。此时它已经有了相应的内存空间和其他资源，但是还没有开始运行</li><li>就绪状态是指当前线程对象调用start()方法后，线程进入了就绪状态。此时它已经具备了运行的条件，只等CPU分配资源，让其开始执行</li><li>运行状态是指当线程对象获得CPU资源后，就开始执行run() 方法中的代码，线程处于运行状态</li><li>阻塞状态是指线程在特定情况下会被挂起，暂时停止执行。当线程处于阻塞状态时，它并不会占用CPU 资源</li><li>终止状态是指线程的run() 方法执行完毕或者因异常退出时，线程进入了终止状态。此时，线程不再占有CPU资源，也不再执行任何代码。</li></ul><p>在线程的生命周期中，线程状态的转换通常时由操作系统调度和控制的。当线程的状态发生变化时，需要进行上下文切换，即保存当前线程的状态和上下文信息，并恢复另一个线程的状态和上下文信息，使其能够继续执行。上下文切换会带来一定的开销，因此需要尽可能减少线程之间的切换次数。</p><h2 id="MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？"><a href="#MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？" class="headerlink" title="MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？"></a>MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</h2><p>MVCC 是指多版本并发控制（Multiversion Concurrency Control），是一种并发控制机制，常用于数据库，用于实现事务的并发控制。它允许在同一时间多个事务对同一个数据集合进行读取操作，同时防止数据不一致和其他并发问题。</p><p>InnoDB 是 MySQL 中最常用的存储引擎之一，它的MVCC 实现是通过在每行记录中添加两个隐藏的列，分别记录行的创建时间和过期时间，以此来判断事务对该行记录的可见性。当一个事务需要读取一行记录时，InnoDB首先读取这行记录的创建时间和过期时间，并根据这些信息判断该行记录是否可见。如果创建时间早于当前事务的开始时间，且过期时间晚于当前事务的开始时间，那么该行记录对当前事务可见。</p><p>在InnoDB 中，MVCC 主要是通过实现以下几个机制来实现的：</p><ol><li>事务版本号：每个事务都有一个唯一的版本号，用来标识该事务的创建时间。</li><li>读取视图：每个事务在开始的时候都会创建一个读取视图，记录该事务开始时间和其他信息。在事务执行期间，所有读取操作都要检查该视图，以确定读取哪些版本的数据</li><li>undo 日志：在事务执行期间，如果对数据进行修改，那么会先将原始数据复制一份到undo日志中。这样，在回滚操作时就可以使用undo 日志中的数据来还原原始数据。</li><li>快照读取：在某些情况下，事务需要读取一个数据的历史版本，而不是当前版本。这是可以使用快照读取来实现，即在读取事务开始时间和undo 日志来读取历史版本的数据。</li></ol><h2 id="Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？"><a href="#Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？" class="headerlink" title="Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？"></a>Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？</h2><p>Redis 的持久化机制主要分为RDB 和AOF 两种</p><p>RDB 持久化机制</p><p>RDB 持久化机制是指将 Redis 在内存中的数据以快照的形式写入磁盘中，可以手动或自动执行快照操作，将数据集的状态保存到一个RDB文件中。RDB 机制的优点在于：</p><ul><li>RDB 机制适合在数据集比较大时进行备份操作，因为它可以生成一个非常紧凑，经过压缩的数据文件，对于备份，恢复，迁移数据都很方便</li><li>RDB机制在Redis 重启时比AOF 机制更快地将Redis 恢复到内存中。</li></ul><p>RDB 机制的缺点在于：</p><ul><li>RDB 机制可能会出现数据丢失，因为数据是周期性的进行备份，一旦Redis出现问题并且上一次备份之后还没有进行数据变更，那么这部分数据将会丢失</li><li>RDB 机制会造成一定的IO 压力，当数据集比较大时，进行备份操作可能会阻塞Redis服务进程</li></ul><p>AOF 持久化机制</p><p>AOF 持久化机制是指将Redis 在内存中的操作指令以追加的形式写入到磁盘中的AOF 文件，AOF 文件记录了 Redis 在内存中的操作过程，只要在Redis 重启后重新执行AOF 文件中的操作命令即可将数据恢复到内存中。AOF机制的优点在于：</p><ul><li>AOF机制比RDB 机制更加可靠，因为AOF 文件记录了Redis 执行的所有操作命令，可以确保数据不丢失。</li><li>AOF 机制在恢复大数据集时更加稳健，因为AOF文件记录了数据的操作过程，可以确保每一次操作都被正确执行</li></ul><p>AOF机制的缺点在于：</p><ul><li>AOF 机制生成的AOF 文件比RDB 文件更大，当数据集比较大时，AOF 文件会比RDB 文件占用更多的磁盘空间</li><li>AOF 机制对数据恢复的时间比RDB 机制更加耗时，因为要重新执行AOF文件中的全部命令</li></ul><p>综上所述，RDB适用于数据集较大，备份，恢复数据和迁移数据等场景，AOF适用于数据可靠性要求高，数据恢复稳健等场景。</p><h2 id="Nginx-是什么？它有哪些应用场景？"><a href="#Nginx-是什么？它有哪些应用场景？" class="headerlink" title="Nginx 是什么？它有哪些应用场景？"></a>Nginx 是什么？它有哪些应用场景？</h2><p>Nginx（发音为”engine-x”）是一个高性能的开源Web服务器和反向代理服务器，可以处理大量的并发连接和请求。它使用事件驱动的异步架构和多线程设计，可以高效的处理并发请求，同时也支持反向代理，负载均衡，动态HTTP缓存，SSL&#x2F;TLS终止，基于模块的扩展功能。</p><p>Nginx的应用场景每场广泛，以下是其中几个：</p><ol><li>Web服务器：Nginx 可以作为HTTP 服务器，处理并发的静态请求和动态请求，并且可以支持负载均衡和缓存，为网站提供高性能和高可用性</li><li>反向代理服务器：Nginx可以作为反向代理的服务器，接收客户端请求并且将其转发到后端服务器，同时也可以支持负载均衡和缓存。</li><li>邮件代理服务器：Nginx 可以作为邮件代理服务器，支持POP3，IMAP和SMTP协议，并且可以支持SSL&#x2F;TLS加密和反垃圾邮件功能</li><li>流媒体服务器：Nginx可以作为流媒体服务器，支持RTMP，HLS和DASH协议，可以用于实现直播，点播和视频-on-demand（VoD）等场景</li></ol><p>总之，Nginx具有高性能，可扩展性和可靠性等特点，被广泛应用于大型网站，互联网公司，云计算，视频流媒体，游戏等领域。</p><h2 id="Dubbo-是什么？是否了解过它的架构设计？"><a href="#Dubbo-是什么？是否了解过它的架构设计？" class="headerlink" title="Dubbo 是什么？是否了解过它的架构设计？"></a>Dubbo 是什么？是否了解过它的架构设计？</h2><p>Dubbo 是一个高性能，轻量级的开源Java RPC 框架，它提供了完整的RPC协议栈，包括服务发布，服务引用，负载均衡，容错，服务治理和服务监控等功能，同时提供了可扩展的RPC协议，数据模型，序列化和网络传输等组件，支持多语言和多协议</p><p>Dubbo 的架构设计主要包括服务提供者，服务消费者，注册中心和监控中心四个角色。其中，服务提供者提供服务的实现，并通过注册中心将自己注册到服务治理中心；服务消费者则通过注册中心发现可用的服务，并通过负载均衡策略选择一个服务提供者进行调用；注册中心主要负载服务的注册，发现和路由；监控中心则负责服务的统计和监控。</p><p>Dubbo的架构设计采用了分层架构，将不同的功能模块进行分离，以达到模块化和可扩展的目的。同时，Dubbo还提供了丰富的扩展点和插件机制，用户可以通过自定义扩展点和插件来满足不同的业务需求。</p><h2 id="synchronized-关键字是什么，有什么作用？"><a href="#synchronized-关键字是什么，有什么作用？" class="headerlink" title="synchronized 关键字是什么，有什么作用？"></a>synchronized 关键字是什么，有什么作用？</h2><p>synchronized 是 Java 中的一个关键字，用于实现线程同步。具体来说，</p><p>synchronized 用于修饰方法或代码块，使得同一时刻只能有一个线程访问被修饰的代码，其他线程需要等待当前线程执行完毕后才能访问。</p><p>synchronized 主要用于解决多线程并发访问共享资源时出现的线程安全问题。如果多个线程同时访问同一个共享资源，就会出现多个线程同时修改这个资源的情况，从而导致该数据不一致等问题。而使用 synchronized 可以保证同一时刻只有一个线程访问该资源，从而避免了线程安全问题</p><p>synchronized 的作用不仅限于线程同步，它还可以保证可见性和有序性，即保证在同一个锁上，一个线程修改了共享变量的值后，另一个线程能够立即看到修改后的值，并且在多个线程执行顺序上保持了一致性。</p><p>需要注意的是：使用synchronized 会带来一定的性能损失，因为每次进入同步块时都需要获得锁，这会增加线程的等待事件和上下文切换的开销。同时，如果同步块的代码执行时间很短，也会增加不必要的性能开销。因此，需要根据具体情况来判断是否需要使用synchronized 。</p><h2 id="如何设计一个点赞系统？"><a href="#如何设计一个点赞系统？" class="headerlink" title="如何设计一个点赞系统？"></a>如何设计一个点赞系统？</h2><p>设计一个点赞系统可以分为以下几个步骤：</p><ol><li>确定需求：需要明确点赞的对象是什么，是否需要计数等信息，同时需要考虑点赞的业务场景，如用户点赞，文章点赞等</li><li>数据库设计：需要设计点赞相关的数据表，可以包含点赞者ID，被点赞对象的ID，点赞时间等字段。</li><li>接口设计：需要设计点赞等相关的接口，包括点赞，取消点赞，查询点赞数等操作</li><li>业务逻辑实现：在接口中实现点赞相关的业务逻辑，包括判断点赞状态，更新点赞数，更新点赞状态等操作。</li><li>安全性考虑：需要考虑并发访问的情况，可以使用分布式锁来保证数据一致性和安全性</li><li>性能优化：如果点赞系统的访问量很高，可以使用缓存来提高性能，比如使用Redis 来缓存点赞等信息</li><li>监控和日志：需要对点赞系统进行监控和日志记录，以便即使发现和排查问题</li></ol><p>总之，设计一个点赞系统需要综合考虑需求，数据库设计，接口设计，业务逻辑实现，安全性，性能优化等方面，同时需要不断优化和完善。</p><h2 id="什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？"><a href="#什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？" class="headerlink" title="什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？"></a>什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？</h2><p>内部类是定义在另一个类中的类。Java 中内部类主要分为成员内部类，静态内部类，局部内部类和匿名内部类</p><ol><li>成员内部类：定义在另一个类的内部，并且与其他成员变量和方法平级，可以访问外部类的所有成员变量和方法。<strong>使用方法：Outer.Inner inner &#x3D; new Outer().new Inner().</strong></li><li>静态内部类：定义在另一个类的内部，但是要用static修饰。只能访问外部类的静态成员变量和方法：<strong>使用方法：Outer.Inner inner &#x3D; new Outer.Inner().</strong></li><li>局部内部类：定义在方法中，作用域仅限于方法内部。与局部变量类似，不能使用访问控制符修饰。<strong>使用方法：在方法中直接实例化</strong></li><li>匿名内部类：没有名字的内部类。<strong>使用方式：new接口或者抽象类(){} 或 new 父类() {}</strong></li></ol><p>内部类的优点：</p><ol><li>可以访问外部类的私有成员变量和方法</li><li>可以隐藏实现细节</li><li>便于编写和维护，提高代码的可读性和可维护性</li><li>内部类可以很好的解决Java中单继承的问题</li></ol><p>内部类的应用场景：</p><ol><li>需要访问外部类的私有成员变量和方法</li><li>需要定义一个回调函数或监听器</li><li>需要实现多重继承</li><li>需要对外部类进行扩展、</li></ol><h2 id="MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"><a href="#MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。" class="headerlink" title="MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"></a>MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。</h2><p>覆盖索引和联合索引是数据库中常见的两种索引类型</p><p>覆盖索引是指一个包含了所有查询需要的列的索引， 查询时可以直接从索引中渠道需要的数据，而不需要再回到表中查找，从而可以提高查询效率</p><p>联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描</p><p>最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了A，B，C三列，那么查询时只能使用A，AB 或ABC 进行匹配，而不是只是用 B 或 C 进行匹配。这是应为如果查询时使用的列不是最左前缀列，那么MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。</p><p>在实际的应用中，覆盖索引和联合索引可以结合使用，以提高查询效率。同时，使用最左前缀匹配原则可以让我们更加合理的设计索引，从而提高查询性能。</p><h2 id="Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？"><a href="#Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？" class="headerlink" title="Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？"></a>Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？</h2><p>Spring 框架中处理线程并发问题的方式包括以下几种：</p><ol><li>同步关键字 synchronized：使用synchronized 关键字可以对共享资源进行加锁，从而保证多线程访问时的同步性。但是，synchronized 会对性能产生一定的影响，并且容易导致死锁等问题</li><li>Lock 接口：Lock 接口提供了比 synchronized 更加灵活的加锁方式，并且可以防止死锁问题发生。但是，Lock 接口使用相对复杂，需要手动进行加锁和解锁的操作</li><li>ThreadLocal类：ThreadLocal 类提供了线程本地变量的功能，可以让每个线程拥有自己的变量副本，从而避免了多个线程之间的共享问题。但是，ThreadLocal 类的使用需要注意内存泄漏问题</li></ol><p>关于ThreadLocal ，它是Java 中一个非常重要的类，用于实现线程本地存储，即让每个线程都拥有自己的变量副本，从而避免多个线程之间的共享问题。在Spring 框架中，ThreadLocal 类经常用于存储一些与当前线程有关的数据，例如请求上下文，用户信息等。通过将这些数据保存到ThreadLocal 对象中，可以方便的在整个应用程序中进行访问和传递，同时避免了多个线程之间的共享问题</p><p>ThreadLocal 类的使用需要注意内存泄漏问题，因为线程本地变量只有在对应的线程被回收时才会被回收，如果没有及时清理，就可能导致内存泄漏问题。因此，在使用ThreadLocal 类时，需要注意在不需要存储数据时及时调用remove() 方法清理ThreadLocal 对象中的数据</p><h2 id="什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？"><a href="#什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？" class="headerlink" title="什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？"></a>什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？</h2><p>MySQL 执行计划是指MySQL 查询优化器生成的一份详细的查询执行计划，它展示了MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序，数据读取方式，使用的索引，使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。</p><p>要获取执行计划，可以在执行SQL 语句时在前面添加 explain 关键字，例如：</p><pre><code class="java">explain select * from table id = 1;</code></pre><p>这样，MySQL 会输出该查询语句的执行计划。执行计划中的各个字段含义如下：</p><ul><li>id：每个Select 子句或者是一个操作符或者是一个查询语句</li><li>select_type：查询类型，标识查询的类型（简单查询，联合查询，子查询等等）</li><li>table：查询设计的表</li><li>partitions：匹配的分区</li><li>type：访问类型，表示MySQL在表中找到所需行的方式</li><li>possible_keys：表示查询可能使用到的索引</li><li>key：实际使用到的索引</li><li>key_len：使用的索引长度</li><li>ref：列与索引的比较</li><li>rows：根据表统计信息及索引选用情况，大致估算出找到所需要的记录所需要读取的行数</li><li>filtered：返回结果的行数占总行数的比例</li><li>Extra：包含MySQL解决查询的详细信息</li></ul><p>分析执行计划时，需要注意以下几个方面：</p><ul><li>扫描行数：rows字段，表示查询所需扫描的行数，如果该值过大，说明查询效率不高，需要优化</li><li>使用索引：key字段，表示查询使用的索引，如果没有使用索引或者使用的不是最优索引，需要考虑优化</li><li>排序：Extra字段，如果查询需要使用filesort排序，说明查询效率不高，需要优化</li><li>嵌套循环：如果查询类型时 nested loop，说明查询中包含嵌套循环，也需要考虑优化</li></ul><p>通过分析执行计划，可以确定查询优化的方法和方向，提高查询效率</p><h2 id="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"><a href="#什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？" class="headerlink" title="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"></a>什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？</h2><p>单例模式时一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式的目的是确保类的一个唯一实例，因此其他类可以轻松的从一个可知的地方访问它</p><p>单例模式的好处：</p><ol><li>节省系统资源：在系统中，如果有多个实例会造成资源浪费，而使用单例模式可以减少这种浪费</li><li>简化了对象访问，单例模式提供了一个全局访问的访问点，因此可以简化访问过程</li></ol><p>常用的单例模式实现方式有以下几种：</p><ol><li>饿汉式单例模式：在类加载时创建单例对象。缺点是不支持延迟加载。</li><li>懒汉式单例模式：在第一次使用时才创建单例对象。缺点是需要考虑线程安全问题</li><li>双重检查锁单例模式：在第一次使用时创建单例对象，并使用双重检查锁定来确保线程安全</li><li>枚举单例模式：在枚举类型中创建单例对象，可以防止反射和序列化攻击</li></ol><p>应用场景：</p><ol><li>数据库连接池：通过使用单例模式，可以确保系统中只有一个数据库连接池</li><li>日志记录器：可以使用单例模式记录系统日志，这样可以确保系统中只有一个日志记录器</li><li>配置文件管理器：可以使用单例模式来管理应用程序的配置文件，这样可以避免重复读取配置文件的开销</li><li>线程池：可以使用单例模式来确保系统中中只有一个线程池</li></ol><p>一个例子时Spring 框架中 ApplicationContext ，它是一个全局访问点，提供了一个管理Bean 的中央注册表。由于 Spring 中的 Bean 只需要创建一次，因此ApplicationContext 使用单例模式确保只有一个实例。</p><h2 id="什么是云原生？它有哪些优缺点？"><a href="#什么是云原生？它有哪些优缺点？" class="headerlink" title="什么是云原生？它有哪些优缺点？"></a>什么是云原生？它有哪些优缺点？</h2><p>云原生是一种开发和运行应用程序的方法，旨在利用云计算的弹性，可扩展性，可靠性和高可用性等优势。它通过将应用程序打包到容器中，使用容器编排工具进行管理，实现了应用程序在不同环境中的快速部署，弹性伸缩和高可用性</p><p>云原生的优点包括：</p><ol><li>灵活性和可扩展性：容器可以快速部署和扩展，以满足不同负载要求</li><li>高可用性：容器编排工具可以自动检测和恢复容器故障，提供高可用性</li><li>效率和成本优化：使用容器可以节省资源和成本，提高应用程序的运行效率</li><li>安全性：容器隔离应用程序的运行环境，减少了安全漏洞的风险</li></ol><p>云原生的缺点：</p><ol><li>学习曲线较陡峭：云原生技术较为复杂，需要学习一些新技术和工具</li><li>可能存在依赖问题：应用程序可能依赖于某些特定的云原生技术或工具，这可能导致一些限制或局限性。</li><li>管理和维护难度：容器编排工具可能需要额外的管理和维护，需要更多的操作和维护成本</li></ol><p>云原生的应用场景包括：</p><ol><li>微服务架构：云原生技术非常适合构建微服务框架，将应用程序拆分为小型，自治的服务</li><li>弹性伸缩：云原生技术可以根据应用程序的负载自动扩展或缩小容器数量，以适应不同负载要求</li><li>快速部署：使用云原生技术，可以快速的部署和更新应用程序，提高开发和部署效率</li><li>多云部署：云原生技术可以在多个云环境中运行，方便应用程序在不同云环境中的部署和迁移</li><li>数据分析和处理：云原生技术可以处理大规模的数据和分析任务，提高数据处理效率</li></ol><h2 id="TCP-和-UDP-协议有什么区别，分别适用于什么场景？"><a href="#TCP-和-UDP-协议有什么区别，分别适用于什么场景？" class="headerlink" title="TCP 和 UDP 协议有什么区别，分别适用于什么场景？"></a>TCP 和 UDP 协议有什么区别，分别适用于什么场景？</h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常用的传输层协议，它们有以下区别：</p><ol><li><strong>连接方面</strong>：TCP是面向连接的协议，而UDP是无连接协议。在TCP 中，发送方和接收方必须先建立连接，然后才能传输数据。UDP 则不需要建立连接，直接发送数据即可</li><li><strong>可靠性</strong>：TCP 保证数据传输的可靠性，通过序列号，确认应答和重传机制等方式来保证数据的完整性和正确性。UDP则不保证数据传输的可靠性，因为它不提供确认和重传机制</li><li><strong>传输速度</strong>：因为TCP 要保证数据传输的可靠性，所以在传输速度方面相对较慢。而UDP则不需要进行复杂的传输控制，因此传输速度更快</li><li><strong>传输内容</strong>：因为TCP 是一种面向字节流的协议，将数据看作是一连串的字节流，没有明确的边界消息。UDP 则是面向报文的协议，将数据看作是一系列的报文，每个报文是一个独立的单元，具有明确的消息边界</li></ol><p>基于以上特点，TCP 和 UDP 适用于不同场景。TCP 适用于对传输可靠性要求比较高的场景，例如网页浏览，文件传输，邮件等。而UDP则适用于对传输可靠性要求较低，传输速度要求较高的场景，例如在线游戏，视频直播等</p><h2 id="什么是分布式的-CAP-理论？"><a href="#什么是分布式的-CAP-理论？" class="headerlink" title="什么是分布式的 CAP 理论？"></a>什么是分布式的 CAP 理论？</h2><p>分布式的CAP 理论是指在分布式系统中，一致性（Consistency），可用性（Availability）和分区容错性（Parttion Tolerance）这三个指标无法同时满足的问题。具体来说：</p><ul><li><strong>一致性</strong>（Consistency）：指多个副本之间数据保持一致，即在一个副本上的写操作会立刻同步到其他所有副本，所有副本的数据都是最新的，保持强一致性</li><li><strong>可用性</strong>（Availability）：指系统在任何时候都能对外提供服务，即系统随时能够响应用户请求，不会因为节点故障或其他原因导致服务中断</li><li><strong>分区容错性</strong>（Partition Tolerance）：指系统在出现网络分区（节点之间失去联系）时，仍能够继续工作，保证数据的一致性和可用性</li></ul><p>CAP 理论指出，一个分布式系统只能同时满足其中的两个指标，无法同时满足三个。例如：当出现网络分区时，如果包保证一致性，就必须停止对外服务，从而失去可用性；如果要保证可用性，就必须放弃一致性，从而可能导致不同节点之间数据不一致。因此，在设计分布式系统时，需要根据具体的场景和需求来选择合适的权衡方案，比如选择CP（一致性和分区容错性）或者选择AP（可用性和分区容错性）</p><p>需要注意的是：CAP 理论知识一种理论框架，不能直接应用于实际的分布式系统设计。在实际应用中，还要考虑系统的具体业务需求，数据访问模式，节点规模和部署环境等因素，综合权衡之后再选择合适的分布式框架和技术方案。</p><h2 id="如何用-Redis-实现分布式-Session？"><a href="#如何用-Redis-实现分布式-Session？" class="headerlink" title="如何用 Redis 实现分布式 Session？"></a>如何用 Redis 实现分布式 Session？</h2><p>在分布式系统中，通常会将Session 存储在Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享Session数据。实现分布式Session 的方式有多种，其中一种常用的方式是使用Redis 的数据结构Hash 。具体的实现步骤如下：</p><ol><li>在用户登录成功后，将Session 数据存储在 Redis中</li><li>将Redis 的Session 数据 Key 设置为一个全局唯一的 ID，一般使用类似于“ session : token ”的格式，其中token是一个随机生成的字符串，用来表示这个Session 数据</li><li>在客户端返回响应的同时，将Session ID（即token）以Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个Cookie</li><li>在后续请求中，服务器会从客户端传递过来的Cookie 中获取 Session ID ，然后根据这个 ID 从 Redis 中获取对应的Session 数据。如果Redis 中没有找到对应的Session 数据，那么就表示这个请求无法通过认证</li><li>在用户退出登录或 Session 失效时，需要将Redis 中对应的Session 数据删除</li></ol><p>可以使用Redis 的EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的Session数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的Session ID等方式来提高安全性</p><h2 id="MySQL-支持哪些存储引擎？默认使用哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？"></a>MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？</h2><p>MySQL 支持多种存储引擎，包括 InnoDB ，M有ISAM，MEMORY，CSV 等。默认情况下，MySQL 使用的存储引擎是 InnoDB</p><p>MyISAM 和 InnoDB 是 MySQL 中 <strong>最常用</strong> 的两种存储引擎，它们有以下区别：</p><ol><li>锁定方式不同：MyISAM 使用表级锁定，而 InnoDB 使用行级锁定。在并发访问时，InnoDB 的锁定方式更加精确，可以避免锁定整个表，提高了并发性能</li><li>数据完整性不同：MyISAM 不支持事务和外键约束，而InnoDB 支持事务和外键约束，可以保证数据的完整性和一致性</li><li>读写性能不同：MyISAM 的读写性能相对较高，适合于读密集型应用；而 InnoDB 的写性能相对较高，适合于写密集型应用</li><li>空间利用率不同：MyISAM 不支持行级别的存储，存储空间利用率较低；而InnoDB 支持行级别的存储，存储空间利用率更高。</li></ol><p>在选择MyISAM 和 InnoDB 引擎时，需要考虑应用场景和需求：</p><ol><li>如果应用主要是读操作，可以考虑选择MyISAM 引擎，以提高读取性能</li><li>如果应用主要是写操作或需要支持事务和外键约束，可以考虑选择 InnoDB 引擎，以保证数据的完整性和一致性。</li><li>如果需要高性能和高可用性，可以考虑使用MyISAM 集群或使用多个副本实例，并将数据分布在不同节点上</li></ol><p>总结：MyISAM 支持多种存储引擎，MyISAM 和 InnoDB 是其中最常用的两种，它们有不同的特点和优缺点，在选择时需要根据应用场景和需求进行考虑和权衡。</p><h2 id="Spring-中的-BeanFactory-和-ApplicationContext-有什么区别和联系？"><a href="#Spring-中的-BeanFactory-和-ApplicationContext-有什么区别和联系？" class="headerlink" title="Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？"></a>Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？</h2><p>在 Spring 中，BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，它们区别和联系如下。</p><p>区别：</p><ol><li>BeanFactory 是 Spring 框架的基础设施，用于管理Bean 的生命周期和依赖关系，提供了IoC 和 DI 功能。ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化，AOP支持。</li><li>BeanFactory 是延迟加载的，即只有在获取Bean 时才会进行实例化，可以减少系统资源的占用。而ApplicationContext 在启动时会立即加载所有的Bean，导致启动时间较长。</li><li>BeanFactory 是单例模式，即在整个应用中只有一个BeanFactory 实例。而ApplicationContext 可以有多个实例，并且可以通过父子容器的方式组织起来，方便模块化开发</li></ol><p>联系：</p><ol><li>BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，可以管理Bean 的生命周期和依赖关系，提供了IoC 和DI 功能</li><li>ApplicationContext 是BeanFactory 的扩展，提供了更多的功能，例如国际化支持，AOP支持等，同时也支持BeanFactory 的所有功能</li><li>BeanFactory 和 ApplicationContext 都可以通过 XML配置文件，Java注解和Java代码等方式进行配置和管理</li><li>BeanFactory 和 ApplicationContext 都可以管理单例Bean 和原型 Bean，可以控制Bean 的作用域和生命周期</li></ol><p>总结：BeanFactory 是 Spring 框架的基础设施，提供了IoC 和 DI 功能，而ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能和扩展性，可以通过多种方式进行配置和管理 Spring Bean</p><h2 id="讲一下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？"><a href="#讲一下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？" class="headerlink" title="讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？"></a>讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？</h2><p>Redis 是一种基于内存的键数据库，鱿鱼内存有限，当Redis 占用内存到达上限时，就需要进行内存淘汰，以腾出一些内存空间</p><p>Redis 中的内存淘汰机制包括：</p><ol><li>定期删除：Redis 可以设置一个定时器，定期扫描空间中的键，并删除已经过期的键</li><li>惰性删除：当一个键过期时，Redis不会立刻删除该键，而是等到该键被访问时再删除</li><li>内存淘汰测略：当Redis 内存占用达到上限时，会根据内存淘汰测略来选择一些键进行删除，以腾出更多的内存空间</li></ol><p>Redis 中的内存淘汰测略包括：</p><ol><li>不删除 key ，当到达最大阈值后报错 ：<strong>noeviction</strong></li><li>设过期 key 中选择使用数最小的 ：<strong>volatile - lrw</strong></li><li>在所有 key 中选择使用数最小的 ：<strong>allkeys - lru</strong></li><li>过期 key 中使用 lfu 算法 ：<strong>volatile - lfu</strong></li><li>所有 key 用 lfu 算法 ：<strong>allkeys - lfu</strong></li><li>过期 key 随机删除 ：<strong>volatile - random</strong></li><li>所有 key 碎甲删除 ：<strong>allkeys - random</strong></li><li>过期 key 中最早过期的删除 : <strong>volatile - ttl</strong></li></ol><p><strong>lru：最近最少使用，实现方式：使用一个链表，被使用就放到表头，其他后推，超过表尾的就删除</strong> </p><p>lfu：最近最不经常使用，实现方式：使用一个计数器</p><p>其中，noeviction 策略是最简单的策略，但可能会导致Redis 内存占满，并导致 Redis 无法正常工作。其他策略会根据不同算法进行键的选择和删除，以尽可能保留重要的键</p><p>总之，Redis 中的内存淘汰机制是保证 Redis 正常运行的重要机制之一，内存淘汰策略则根据不同的场景选择合适的策略来删除不必要的键，以腾出更多的内存空间</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题1</title>
      <link href="/2023/03/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
      <url>/2023/03/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-和-JRE-和-JVM-分别是什么，有什么区别？"><a href="#JDK-和-JRE-和-JVM-分别是什么，有什么区别？" class="headerlink" title="JDK 和 JRE 和 JVM 分别是什么，有什么区别？"></a>JDK 和 JRE 和 JVM 分别是什么，有什么区别？</h2><p>1，**JDK (Java Development Kit)**：JDK是Java开发工具包，包含了编写，编译，调试和运行java程序所需要的所有工具和组件，比如编译器（javac），javaAPI，调用工具等。JDK是针对Java开发人员的，它包含JRE，还有一编译器和其他工具，可以用来编写和调试Java程序。</p><p>2，**JRE (Java Runtime Environment)**：JRE是java运行时环境，包括了Java虚拟机（JVM）和Java标准类库（JavaAPI）JRE是争对Java应用程序的，它提供了在计算机上运行的Java应用程序所需的最小环境。</p><p>3，**JVM (Java Virtual Machine)**：JVM是Java虚拟机，是Java程序运行的环境。JVM负责将java代码解释或编译为本地机器代码，并在运行时提供必要的环境支持，比如内存管理，垃圾回收，安全新等。JVM的主要作用时将Java代码转化为可以在计算机上运行的机器码，并负责程序的执行。</p><p>综上所述，JDK，JRE和JVM在区别上可以总结如下：</p><p><strong>JDK时Java开发工具包</strong>，包括了编译器，JavaAPI，调试工具等，用于Java开发应用程序</p><p><strong>JRE是Java运行时环境</strong>，包括了Java虚拟机和Java标准类库，用于在计算机上运行Java应用程序</p><p><strong>JVM是Java虚拟机</strong>，是Java程序运行的环境，负责将java代码转换为可以在计算机上运行的机器码，并提供必要的环境支持</p><h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>字节码是Java程序编译后的中间代码，是一种可移植的二进制代码，可以在任何支持Java虚拟机（JVM）的平台上运行。字节码通过Java源代码编译为字节码指令序列，使得Java程序可以跨平台运行，即使在不同的操作系统和硬件平台上也可以运行。</p><p>字节码采用中间代码的形式，相比于直接将程序编译为特定平台上的机器码，有以下几个好处</p><ol><li>可移植性：由于字节码是中间代码，所以可以在任何支持JVM的平台上运行，使得Java程序具有很好的可移植性。这也是Java跨平台的重要特征之一。</li><li>安全性：由于字节码需要在JVM中运行，所以可以对字节码进行安全检查，以确定程序不会对系统造成威胁。</li><li>性能：由于字节码是一种紧凑的二进制格式，相比于直接编译为机器码，可以更快速的加载和传输，同时也可以在运行时动态优化，提高程序的执行效率。</li><li>可读性：相比于直接编译为机器码，字节码具有更好的可读性，可以方便的进行反汇编和调试</li></ol><p>因此，采用字节码作为中间代码的最大好处是提高了Java程序的可移植性，安全性，性能和可读性。这也是Java跨平台和安全性的基础</p><h2 id="什么是数据库事务？讲一下事务的-ACID-特性？"><a href="#什么是数据库事务？讲一下事务的-ACID-特性？" class="headerlink" title="什么是数据库事务？讲一下事务的 ACID 特性？"></a>什么是数据库事务？讲一下事务的 ACID 特性？</h2><p>数据库事务是指数据库管理系统DBMS中的一个操作序列，这些操作必须作为一个不可分割的单元执行，要么全部执行成功，要么全部失败回滚。事务通常涉及到对数据库中的数据进行读写操作。</p><p>事务的ACID特性是指其四个关键特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）</p><ol><li>原子性：事务是一个原子操作，要么全部提交，要么全部回滚。当一个事务执行期间发生故障，操作系统便会自动将其回滚到事务执行之前的状态，保证数据的一致性。</li><li>一致性：事务执行结束后，数据必须保持一致的状态。在事务执行期间，数据库的数据可以处于中间状态，但是在事务完成时必须保持数据的一致性。</li><li>隔离性：数据库系统必须保证事务之间的相互隔离，不会相互干扰。隔离级别不同，会影响事务的并发性和一致性，比如出现脏读，不可重复读，幻读等。</li><li>持久性：一旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发生故障或者宕机，数据也能够保持不变。</li></ol><p>ACID特性是保证事务正确性和数据一致性的重要手段。在设计数据库应用程序时，应该根据具体的业务需求和数据库安全性要求，选择合适的隔离级别和事务提交策略，保证事务的可靠性和数据的一致性。</p><h2 id="Java-和-C-、Go-语言的区别，各自的优缺点？"><a href="#Java-和-C-、Go-语言的区别，各自的优缺点？" class="headerlink" title="Java 和 C++、Go 语言的区别，各自的优缺点？"></a>Java 和 C++、Go 语言的区别，各自的优缺点？</h2><p><strong>Java是一种面向对象的编程语言</strong>，醉蛛被设计用于开发嵌入式系统，现在广泛应用于企业应用，Web应用和移动应用开发等领域。Java优点包括：</p><ol><li>跨平台性强：Java虚拟机（JVM）可以在不同操作系统上运行java程序，使得开发者可以编写一次代码并在多个平台上运行</li><li>安全性高：Java有很多安全特征，例如自动内存管理，类的访问权限控制，异常处理等，可以有效避免一些常见安全漏洞</li><li>生态系统完备：Java的生态系统非常完善，有很多成熟的框架和工具可以帮助开发者快速构建复杂的应用</li></ol><p><strong>C++是一种系统级编程语言</strong>，最初设计用于操作系统和系统软件的开发，现在也广泛用于游戏，图形图像处理，嵌入式系统等领域。C++的优点包括：</p><ol><li>新能高：C++是一种编译型语言，可以生成高效的机器代码，所以在处理大量数据和对计算效率又要求的应用场合下具有优势</li><li>控制能力强：C++具有非常高的控制能力，可以直接操作计算机的硬件和内存等资源</li><li>应用领域广泛：C++适用于开发大型系统，高性能应用和底层软件，如操作系统，数据库，游戏引擎等</li></ol><p><strong>Go是一种开源的编程语言</strong>，由Google公司开发，被设计用于开发高并发，分布式系统。Go的优点包括：</p><ol><li>并发能力强：Go具有轻量级的线程（goroutine）基于消息传递的通道（channel），可以方便地实现并发编程</li><li>内存管理高效：Go的内存管理采用自动垃圾回收装置，使得开发者可以更加专注于业务逻辑</li><li>语言特性简单：Go的语法简单易懂，代码易于阅读和维护，同时提供了丰富的标准库和工具支持</li></ol><h2 id="什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？"><a href="#什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？" class="headerlink" title="什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？"></a>什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？</h2><p>Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，也被称为数据结构等服务。它支持多种类型的数据结构，如字符串，哈希，列表，集合，有序集合等，并提供了丰富的操作这些数据结构的命令。</p><p>Redis的特点包括：</p><ol><li>高性能：Redis使用内存来存储数据，并且数据存储在单一进程中，因此速度非常快</li><li>多样的数据类型：Redis支持多种数据结构，包括字符串，哈希，列表，集合，有序集合等。</li><li>持久化：Redis支持多种持久化方式，包括RDB快照和AOF日志</li><li>分布式：Redis支持分布式部署，可以将数据分布在多个节点上</li><li>简单易用：Redis提供了丰富的命令，使得操作数据非常方便</li></ol><p>Redis的常见应用场景包括：</p><ol><li>缓存：Redis可以作为缓存使用，加速数据读取和响应速度</li><li>消息队列：Redis提供了列表和发布&#x2F;订阅功能，可以用来实现消息队列</li><li>计算器：Redis的计算器功能非常高效，可以用来实现页面访问量，点击量等的·计数</li><li>排行榜：Redis的有序集合功能可以用来实现排行榜</li><li>分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问</li><li>实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析的速度</li></ol><p>总之，Redis具有高性能，多样的数据类型，分布式，简单易懂等特点，可以应用于各种场景，特别适合用于解决读写频繁的问题</p><h2 id="简述计算机网络七层模型和各自的作用？"><a href="#简述计算机网络七层模型和各自的作用？" class="headerlink" title="简述计算机网络七层模型和各自的作用？"></a>简述计算机网络七层模型和各自的作用？</h2><p>计算机网路七层模型是一个把网络通信协议分为七个层次的标准模型，其目的是为了让计算机网络的设计和管理更加灵活和模块化。这个模型被称为OSI模型（Open System Interconnection Model）,它由国际标准话组织（ISO）于1984年发布，是一个开放的标准模型。</p><p>每个层次都有自己独立功能和责任，这种分层的方式使得每个层次都可以独立工作，同时还能够很好地协调上下层之间的数据传输，而不需要依赖于其他层次的实现细节。以下是每个层的具体功能和责任：</p><ol><li>物理层：主要负责通过物理媒介传输比特流，如光纤，电缆，无线电波等。物理层规定了物理连接的规范，包括电缆类型，接口规范等</li><li>数据链路层：主要负责把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配，数据流量控制，错误校验等</li><li>网络层：主要负责数据在网络中的传输，包括路由选择，分组转发，数据报文的封装等。网络层还处理数据包的寻址和控制流量等</li><li>传输层：主要负责数据传输的可靠性和流量控制等，同时还包括分段，组装，连接建立和断开等功能。传输层最重要的两个协议是TCP和UDP</li><li>会话层：主要负责建立，管理和终止会话，提供会话控制和同步等服务。会话层层还负责处理多个应用程序之间的数据交换。</li><li>表示层：主要负责数据格式转换，加密解密，压缩解压等服务。表示层使得应用程序可以使用不同数格式和编码，同时还提供数据的安全性和完整的保护服务</li><li>应用层：主要提供各种服务和应用程序，如电子邮件，文件传输，远程登录，Web浏览等，应用层服务可以使用不同协议实现，如HTTP，SMTP，FTP，TELNET等</li></ol><p>现在较为常用的是TCP&#x2F;IP模型，它包含四层：应用层，传输层，网路层和数据链路层。</p><h2 id="JDK-动态代理和-CGLIB-动态代理的区别是什么？"><a href="#JDK-动态代理和-CGLIB-动态代理的区别是什么？" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理的区别是什么？"></a>JDK 动态代理和 CGLIB 动态代理的区别是什么？</h2><p>JDK动态代理和CGLIB动态代理都是Java中动态代理的两种实现方式，它们的区别主要在以下几个方面：</p><ol><li>实现方式：JDK动态代理是通过<strong>反射</strong>实现的，而CGBIL动态代理是通过<strong>继承目标类</strong>来实现的</li><li>目标类限制：JDK动态代理要求目标类必须<strong>实现接口</strong>，而CGBIL动态代理没有这个限制</li><li>性能：JDK动态代理相对于CGBIL动态代理来说，因为实现方式的不同，生成的代理效率会低一些</li><li>对象类型：JDK动态代理只能代理实现了接口的类，而CGBIL动态代理可以代理任何类</li><li>依赖库：JDK动态代理是Java自带的库，不需要额外的依赖，而CGBIL动态代理需要依赖cglib库</li></ol><p>在使用动态代理时，可以根据需要和具体场景选择合适的实现方式，JDK动态代理适用于接口代理的场景，而CGBIL动态代理适用于类代理场景</p><h2 id="MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用"><a href="#MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用" class="headerlink" title="MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用"></a>MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用</h2><p>MySQL是一款流行的关系型数据库，其日志是关键功能之一。MySQL包括三种类型的日志：binlog，redolog和undolog，它们分别有各自的作用和特点。</p><ol><li>binlog（Binary log）：MySQL种的二进制日志文件，用于记录MySQL服务器上所有的更新和修改操作。它可以记录所有的DDL（Data Definition Language）和DML（Data Modification Language）操作，包括对表结构的更改，数据的插入，修改，删除等等。binlog是在事务提交后生成的，因此可以用于恢复数据库。</li><li>redolog（Redo log）：用于恢复数据，保证数据的一致性和持久性。当MySQL发生修改时，redolog会将这些操作记录下来，并写入磁盘。这样，当MySQL发生宕机或崩溃时，通过redolog就可以回复数据。</li><li>undolog（Undo log）：用于回滚操作，当MySQL发生事务回滚时，undolog会记录这些操作并写入磁盘。这样，当MySQL需要回滚时，通过重放undolog就可以回滚事务。</li></ol><p>区别：</p><p>​binlog和redolog都是MySQL中的二进制日志，但是它们的作用和实现方式有所不同。binlog是MySQL操作的记录日志，而redolog是保证数据一致性和持久性的日志。此外，binlog是逻辑日志，redolog是物理日志。binlog可以跨平台使用，而eredolog不行。undolog和redolog区别是：undolog用于回滚操作，redolog用于回复数据。</p><h2 id="Spring-框架是什么？使用-Spring-框架有哪些好处？"><a href="#Spring-框架是什么？使用-Spring-框架有哪些好处？" class="headerlink" title="Spring 框架是什么？使用 Spring 框架有哪些好处？"></a>Spring 框架是什么？使用 Spring 框架有哪些好处？</h2><p>Spring框架是一个开源的Java企业应用程序框架，它通过依赖注入（DI：Dependency Injection）和面向切面编程（Aspect Oriented Proframming）等技术为开发者提供了一个全面的编程和配置模型。它可以降低Java开发的复杂度，提高代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。</p><p>使用Spring框架有以下好处：</p><ol><li>依赖注入（DI）：通过Spring框架的依赖注入功能，开发者可以将应用程序中的不同组件之间的依赖关系交给Spring来管理，从而降低组件之间的耦合度，并方便后续的组件替换和维护。</li><li>支持切面编程（AOP：Aspect Oriented Programming）：Spring框架提供了面向切面编程的支持，可以将不同组件关联起来，从而降低了应用程序中的重复代码量，并提高了代码的可重用性和可维护性。</li><li>提供了多种技术整合方案：Spring框架可以与其他的Java企业引用程序框架和技术进行整合，如Hibernate，Mybatis，Struts，JSF等，从而降低了技术整合的复杂度</li><li>支持声明式事务管理：Spring框架提供了声明事务管理的支持，开发者可以通过配置来管理应用程序中的事务，从而简化了事务管理的过程。</li><li>提供了Ioc容器：Spring框架提供了一个Ioc容器，可以实现对应程序的不同组件进行管理，并支持对组件进行AOP增强，从而实现了应用程序中的组件解耦和高度可配置性。</li><li>便于配置：Spring框架可以方便的进行单元测试和集成测试，提高了代码的可测试性和可靠性</li></ol><h2 id="Java-中-final-关键字有什么用"><a href="#Java-中-final-关键字有什么用" class="headerlink" title="Java 中 final 关键字有什么用"></a>Java 中 final 关键字有什么用</h2><p>在Java中，final关键字用于表示一个不可变的常量或一个不可变的变量，final关键字开源修饰类、方法和变量</p><ol><li>final修饰类，表示该类不能被继承。final类中的方法都是默认final，不能被子类重写</li><li>final修饰方法，表示该方法不能被子类重写</li><li>final修饰变量，表示该变量只能被赋予一次。final修饰的变量必须在申明时或构造函数中初始化，且不能再被改变。常用于定义变量。</li></ol><p>除此之外，使用final修饰的变量在编译时就确定了其值，因此在运行时访问比非final变量更快</p><p>使用final关键字可以带来的好处：</p><ol><li>安全性：将变量声明为final可以防止它被改变，从而提高安全性</li><li>可读性：将常量声明为final可以提高代码的可读性，因为常量的值不会被改变</li><li>优化：final变量在编译时被转变为常量，这可以提高程序的性能</li></ol><h2 id="HTTP-是哪一层的协议？简述它的作用？"><a href="#HTTP-是哪一层的协议？简述它的作用？" class="headerlink" title="HTTP 是哪一层的协议？简述它的作用？"></a>HTTP 是哪一层的协议？简述它的作用？</h2><p>HTTP是应用层协议，主要用于Web浏览器和Web服务器之间的传递数据。它是一种无状态的协议，即服务器不会保存关于客户端的任何信息，每次客户端发送请求，服务器都会返回响应。HTTP协议通常基于TCP协议，使用TCP的80端口作为默认的传输端口。HTTP协议主要作用包括：</p><ol><li>建立连接：客户端与服务器建立TCP链接，然后发送HTTP请求，服务器接收请求并处理</li><li>发送请求：客户端发送HTTP请求到服务器，包括请求方法（GET，POST，PUT等），请求头（如User-Agent，Accept等）和请求正文（可选）等信息。</li><li>请求处理：服务器接收并解析HTTP请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端</li><li>返回响应：服务器返回HTTP响应，包括响应状态码（如200 OK，404 Not Found等），响应头（如Content-Type,Cache_Control等）和响应正文（可选）等信息。</li><li>关闭连接：客户端接收到响应后，关闭TCP连接</li></ol><p>HTTP的响应报文主要包括以下几个部分：</p><ol><li>状态行：包含HTTP协议版本，状态码和状态消息。</li><li>响应头：包含一些响应头部信息，例如Server，Control-Type，Content_Length等</li><li>空行：表示响应头结束</li><li>响应体：实际响应数据，例如网页的HTML代码，图片，音频等。</li></ol><p>HTTP的状态码指示了服务器对请求的处理结果。常见的状态码包括200 OK（请求成功），301 MovedPermanently（永久重定向），404 Not Found（未找到资源）和500 Internal Server Error（服务器内部错误）等</p><p>总之，HTTP协议的作用是规定了Web应用程序中客户端和服务器之间的通讯方式和数据传输格式，是支持Web应用开发的基础协议。</p><h2 id="什么是进程和线程？它们有哪些区别和联系？"><a href="#什么是进程和线程？它们有哪些区别和联系？" class="headerlink" title="什么是进程和线程？它们有哪些区别和联系？"></a>什么是进程和线程？它们有哪些区别和联系？</h2><p>在操作系统中，<strong>进程是指一个正在执行的程序</strong>，而<strong>线程是进程的一部分，是一个程序中执行的代码片段</strong></p><p><strong>进程是操作系统资源分配的最小单位</strong>，一个进程至少包括一个线程，进程拥有自己的内存空间，文件句柄，环境变量等资源系统。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通讯需要通过进程间通信机制（IPC）来实现</p><p><strong>线程是程序执行的最小单位</strong>，一个进程中可以包含多个线程，它们共享进程的内存空间和资源系统。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通讯可以通过共享内存，信号量等机制实现</p><p>进程与线程的区别与联系如下：</p><ol><li>资源分配：进程拥有自己的内存空间等系统资源，而是线程共享进程的资源</li><li>独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源</li><li>调度：进程间调度开销比线程大，线程调度开销小，可以并发执行</li><li>并发性：多个进程之间相互独立，多个线程可以并发执行</li><li>同步：进程间通讯需要通过IPC机制，线程间同步可以通过共享内存，信号量等机制实现、</li></ol><p>实际开发中，多线程应用更加常见，因为线程开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。</p><h2 id="Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？"><a href="#Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？" class="headerlink" title="Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？"></a>Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？</h2><p>在Java中mhashCode和equals方法都是Object类的方法。它们作用如下：</p><p>hashCode方法返回对象的哈希码，用于支持基于哈希表的集合，如HashMap，HashSet等。如果两个对象的equals方法返回true，则它们的hashCode方法必然返回相同的值，反之则不必然</p><p>equals方法用于比较对象是否相等。默认情况下，equals方法使用的是 &#x3D;&#x3D; 操作符，即只有两个对象引用指向同一个对象时才会返回true。但是，大部分情况下，我们需要重写equals方法来实现自己定义的相等规则。</p><p>两者之间的区别在于hashCode方法返回的是一个int类型的数值，而equals方法返回的是一个boolean类型的值。</p><p>hashCode方法用于快速比较两个对象是否不同，毕竟如果哈希码不同，那么它们肯定不相等。equals方法用于判断两个对象是否真正相等，这个判断比较复杂，需要根据对象的实际情况来定义</p><p>另外，需要注意的是， &#x3D;&#x3D; 操作符用于比较两个对象的引用是否相等，即它们是否指向同一个对象，而equals方法则用于比较两个对象的值是否相等</p><p>在Java中，对象值的比较往往需要更具对象实际情况来定义，因此一般需要重写equals方法</p><h2 id="Spring-的两大核心概念是什么？简单讲一下你对它们的理解"><a href="#Spring-的两大核心概念是什么？简单讲一下你对它们的理解" class="headerlink" title="Spring 的两大核心概念是什么？简单讲一下你对它们的理解"></a>Spring 的两大核心概念是什么？简单讲一下你对它们的理解</h2><p>Spring 框架的两大核心概念是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）</p><p><strong>控制反转</strong>指的是将对象的创建和依赖注入由应用代码转移到Spring容器中进行，即由Spring容器负责创建对象和管理它们之间的依赖关系。这样，应用代码只需要关注业务逻辑的实现，而不是关注对象的创建和管理，降低了应用代码的复杂度，提高了代码的可重用性和可维护性。</p><p><strong>面向切面编程</strong>是指将业务逻辑无关的代码（如日志，安全，事务等）从业务逻辑中剥离出来，以便于统一管理和维护。通过AOP，我们可以将这些业务逻辑无关的横切关注点（Cross-cutting Concerns）定义切面（Aspect），并将它们织入到业务逻辑中，从而实现了业务逻辑与横切关注点的解耦</p><p>这两个概念是Spring框架的核心，它们使得Spring框架具有了高度的可用性，灵活性和模块性，极大的提高了应用程序的开发效率和代码的可维护性</p><h2 id="死锁是什么？如何预防和避免死锁？"><a href="#死锁是什么？如何预防和避免死锁？" class="headerlink" title="死锁是什么？如何预防和避免死锁？"></a>死锁是什么？如何预防和避免死锁？</h2><p>死锁是指两个或多个进程在执行过程中因争夺资源而造成的一种僵局，当进程处于死锁状态时，它们将无法继续执行，而只能相互等待，直到被外部程序干预或者自行放弃。</p><p>预防和避免死锁需要采取一些措施，包括：</p><ol><li><strong>避免资源独占</strong>：尽量避免一个进程在获得了某些资源后再次请求其他资源，而采取应用所需资源一次性申请到位。</li><li><strong>避免资源持有和等待</strong>：当一个进程占用了一些资源并等待另一些资源时，其他进程就无法使用这些资源，容易发送死锁。因此，尽可能减少资源的持有和等待时间。</li><li><strong>避免资源互斥</strong>：有些资源在同一时间只能被一个进程占用，比如打印机，磁带机等，需要采用一些技术手段来避免资源的互斥问题。</li><li><strong>引入资源掠夺策略</strong>：当一个进程请求的资源被其他进程占用时，可以采取掠夺资源的策略，即暂停占用该资源的进程，直到该资源被释放后再恢复该进程的执行。</li><li><strong>引入进程抢占策略</strong>：当一个进程等待时间过长时，可以采取抢占其他资源的策略，即终端正在执行的进程，强制释放其占用的资源</li></ol><p>以上是一些避免和预防死锁的方法，具体选择哪种方法需要根据具体情况进行分析和判断。</p><h2 id="什么是反射机制？说说反射机制的优缺点、应用场景？"><a href="#什么是反射机制？说说反射机制的优缺点、应用场景？" class="headerlink" title="什么是反射机制？说说反射机制的优缺点、应用场景？"></a>什么是反射机制？说说反射机制的优缺点、应用场景？</h2><p>Java反射机制是指在运行时动态的获取了类的信息、创建对象以及调用对象的属性和方法的机制。Java反射机制提供了运行时检查Java类信息的能力，让Java程序可以通过程序获取其本身的信息。</p><p>Java反射机制的优点：</p><ol><li>可以动态的获取类的信息，不需要在编译时就知道类的信息</li><li>可以动态的创建对象，不需要在编译时就知道对象的类型</li><li>可以动态的调用对象的属性和方法，可以在运行时动态的改变对象的行为</li></ol><p>Java反射机制的缺点：</p><ol><li>由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性</li><li>由于反射是动态的，所以它会破坏Java的封装性，可能会使代码变得复杂和不稳定</li></ol><p>Java反射机制的应用场景：</p><ol><li>动态代理。动态代理可以使用反射机制在运行时动态的创建代理对象，而不需要在编译时就知道接口的实现类</li><li>单元测试。JUnit等单元测试框架可以使用在反射机制在运行时动态的获取类的方法信息，实现自动化测试</li><li>配置文件加载。许多框架（如Spring）使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。</li></ol><h2 id="数据库索引是什么，有什么作用，什么场景适合使用索引？"><a href="#数据库索引是什么，有什么作用，什么场景适合使用索引？" class="headerlink" title="数据库索引是什么，有什么作用，什么场景适合使用索引？"></a>数据库索引是什么，有什么作用，什么场景适合使用索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大的提高数据检索的效率。</p><p>索引的作用是通过构建一个额外的数据结构（B-tree，哈希表等）来加速数据的检索。它是在数据库表上查询的一种数据结构，它包含一些指向表中数据的指针，可以快速定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列缩影，组合缩影，全文索引等待多种方式来创建</p><p>适合使用索引的场景包括：</p><ol><li>频繁查询的列，如主键，外键等。</li><li>经常作为查询条件的列，如WHERE，ORDER BY，GROUP BY等语句中的列。</li><li>经常需要连接的列，如多表联合查询时的列</li><li>数据量较大的表，通过索引可以加快数据的检索速度</li></ol><p>索引的优点是可以提高数据库的查询速度，缩短数据检索的时间，提高系统的性能。但是索引也有缺点：</p><ol><li>占用额外的存储空间，增加了存储成本</li><li>建立索引需要时间，增加了系统的开销</li><li>数据库的更新操作（增删改）会导致索引的重建，避免过度索引导致系统性能下降</li></ol><h2 id="HTTP-有哪些常见的状态码？"><a href="#HTTP-有哪些常见的状态码？" class="headerlink" title="HTTP 有哪些常见的状态码？"></a>HTTP 有哪些常见的状态码？</h2><p>HTTP（超文本传输协议）常见的状态码有以下几种：</p><ul><li><p>1XX（信息类状态码）：指示已经收到请求，正在继续处理</p></li><li><p>2XX（成功状态码）：请求已经被接收，理解和接受</p><ul><li>200 OK：请求已经成功处理</li><li>201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li><li>204 No Content：服务器依据成功处理了请求，但是没有返回任何实体内容</li></ul></li><li><p>3XX（重定向状态码）：需要镜像附加操作以完成请求</p><ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客服端发送了一个带条件的请求，服务器允许请求访问资源，但是请求为满足条件</li></ul></li><li><p>4XX（客户端错误状态码）：请求包含错误语法或不能被执行</p><ul><li>400 Bad Request：请求报文存在语法错误</li><li>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在。</li></ul></li><li><p>5XX（服务器错误状态码）：服务器在处理请求的过程中发生了错误</p><ul><li>500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。</li><li>502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效请求。</li><li>503 Service Unavailable：服务器暂时处于超负荷或正在停机维护，无法处理请求</li></ul></li></ul><p>状态码是服务器读客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理</p><h2 id="访问修饰符-public、private、protected，以及无修饰符（默认）时的区别"><a href="#访问修饰符-public、private、protected，以及无修饰符（默认）时的区别" class="headerlink" title="访问修饰符 public、private、protected，以及无修饰符（默认）时的区别"></a>访问修饰符 public、private、protected，以及无修饰符（默认）时的区别</h2><p>在Java中，访问修饰符指的是控制类，接口，方法，属性等成员的访问范围。Java提供了四种访问修饰符，分别是public，private，protected和默认（无修饰符）</p><ul><li>public：可以被任何类或对象访问</li><li>private：只能被定义该成员的类访问，其他类无法访问</li><li>protected：可以被当前类，子类和同一个包中的类访问</li><li>默认（无修饰符）：可以被同一个包中的类访问</li></ul><p>各个修饰符的特点：</p><ul><li>public可以被任何类或对象访问，因此其访问范围最大，但也可能会存在安全问题。</li><li>private限制了访问范围，可以有效保护数据的安全，但是可能会增加代码的耦合度</li><li>protected提供了一种在继承中使用的访问控制方式，但是可能会导致模块间的耦合</li><li>默认（无修饰符）访问范围比protected更小，只能被同一个包中的类访问，可以减小模块间的耦合</li></ul><p>访问修饰符的选择需要根据具体情况来考虑，不能一概而论。通常情况下，应该尽可能的将成员设置为private，只在需要的情况下使用 public 或 protected</p><p>在同一个类中，成员可以直接访问其他成员，无论其访问修饰符是什么</p><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p>线程间通信是多线程编程中非常重要的一个概念。在多线程编程中，有时候需要让线程之间进行数据交换，协作工作。以下是几种线程间的通信方式：</p><ol><li>共享内存：线程之间通过访问同一块共享内存区域来实现数据交换</li><li>消息队列：一个线程向消息队列中放入一条消息，另一个线程从消息队列中取出消息。</li><li>管道（Pipe）：管道是一种半双工的通信方式，一个进程可以向管道中写入数据，另一个进程可以从管道中读取数据</li><li>信号（Signal）：信号是一种异步通信的方式，进程收到信号后，会根据信号的类型做出相应的处理</li><li>互斥锁（Mutex）：用于同步访问共享资源，防止多个线程同时访问共享资源，产生冲突</li><li>条件变量（Condition Variable）：用于线程之间的协调和通信，一个线程可以通过条件变量等待某个·条件的出现，另一个线程可以通过条件变量通知正在等待的线程</li></ol><h2 id="什么是分布式？为什么需要分布式？"><a href="#什么是分布式？为什么需要分布式？" class="headerlink" title="什么是分布式？为什么需要分布式？"></a>什么是分布式？为什么需要分布式？</h2><p>分布式是指在堕胎计算机上协同完成工作的系统，这些计算机通过网络连接在一起，共同完成一个任务。</p><p>分布式系统能够有效解决单台计算机处理能力不足，系统容易宕机，数据存储容量有限等问题，同时能够提高系统的可靠性，可用性和性能，适用于数据量较大，并发量高，访问平凡的场景。此外，分布式系统还可以通过横向扩展的方式提高系统的性能和可靠性，同时降低单点故障的风险，提高了系统的可伸缩性，方便进行升级和维护。</p><p>在分布式系统中，由于数据和计算任务被分布在多台计算器上，不同计算机之间需要进行通信和协调，因此需要解决分布式一致性，负载均衡，故障回复，数据共享和安全等问题，同时需要考虑数据的一致性和可靠性。因此，分布式系统的设计和实现比单机系统更加复杂和困难，需要考虑到多个因素的综合影响。</p><h2 id="你是怎么做-MySQL-数据备份的？比如怎么恢复半个月前的数据？"><a href="#你是怎么做-MySQL-数据备份的？比如怎么恢复半个月前的数据？" class="headerlink" title="你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？"></a>你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？</h2><p>MySQL数据备份是一个非常重要的工作，保证数据的安全性和可靠性。</p><p><strong>备份数据库文件：</strong></p><p>使用mysqldump工具来备份MySQL数据库，该工具可以生成SQL脚本文件，包含数据库中所有表和数据的语句。在终端中运行以下命令：</p><pre><code class="mysql">mysqldump -u [username] -p [password] --[database_name] &gt; [backup_file].sql// [username]:MySQL用户名// [password]:密码// [database_name]:需要备份的数据库名称// [backup_file]:备份的文件名</code></pre><p>该命令会将SQL脚本文件导出到当前目录下。</p><p><strong>回复MySQL数据库：</strong></p><pre><code class="mysql">mysql -u [username] -p [password] --[database_name] &lt; [backup_file].sql// [username]:MySQL用户名// [password]:密码// [database_name]:需要恢复的数据库名称// [backup_file]:备份的文件名</code></pre><p>该命令会将备份文件中的SQL语句执行，从而将数据恢复到指定的数据库中。</p><p>如果需要恢复半个月以上的数据，可以选择备份文件中的某个时间点之前的数据，并使用以上方法进行恢复</p><p>此外使用mysql自带的mysqlbinlog工具进行增量备份或者第三方备份软件进行备份。</p><h2 id="什么是消息队列？消息队列有哪些应用场景？"><a href="#什么是消息队列？消息队列有哪些应用场景？" class="headerlink" title="什么是消息队列？消息队列有哪些应用场景？"></a>什么是消息队列？消息队列有哪些应用场景？</h2><p>消息队列是一种异步通信机制，用于在应用程序之间传递消息。它可以将消息暂时存储在队列中，然后按照一定的顺序和条件将消息传递给消费者。</p><p>消息队列有以下几个主要应用场景：</p><ol><li>异步处理：通过将任务转换为消息，异步的进行处理，可以提高系统的吞吐量和响应速度</li><li>系统解耦：在不同的系统或模块之间使用消息队列进行通信，可以实现系统的解耦，提高系统的灵活性和可扩展性</li><li>流量控制：消息队列可以对消息进行缓存和限流，保证系统稳定性和高可用性</li><li>应用解耦：在同一个应用程序中，不同模块之间使用消息队列进行通信，可以实现模块之间的解耦，提高代码的可维护性</li><li>日志处理：通过将日志转换为消息，可以实现日志的异步处理，提高系统的性能和可维护性</li></ol><p>常见的消息队列包括：Kafka，Rabbit MQ，ActiveMQ，RocketMQ等</p><h2 id="设计模式是什么？为什么要学习和使用设计模式？"><a href="#设计模式是什么？为什么要学习和使用设计模式？" class="headerlink" title="设计模式是什么？为什么要学习和使用设计模式？"></a>设计模式是什么？为什么要学习和使用设计模式？</h2><p>设计模式是一套被反复使用，经过验证的，通用的解决特定问题的设计思想，是一种被设计师反复使用的技术方案</p><p>设计模式主要作用在于：</p><ol><li>提高代码的可维护性，可扩展性，可读性，提高代码的质量</li><li>通过共享经验，提高开发人员的设计能力，缩短学习时间，增强团队合作效率；</li><li>提高开发效率，缩短开发周期</li></ol><p>设计模式主要分为三大类：</p><ol><li>创建型模式：用于描述创建对象的方式</li><li>结构性模式：用于描述如何组合对象，形成更大的结构</li><li>行为型模式：用于描述对象之间的协作和职责分配。</li></ol><p>在具体的应用设计模式时，需要更具实际场所选用合适的设计模式。常用的设计模式包括单例模式，工厂模式，观察者模式，适配器模式，装饰器模式，策略模式。</p><h2 id="一条-SQL-语句在-MySQL-中的执行过程是怎样的？"><a href="#一条-SQL-语句在-MySQL-中的执行过程是怎样的？" class="headerlink" title="一条 SQL 语句在 MySQL 中的执行过程是怎样的？"></a>一条 SQL 语句在 MySQL 中的执行过程是怎样的？</h2><p>在MySQL中，一条SQL语句的执行过程通常可以分为以下几个步骤：</p><ol><li><strong>词法分析和语法分析</strong>：MySQL的SQL解析器会对输入的SQL语句进行词法分析和语法分析，以确定语句的结构和语法是否正确</li><li><strong>查询优化</strong>：MySQL会对SQL语句进行优化，以确定最优的执行计划。在这个过程中，MySQL会考虑许多因素，例如索引，表连接，统计信息等，以找到执行查询的最有效方式</li><li><strong>查询执行</strong>：在查询优化后，MySQL开始执行查询，读取和处理数据。在执行过程中，MySQL会根据查询中所涉及的表和列等信息，从磁盘中读取相应的数据，并进行计算和过滤操作。</li><li><strong>结果返回</strong>：最后，MySQL会将查询结果返回给客户端，完成整个查询过程</li></ol><p>需要注意的是：实际执行过程可能会应为多种因素而不同，例如数据量，硬件配置等。另外，在并发环境下，多个查询可能会同时进行，需要使用<strong>锁和事务</strong>等机制来保证数据的一致性和正确性。</p><h2 id="什么是-IOC，简单讲一下-Spring-IOC-的实现机制"><a href="#什么是-IOC，简单讲一下-Spring-IOC-的实现机制" class="headerlink" title="什么是 IOC，简单讲一下 Spring IOC 的实现机制"></a>什么是 IOC，简单讲一下 Spring IOC 的实现机制</h2><p>IOC（Inversion of Control），中文译为<strong>控制反转</strong>，是一种<strong>编程思想</strong>，它将程序中的对象的创建，组装，管理等控制权从代码中转移到框架中，实现了<strong>松耦合和可重用性</strong>的设计。</p><p>Spring IOC 是Spring 框架的一个核心特征，它实现机制主要包括以下几个步骤：</p><ol><li><strong>定义Bean</strong>：在Spring IOC 中，所有对象都被看做是 Bean，需要在配置文件或者使用注解的方式中进行定义和配置</li><li><strong>创建Bean工厂</strong>：在Spring中，Bean工厂负责管理Bean的创建，组装和销毁等任务。Spring IOC 容器就是Bean工厂的一种实现。</li><li><strong>读取配置文件</strong>：Spring IOC容器会读取配置文件或者使用注解的方式来获取 Bean 的定义和配置信息。</li><li><strong>创建Bean实例</strong>：Spring IOC 容器根据配置文件中的信息，使用反射技术来创建 Bean 实例，并将其保存在容器中。</li><li><strong>组装Bean</strong>：Spring IOC 容器根据配置文件中的信息，将不同的Bean实例组装起来，形成一个完整的应用程序</li><li><strong>注入依赖</strong>：Spring IOC 容器根据配置文件中的信息，自动为Bean注入依赖的对象或者值</li><li><strong>提供Bean实例</strong>：应用程序通过Spring IOC容器获取需要的Bean实例，从而使用其中的方法和属性等</li></ol><p>需要注意的是，Spring IOC还提供了多种作用域，例如单例，原型，会话，请求等作用域，可以根据具体的需求来选择。同时，Spring IOC容器也支持AOP，事务管理等功能，可以为应用程序提供更完整的服务。</p><h2 id="并发和并行有什么区别？同步和异步有什么区别？"><a href="#并发和并行有什么区别？同步和异步有什么区别？" class="headerlink" title="并发和并行有什么区别？同步和异步有什么区别？"></a>并发和并行有什么区别？同步和异步有什么区别？</h2><p>并发和并行是两个计算机领域经常被提到的概念：</p><ol><li><strong>并发</strong>（Concurrency）：指的是系统中同时存在多个正在执行的任务，并且这些任务之间可能会相互影响。并发通常用来处理多个任务共享资源的情况。在单核CPU上，多个任务会轮流使用CPU时间片，变现为看似同时执行的情况，但实际上只有一个任务在进行。</li><li><strong>并行</strong>（Parallelism）：指的是系统中同时存在多个并且相互独立的任务，并且这些任务可以在多个处理器上同时执行，真正意义上的同时处理多个任务</li><li><strong>同步</strong>（Synchronous）：指的是程序按照代码的执行顺序，一行一行的执行，知道当前执行完成后才能继续执行下一行。同步通常会阻塞调用者，直到任务完成才能返回。</li><li><strong>异步</strong>（Asynchronous）：指的是程序在执行某个任务时，不会一直等待任务完成，而是继续执行下一行代码，当任务完成后再进行相应的处理。异步通常不会阻塞调用者，可以提高系统的并发性能。</li></ol><p>总的来说，“并行”和“并发”是针对对各任务的执行方式。“同步”和“异步”是针对任务执行的阻塞方式和返回方式。在实际应用中，可以根据不同需求来选择合适的并发同步方式，以提高系统的性能和可靠性。</p><h2 id="String-和-StringBuffer、StringBuilder-的区别是什么？"><a href="#String-和-StringBuffer、StringBuilder-的区别是什么？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别是什么？"></a>String 和 StringBuffer、StringBuilder 的区别是什么？</h2><p>String 和 StringBuffer&#x2F;StringBuilder 是 Java中两种不同的字符串处理方式，主要区别在于String是不可变的（immutable）对象，而StringBuffer 和 StringBuilder 则是可变的（mutable）对象</p><p>String对象一旦被创建，就不可修改，任何的字符串操作都会返回一个新的 String 对象，这可能导致频繁的对象创建和销毁，影响性能。而StringBuffer和StringBuilder允许进行修改，提供了一种更加高效的字符串处理方式。</p><p>StringBuffer和StringBuilder的主要区别在于线程安全和性能方面。StringBuffer是线程安全的，所有方法都是同步的，因此可以被多个线程同时访问和修改。而StringBuilder不是线程安全的，适用于单线程环境下的字符处理，但是相比于StringBufer，StringBuilder具有更高性能。</p><p>因此，当字符串处理需要频繁修改时，建议使用StringBuffer或StringBuilder，而当字符串处理不需要修改时，可以使用String</p><h2 id="MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，为什么-MySQL-要用-B-树？"><a href="#MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，为什么-MySQL-要用-B-树？" class="headerlink" title="MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？"></a>MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？</h2><p>MySQL中的索引是通过B+树实现的。B+树是一种多叉树，它可以将数据按照一定的顺序组织起来，从而提高查询效率。</p><p>B+树和B树区别在于：B+树的所有数据都存储在叶子节点上，而非叶子节点只存储索引，这样可以提高数据查询效率。B+树的叶子节点之间使用指针相连，这样可以实现区间查找，也就是说，可以快速定位某个区间内的数据。</p><p>之所以使用B+树，是因为B+树有以下特点：</p><ol><li>能够支持高效的范围查找和排序</li><li>叶子节点之间使用指针相连，能够支持高效的区间查询</li><li>B+树具有较高的数据密度，可以减少磁盘I&#x2F;O次数，提高查询效率</li><li>B+树对于插入和删除操作也比较高效</li></ol><p>在MySQL中，B+树的实现主要是通过InnoDB存储引擎来实现的，InnoDB存储引擎中的索引主要有聚簇索引和辅助索引两种类型，聚簇索引是根据主键来创建的索引，而辅助索引是根据非主键列创建的索引，MySQL中会同时创建一个对应的聚簇索引，这样可以提高查询效率</p><h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><p>Spring框架中使用了许多设计模式，例如：</p><ol><li>单例模式：Spring的Bean默认是单例模式，通过Spring容器管理Bean的生命周期，保证每个Bean只被创建一次，并在整个应用程序中重用</li><li>工厂模式：Spring使用工厂模式通过BeanFactory和ApplicationContext 创建并管理Bean对象</li><li>代理模式：Spring AOP基于动态代理技术，使用代理模式实现切面编程，提供了对AOP编程支持</li><li>观察者模式： Spring中事件机制基于观察者模式，通过ApplicationEventPublisher发布事件，由ApplicationListener监听事件，将一些固定的流程封装在父类中，子类只需要实现一些抽象方法即可。</li><li>策略模式：Spring中HandlerInterceptor和HandlerExrcutionChain使用了策略模式，允许开发者自定义处理器拦截器，按照一定顺序执行</li><li>责任链模式：Spring中过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并作出相应的处理</li></ol><p>总之，Spring框架中充分利用了许多设计模式，提供了良好的扩展性和灵活性，降低了代码的耦合度，提高了代码的可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap方法总结</title>
      <link href="/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-方法总结"><a href="#HashMap-方法总结" class="headerlink" title="HashMap 方法总结"></a>HashMap 方法总结</h1><ul><li>HashMap继承关系</li><li>HashMap常见方法</li><li>HashMap全部方法简介</li></ul><h3 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p><p>HashMap 是无序的，即不会记录插入的顺序。</p><h3 id="HashMap常见方法"><a href="#HashMap常见方法" class="headerlink" title="HashMap常见方法"></a>HashMap常见方法</h3><h5 id="put-添加新的键值对"><a href="#put-添加新的键值对" class="headerlink" title="put - 添加新的键值对"></a>put - 添加新的键值对</h5><pre><code class="java">// 实例HashMap    public static HashMap&lt;Integer, String&gt; createItSHashMap() &#123;        HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(1,&quot;a&quot;);        hashMap.put(2,&quot;bcd&quot;);        hashMap.put(3,&quot;hello&quot;);        hashMap.put(4,&quot;IZONKUN&quot;);        hashMap.put(5,&quot;world&quot;);        hashMap.put(6,&quot;a&quot;);        return hashMap;    &#125;    public static HashMap&lt;String, String&gt; createStSHashMap() &#123;        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;fir&quot;,&quot;a&quot;);        hashMap.put(&quot;sec&quot;,&quot;b&quot;);        hashMap.put(&quot;the&quot;,&quot;c&quot;);        hashMap.put(&quot;fou&quot;,&quot;d&quot;);        hashMap.put(&quot;fiv&quot;,&quot;e&quot;);        hashMap.put(&quot;six&quot;,&quot;f&quot;);        return hashMap;    &#125;// 源码方法    public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;</code></pre><h5 id="containsKey-查看是否包含键"><a href="#containsKey-查看是否包含键" class="headerlink" title="containsKey - 查看是否包含键"></a>containsKey - 查看是否包含键</h5><pre><code class="java">// 输入参数：E Key是什么类型就输入什么类型public static void main(String[] args)&#123;    HashMap&lt;String,String&gt; arrayList = createStSHashMap();    System.out.println(arrayList.containsKey(&quot;fir&quot;));&#125;// 返回值 booleantrue// 源码方法    public boolean containsKey(Object key) &#123;    return getNode(hash(key), key) != null;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) &#123;        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) &#123;            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do &#123;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e = e.next) != null);        &#125;    &#125;    return null;&#125;</code></pre><h5 id="containsValue-查看是否包含值"><a href="#containsValue-查看是否包含值" class="headerlink" title="containsValue - 查看是否包含值"></a>containsValue - 查看是否包含值</h5><pre><code class="java">// 输入参数：E value是什么类型就输入什么类型public static void main(String[] args)&#123;    HashMap&lt;String,String&gt; arrayList = createStSHashMap();    System.out.println(arrayList.containsValue(&quot;b&quot;));&#125;// 返回值 booleantrue// 源码方法 public boolean containsValue(Object value) &#123;    Node&lt;K,V&gt;[] tab; V v;    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;        for (Node&lt;K,V&gt; e : tab) &#123;            for (; e != null; e = e.next) &#123;                if ((v = e.value) == value ||                    (value != null &amp;&amp; value.equals(v)))                    return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><h5 id="get-获取对应值"><a href="#get-获取对应值" class="headerlink" title="get - 获取对应值"></a>get - 获取对应值</h5><h5 id="getOrDefault-获取对应值或获取默认值"><a href="#getOrDefault-获取对应值或获取默认值" class="headerlink" title="getOrDefault - 获取对应值或获取默认值"></a>getOrDefault - 获取对应值或获取默认值</h5><h5 id="replace-更改映射"><a href="#replace-更改映射" class="headerlink" title="replace - 更改映射"></a>replace - 更改映射</h5><h5 id="isEmpty-判空"><a href="#isEmpty-判空" class="headerlink" title="isEmpty - 判空"></a>isEmpty - 判空</h5><h5 id="clone-拷贝一份hashMap"><a href="#clone-拷贝一份hashMap" class="headerlink" title="clone - 拷贝一份hashMap"></a>clone - 拷贝一份hashMap</h5><h3 id="HashMap全部方法简介"><a href="#HashMap全部方法简介" class="headerlink" title="HashMap全部方法简介"></a>HashMap全部方法简介</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clear()</td><td align="center">删除hashMap中的所有键&#x2F;值对</td></tr><tr><td align="center">clone()</td><td align="center">复制一份hashMap</td></tr><tr><td align="center">isEmpty()</td><td align="center">判断hashMap是否为空</td></tr><tr><td align="center">size()</td><td align="center">计算hashMap中键&#x2F;值对的数量</td></tr><tr><td align="center">put()</td><td align="center">将键&#x2F;值对添加到hashMap中</td></tr><tr><td align="center">putAll()</td><td align="center">将所有键&#x2F;值对添加到hashMap中</td></tr><tr><td align="center">putIfAbsent()</td><td align="center">如果hashMap中不存在指定的键，则将指定的键&#x2F;值对插入</td></tr><tr><td align="center">remove()</td><td align="center">删除hashMap中指定键key的映射关系</td></tr><tr><td align="center">containsKey()</td><td align="center">检查hashMap中是否存在指定key对应的映射关系</td></tr><tr><td align="center">containsValue()</td><td align="center">检查hashMap中是否存在指定value对应的映射关系</td></tr><tr><td align="center">replace()</td><td align="center">替换hashMap中是指定的Key对应的value</td></tr><tr><td align="center">replaceAll()</td><td align="center">将hashMap中所有的映射关系替换成给定函数所执行的结果</td></tr><tr><td align="center">get()</td><td align="center">获得指定key对应的value</td></tr><tr><td align="center">getOrDefault()</td><td align="center">获取指定key对应的value，如果找不到key，则返回设置的默认值</td></tr><tr><td align="center">forEach()</td><td align="center">对hashMap中每个映射执行指定的操作</td></tr><tr><td align="center">entrySet()</td><td align="center">返回hashMap中所有映射项的集合视图</td></tr><tr><td align="center">keySet()</td><td align="center">返回hashMap中所有key组成的集合视图</td></tr><tr><td align="center">values()</td><td align="center">返回hashMap中存在的所有value值</td></tr><tr><td align="center">merge()</td><td align="center">添加键值对到hashMap中</td></tr><tr><td align="center">compute()</td><td align="center">对hashMap中指定key的值进行重新计算</td></tr><tr><td align="center">computeIfAbsent()</td><td align="center">对hashMap指定的key的值进行重新计算，如果不存在这个key，则添加到hashMap中</td></tr><tr><td align="center">computeIfPresent()</td><td align="center">对hashMap中指定key的值进行重新计算，前提是该key存在于hashMap中</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList方法总结</title>
      <link href="/2023/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ArrayList%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ArrayList%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-方法总结"><a href="#ArrayList-方法总结" class="headerlink" title="ArrayList 方法总结"></a>ArrayList 方法总结</h1><ul><li>ArrayList继承关系</li><li>ArrayList常见方法</li><li>ArrayList全部方法简介</li></ul><h3 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h3><p>ArrayList继承了AbstractList，实现了List接口，底层实现是数组</p><p>ArrayList中的<strong>方法</strong>没有加 <strong>synchronized</strong> 关键字，线程并不安全</p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;...&#125;</code></pre><h3 id="ArrayList常见方法"><a href="#ArrayList常见方法" class="headerlink" title="ArrayList常见方法"></a>ArrayList常见方法</h3><h5 id="add-添加"><a href="#add-添加" class="headerlink" title="add - 添加"></a>add - 添加</h5><pre><code class="java">// 实例arraylist    public static ArrayList&lt;Integer&gt; createIntegerArray() &#123;        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();        arrayList.add(1);        arrayList.add(9);        arrayList.add(6);        arrayList.add(4);        arrayList.add(7);        return arrayList;    &#125;    public static ArrayList&lt;String&gt; createStringArray() &#123;        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();        arrayList.add(&quot;a&quot;);        arrayList.add(&quot;bcd&quot;);        arrayList.add(&quot;hello&quot;);        arrayList.add(&quot;IZONKUN&quot;);        arrayList.add(&quot;world&quot;);        arrayList.add(&quot;a&quot;);        return arrayList;    &#125;// 源码方法：    public boolean add(E e) &#123;        modCount++;        add(e, elementData, size);        return true;    &#125;    // 简单好懂：有位置就在对应位置赋值，否则就扩容再赋值    private void add(E e, Object[] elementData, int s) &#123;        if (s == elementData.length)            // grop() 扩容方法            elementData = grow();        elementData[s] = e;        size = s + 1;    &#125;</code></pre><h5 id="get-获得所给索引对应的值"><a href="#get-获得所给索引对应的值" class="headerlink" title="get - 获得所给索引对应的值"></a>get - 获得所给索引对应的值</h5><pre><code class="java">// 输入参数：int num 用于在数组中寻找对应偏移量的值public static void main(String[] args)&#123;    ArrayList&lt;Integer&gt; arrayList1 = createIntegerArray();    System.out.println(arrayList1.get(1));    System.out.println(arrayList1.get(100));&#125;// 返回值 &lt;E&gt; ArrayList对应类型9NPE 空指针异常// 源码方法：    public E get(int index) &#123;        // 检查长度是否有异常        Objects.checkIndex(index, size);        return elementData(index);    &#125;    // 检查长度是否有异常方法    public static &lt;X extends RuntimeException&gt;    int checkIndex(int index, int length,                   BiFunction&lt;String, List&lt;Integer&gt;, X&gt; oobef) &#123;        if (index &lt; 0 || index &gt;= length)            throw outOfBoundsCheckIndex(oobef, index, length);        return index;    &#125;    // 返回对应值    E elementData(int index) &#123;        return (E) elementData[index];    &#125;</code></pre><h5 id="contains-判断是否存在在对应arraylist中"><a href="#contains-判断是否存在在对应arraylist中" class="headerlink" title="contains - 判断是否存在在对应arraylist中"></a>contains - 判断是否存在在对应arraylist中</h5><pre><code class="java">// 输入参数：Object object 用于判断是否存在的对象public static void main(String[] args)&#123;    ArrayList&lt;Integer&gt; arrayList1 = createIntegerArray();    System.out.println(arrayList1.contains(1));    System.out.println(arrayList1.contains(100));&#125;// 返回值：booleantrue   false// 源码方法：    public boolean contains(Object o) &#123;        return indexOf(o) &gt;= 0;    &#125;    public int indexOf(Object o) &#123;        return indexOfRange(o, 0, size);    &#125;    int indexOfRange(Object o, int start, int end) &#123;        Object[] es = elementData;        // 目标为空        if (o == null) &#123;            for (int i = start; i &lt; end; i++) &#123;                if (es[i] == null) &#123;                    return i;                &#125;            &#125;        &#125; else &#123;            // 遍历返回第一次遇到目标的下标            for (int i = start; i &lt; end; i++) &#123;                if (o.equals(es[i])) &#123;                    return i;                &#125;            &#125;        &#125;        return -1;    &#125;</code></pre><h5 id="indexOf-获得所给值对应的第一个索引"><a href="#indexOf-获得所给值对应的第一个索引" class="headerlink" title="indexOf - 获得所给值对应的第一个索引"></a>indexOf - 获得所给值对应的第一个索引</h5><pre><code class="java">// 输入参数：Object object 用于判断是否存在的对象public static void main(String[] args)&#123;    ArrayList&lt;String&gt; arrayList2 = createStringArray();    System.out.println(arrayList2.indexOf(&quot;wwww&quot;));    System.out.println(arrayList2.indexOf(&quot;IZONKUN&quot;));&#125;// 返回值 int 返回对应值对应的第一个索引-13// 见上面的contains中的indexOf和indexOfRange</code></pre><h5 id="size-获得arraylist长度"><a href="#size-获得arraylist长度" class="headerlink" title="size - 获得arraylist长度"></a>size - 获得arraylist长度</h5><pre><code class="java">public static void main(String[] args)&#123;    ArrayList&lt;String&gt; arrayList2 = createStringArray();    System.out.println(arrayList2.size());&#125;// 返回值 int 长度6// 源码方法：    public int size() &#123;        return size;    &#125;</code></pre><h5 id="isEmpty-判断当前arraylist是否为空"><a href="#isEmpty-判断当前arraylist是否为空" class="headerlink" title="isEmpty - 判断当前arraylist是否为空"></a>isEmpty - 判断当前arraylist是否为空</h5><pre><code class="java">public static void main(String[] args)&#123;    ArrayList&lt;String&gt; arrayList2 = createStringArray();    System.out.println(arrayList2.isEmpty());&#125;// 返回值 boolean  为空返回true 不为空返回falsefalse// 源码方法：    public boolean isEmpty() &#123;        return size == 0;    &#125;</code></pre><h5 id="forEach-遍历arraylist"><a href="#forEach-遍历arraylist" class="headerlink" title="forEach - 遍历arraylist"></a>forEach - 遍历arraylist</h5><pre><code class="java">// 遍历数组，进行活动public static void main(String[] args)&#123;    ArrayList&lt;String&gt; arrayList2 = createStringArray();    arrayList2.forEach((e)-&gt; &#123;        System.out.print(e+&quot; &quot;);    &#125;);&#125;// 返回值a bcd hello IZONKUN world a // 源码方法：    // 传入参数：消费者行为    public void forEach(Consumer&lt;? super E&gt; action) &#123;        // 判空异常        Objects.requireNonNull(action);        final int expectedModCount = modCount;        final Object[] es = elementData;        final int size = this.size;        for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)            // 消费者方法执行            action.accept(elementAt(es, i));        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    &#125;    // 判空异常方法：    public static &lt;T&gt; T requireNonNull(T obj) &#123;        if (obj == null)            throw new NullPointerException();        return obj;    &#125;</code></pre><h3 id="ArrayList全部方法简介"><a href="#ArrayList全部方法简介" class="headerlink" title="ArrayList全部方法简介"></a>ArrayList全部方法简介</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">add()</td><td align="center">将元素插入到指定位置的arraylist中</td></tr><tr><td align="center">addAll()</td><td align="center">添加集合中所有元素到arraylist中</td></tr><tr><td align="center">clear()</td><td align="center">删除arraylist中所有元素</td></tr><tr><td align="center">clone()</td><td align="center">复制一份arraylist</td></tr><tr><td align="center">contains()</td><td align="center">判断元素是否在arraylist中</td></tr><tr><td align="center">get()</td><td align="center">通过索引值获取arraylist中的元素</td></tr><tr><td align="center">indexOf()</td><td align="center">返回arraylist中元素的索引值</td></tr><tr><td align="center">removeAll()</td><td align="center">删除存在于指定集合中的arraylist里的所有元素</td></tr><tr><td align="center">remove()</td><td align="center">删除arraylist里的单个元素</td></tr><tr><td align="center">size()</td><td align="center">返回arraylist里元素数量</td></tr><tr><td align="center">isEmpty()</td><td align="center">判断arraylist是否为空</td></tr><tr><td align="center">subList()</td><td align="center">截取部分arraylist的元素</td></tr><tr><td align="center">set()</td><td align="center">替换arraylist中指定索引的元素</td></tr><tr><td align="center">sort()</td><td align="center">对arraylist元素进行排序</td></tr><tr><td align="center">toArray()</td><td align="center">将arraylist转换为数组</td></tr><tr><td align="center">toString()</td><td align="center">将arraylist转换为字符串</td></tr><tr><td align="center">ensureCapacity()</td><td align="center">设置指定容量大小的arraylist</td></tr><tr><td align="center">lastindexOf()</td><td align="center">返回指定元素在arraylist中最后一次出现的位置</td></tr><tr><td align="center">retainAll()</td><td align="center">保留arraylist是否包含指定集合中的所有元素</td></tr><tr><td align="center">containsAll()</td><td align="center">查看arraylist是否包含指定集合中的所有元素</td></tr><tr><td align="center">trimToSize()</td><td align="center">将arraylist中的容量调整为数组中的元素个数</td></tr><tr><td align="center">removeRange()</td><td align="center">删除arraylist中指定索引之间存在的元素</td></tr><tr><td align="center">replaceAll()</td><td align="center">将给定的操作内容替换掉数组中每一个元素</td></tr><tr><td align="center">removeIf()</td><td align="center">删除所有满足特定条件的arraylist元素</td></tr><tr><td align="center">forEach()</td><td align="center">遍历arraylist中每一个元素并执行特定操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux任务调度和定时任务</title>
      <link href="/2023/02/07/Linux/Linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/02/07/Linux/Linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux任务调度和定时任务"><a href="#Linux任务调度和定时任务" class="headerlink" title="Linux任务调度和定时任务"></a>Linux任务调度和定时任务</h1><ul><li><p>Linux crond 任务调度</p><ul><li>基本使用代码</li><li>属性信息</li><li>其他使用代码</li></ul></li><li><p>Linux at 定时任务</p><ul><li>基本使用代码</li><li>时间设置</li></ul></li></ul><h3 id="Linux-crond-任务调度"><a href="#Linux-crond-任务调度" class="headerlink" title="Linux crond 任务调度"></a>Linux crond 任务调度</h3><h5 id="基本使用代码"><a href="#基本使用代码" class="headerlink" title="基本使用代码"></a>基本使用代码</h5><pre><code class="linux">// 进入任务调度状态(命令行模式)crontab -e// 输入需要调度的任务,例如：每分钟执行一次（ls -l /etc/ &gt; /tmp/to.txt 查询/etc/目录下的文件，并以覆盖形式卸载/tmp/to.txt中）*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt// 其他调度计划// 完成后输入（:wq）保存退出任务调度状态:wq</code></pre><h5 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h5><p>第一个*：每小时的第几分钟，</p><p>第二个*：每天的第几小时</p><p>第三个*：每个月的第几天</p><p>第四个*：每年的第几个月</p><p>第五个*：一周中的星期几（0-7：0和7都是周日）</p><p>注：每个 * 之间有空格</p><p><strong>不同形态</strong>：</p><p>*：    表示每一个时间点，每一分钟开始，每一小时开始…</p><p>*&#x2F;n： 表示每隔n分钟执行一次</p><p>a,b： 表示不连续，如 0 8,12,16 * * * 表示每天8点，12点，16点整执行一次</p><p>a-b： 表示连续，如 0 5 * * 1-6 表示周一到周六的凌晨五点执行一次</p><h5 id="其他使用代码"><a href="#其他使用代码" class="headerlink" title="其他使用代码"></a>其他使用代码</h5><pre><code class="Linux">conrtab -r:终止任务调度conrtab -l  :列出当前任务调度</code></pre><h3 id="Linux-at-定时任务"><a href="#Linux-at-定时任务" class="headerlink" title="Linux at 定时任务"></a>Linux at 定时任务</h3><h5 id="基本使用代码-1"><a href="#基本使用代码-1" class="headerlink" title="基本使用代码"></a>基本使用代码</h5><pre><code class="linux">// at 定时任务，也是一次性任务at [选项] [时间]-m: 任务完成，给用户发邮件| -V : 显示版本信息-I  : atq别名   | -q &lt;队列&gt;  : 使用指定队列-d  : atrm别名   | -f &lt;文件&gt;  : 从指定文件读取任务-v  : 显示任务被执行时间  | -t &lt;时间参数&gt; : 以时间参数形式提交运行任务-c  : 打印任务内容到标准输出// Ctrl D [按两次] : 退出at命令输入Ctrl DCtrl D</code></pre><h5 id="时间设置"><a href="#时间设置" class="headerlink" title="时间设置"></a>时间设置</h5><ol><li>hh:mm （小时 : 分钟）如果今天这个时间已过，则明天执行</li><li>midnight （深夜），noon（中午），teatime（下午四点）</li><li>1~12 +AM&#x2F;PM</li><li>month day 或 mm&#x2F;dd&#x2F;yy （月&#x2F;日&#x2F;年） 或 dd.mm.yy （日.月.年）如 04:00 2021-03-01</li><li>相对时间：now + count time-unit ：如 now + 5minutes （minutes 分钟；hours 小时；days 天；weeks 星期）</li><li>today , tomorrow</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux运行级别和文件管理</title>
      <link href="/2023/02/05/Linux/Linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/05/Linux/Linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux运行级别和文件管理"><a href="#Linux运行级别和文件管理" class="headerlink" title="Linux运行级别和文件管理"></a>Linux运行级别和文件管理</h1><ul><li><p>Linux运行级别</p><ul><li>Linux 运行级别</li><li>运行级别管理相关命令</li></ul></li><li><p>Linux目录文件管理</p><ul><li>文件管理相关命令</li><li>文件查询相关命令</li><li>文件压缩和解压命令</li><li>其他信息命令</li></ul></li></ul><h3 id="Linux运行级别"><a href="#Linux运行级别" class="headerlink" title="Linux运行级别"></a>Linux运行级别</h3><h5 id="Linux-运行级别"><a href="#Linux-运行级别" class="headerlink" title="Linux 运行级别"></a>Linux 运行级别</h5><p>0关机  |    4 系统未使用保留给用户</p><p>1单用户【找丢失密码】   |     5 图形界面</p><p>2    多用户无网络  |      6 系统重启</p><p>3 多用户有网络 |</p><p>常用为 <strong>3 - 多用户有网络（命令行模式）【企业】</strong> 和 <strong>5 - 图形界面（桌面模式）【学习】</strong></p><h5 id="运行级别管理相关命令"><a href="#运行级别管理相关命令" class="headerlink" title="运行级别管理相关命令"></a>运行级别管理相关命令</h5><pre><code class="linux">init 数子        :执行相对应的运行级别</code></pre><p>附：1 - 单用户 找回root密码 可以看<a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=26&vd_source=ad19a531d1fe118602dfd75ff3c6db57">026_韩顺平Linux_找回root密码_哔哩哔哩_bilibili</a></p><h3 id="Linux目录文件管理"><a href="#Linux目录文件管理" class="headerlink" title="Linux目录文件管理"></a>Linux目录文件管理</h3><h5 id="文件管理相关命令"><a href="#文件管理相关命令" class="headerlink" title="文件管理相关命令"></a>文件管理相关命令</h5><pre><code class="linux">跳转路径   : cd 绝对路径/相对路径| 回到家目录: cd ~创建目录   : mkdir 目录名| 创建多级目录   : mkdir -P /文件夹/../目录名删除目录   : rmdir 空目录名   | 强制删除: rm -rf 目录创建空文件     : touch 文件名复制拷贝   : cp 文件名 目的地  | 递归拷贝目录文件 : cp -r 文件夹 目的地移动文件   : mv 文件 目的地</code></pre><h5 id="文件查询相关命令"><a href="#文件查询相关命令" class="headerlink" title="文件查询相关命令"></a>文件查询相关命令</h5><pre><code class="linux">显示当前绝对路径: pwd查看当前目录下文件  : ls  | -a 查看包括隐式文件  -l以列形式展示 如： ls -al查看文件(不修改)    : cat 文件分段查看大文件 : less 文件查看文件头10行   : head 文件   | 查看文件头五行    : head -n 5 文件查看文件尾10行   : tail 文件   | 查看文件尾五行    : tail -n 5 文件实时追踪文件更新: tail -f 文件</code></pre><h5 id="文件压缩和解压命令"><a href="#文件压缩和解压命令" class="headerlink" title="文件压缩和解压命令"></a>文件压缩和解压命令</h5><pre><code class="linux">压缩文件为文件名.gz  : gzip 文件 | 解压文件 : gunzip 文件.gz文件夹递归压缩整个文件: zip -r 文件夹  | 解压到对应路径: unzip -d 存储路径 文件.zip打包内容(压缩)   : tar -zcfv 内容   | 打包内容(解压)   : tar -zxfv 内容-x: 解包.tar文件-c: 产生.tar文件-v: 显示信息 xxx.tar.gz-f: 指定名字-z: 打包压缩</code></pre><h5 id="其他信息命令"><a href="#其他信息命令" class="headerlink" title="其他信息命令"></a>其他信息命令</h5><pre><code class="linux">命令行输出内容 : echo 内容A &gt; B: 将A的内容写至B中（覆盖）| A &gt;&gt; B: 将A的内容写至B中（追加）打印当前日历    : cal| 打印一年的日历  : cal 年份查看历史命令    : history| 在histor查看历史命令时执行某行历史命令: !行数查看命令所在目录: which 命令显示当前时间     : date| 设置时间 : date -s &quot;2023-2-5 12:23:00&quot;查找文件： find 要查找的目录目录 -name文件名字 -user用户名 -size大小（+n大于 -n小于 n等于 -- k/M/G单位）</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户和权限基本命令</title>
      <link href="/2023/02/03/Linux/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/03/Linux/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux用户和权限的命令"><a href="#Linux用户和权限的命令" class="headerlink" title="Linux用户和权限的命令"></a>Linux用户和权限的命令</h1><ul><li>Linux用户管理<ul><li>用户管理相关指令</li><li>用户管理相关文件</li></ul></li><li>Linux权限管理<ul><li>用户与组</li><li>rwx权限数字</li><li>权限管理相关指令</li></ul></li></ul><h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><h5 id="用户管理相关指令"><a href="#用户管理相关指令" class="headerlink" title="用户管理相关指令"></a>用户管理相关指令</h5><pre><code class="linux">useradd 用户名:添加用户，并在 /home 下创建 /用户名 目录例如： useradd ITegg=&gt; 在/home 下会有 /ITegg 目录useradd -d 路径 用户名:添加用户，自指定用户目录位置   例如： useradd -d /user/test ITegg  =&gt;在、home 下创建/test/ITegg目录password 用户名:为用户设置密码（新用户默认没有密码）  pwd:显示当前目录userdel 用户名:删除用户（用户目录会保留） userdel -r 用户名:连带用户目录一起删掉who am i   :查看当前权限</code></pre><h5 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h5><p><strong>&#x2F;etc&#x2F;passwd 文件</strong>：用户配置文件</p><p>用户名：口令：用户标识号：组标识号：注释性描述目录：主目录：登录Shell<strong>shell</strong>：人命令和机器命令之间的翻译官</p><p><strong>&#x2F;etc&#x2F;shadow 文件</strong>：口令配置文件</p><p>登录名：加密口令：最后修改时间：最小修改间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p><p><strong>&#x2F;etc&#x2F;group 文件</strong>：组配置文件</p><p>组名：口令：组标识号</p><h3 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a>Linux权限管理</h3><h5 id="用户与组："><a href="#用户与组：" class="headerlink" title="用户与组："></a><strong>用户与组</strong>：</h5><p>要想了解权限管理，需要先了解一个概念：组。就像分类一样，同一个组的用户拥有相同的权限，所以为了便于组的管理，可以将拥有相同权限的不同用户放入同一个组，用户创建时，默认会创建一个和自己同名的组里（自己就是一个组）</p><h5 id="rwx权限数字"><a href="#rwx权限数字" class="headerlink" title="rwx权限数字:"></a><strong>rwx权限数字</strong>:</h5><p>rwx权限数字有0-9（一共十位）</p><p>0：文件类型： l ：链接；   d：目录；  c：字符设备（鼠标键盘）；  b：块设备（硬盘）； - ：普通文件</p><p>1-3：文件所有者对其的权限： r 可读（文件）&#x2F; 可查询有什么文件（目录）w 可写（文件）&#x2F; 可删除或新增文件（目录）x 可执行（文件）&#x2F; 可进入（目录）</p><p>4-6：文件所属组对其的权限： r 可读（文件）&#x2F; 可查询有什么文件（目录）w 可写（文件）&#x2F; 可删除或新增文件（目录）x 可执行（文件）&#x2F; 可进入（目录）</p><p>7-9：其他用户对文件的权限： r 可读（文件）&#x2F; 可查询有什么文件（目录）w 可写（文件）&#x2F; 可删除或新增文件（目录）x 可执行（文件）&#x2F; 可进入（目录）</p><h5 id="权限管理相关指令"><a href="#权限管理相关指令" class="headerlink" title="权限管理相关指令"></a>权限管理相关指令</h5><pre><code class="linux">文件，组管理：ls -ahl :查看文件所有者groupadd 组名:创建组groupdel 组名 :删除组usermod -g 组名 用户名:改变用户的所在组  chown 用户名 文件名:修改文件的所有者chgrp -r 组名 文件名:修改文件所在组修改权限：chmod u=rwx,g=rx,o=x 文件或目录:u是文件所有者，g是所属组，o是其他用户，设置权限（a是所有用户）chmod u-x 文件或目录:将u的写能力去掉chmod o+r 文件或目录:将o新增读能力还有：r = 4; w = 2; x = 1所以chmod 751 文件或目录 等价于 chmod u=rwx,g=rx,o=x</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录文件和基本指令</title>
      <link href="/2023/02/01/Linux/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/02/01/Linux/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录文件和基本指令"><a href="#Linux目录文件和基本指令" class="headerlink" title="Linux目录文件和基本指令"></a>Linux目录文件和基本指令</h1><ul><li>Linux目录文件夹</li><li>基本指令</li></ul><h3 id="Linux目录文件夹"><a href="#Linux目录文件夹" class="headerlink" title="Linux目录文件夹"></a>Linux目录文件夹</h3><table><thead><tr><th align="center">目录地址</th><th align="center">目录内容</th></tr></thead><tbody><tr><td align="center"><strong>&#x2F;bin</strong></td><td align="center">存放常用指令</td></tr><tr><td align="center"><strong>&#x2F;home</strong></td><td align="center">存放用户信息</td></tr><tr><td align="center"><strong>&#x2F;root</strong></td><td align="center">超级管理员目录（文件管理）</td></tr><tr><td align="center"><strong>&#x2F;etc</strong></td><td align="center">存放系统所需的配置文件和子目录</td></tr><tr><td align="center"><strong>&#x2F;usr</strong></td><td align="center">存放系统所需要的配置文件，类似windows下的programfile文件夹</td></tr><tr><td align="center"><strong>&#x2F;boot</strong></td><td align="center">存放Linux启动的核心文件，包括一些连接文件和镜像文件</td></tr><tr><td align="center"><strong>&#x2F;mnt</strong></td><td align="center">用于让用户临时挂载别的文件</td></tr><tr><td align="center"><strong>&#x2F;media</strong></td><td align="center">Linux自动识别设备：U盘，光驱等</td></tr><tr><td align="center"><strong>&#x2F;usr&#x2F;local</strong></td><td align="center">另一个主机歪歪安装软件的目录，以编译源码的方式安装</td></tr><tr><td align="center">&#x2F;sbin</td><td align="center">存放管理员（Super user）使用的管理系统管理程序&#x2F;指令</td></tr><tr><td align="center">&#x2F;lib</td><td align="center">类似DLL文件，存放基本动态连接共享库</td></tr><tr><td align="center">&#x2F;lost+found</td><td align="center">一般是空文件且不可见，当系统非法关机后存放信息</td></tr><tr><td align="center">&#x2F;proc</td><td align="center">虚拟目录【不可动】存放系统内存映射</td></tr><tr><td align="center">&#x2F;srv</td><td align="center">存放服务启动后要提取的数据</td></tr><tr><td align="center">&#x2F;sys</td><td align="center">安装了Linux2.6 内核的新文件系统</td></tr><tr><td align="center">&#x2F;tmp</td><td align="center">存放临时文件</td></tr><tr><td align="center">&#x2F;dev</td><td align="center">类似windows 设备管理器</td></tr><tr><td align="center">&#x2F;opt</td><td align="center">给主机额外安装软件所摆放的目录</td></tr><tr><td align="center">&#x2F;var</td><td align="center">存放正在扩充的文件&#x2F;经常修改的文件</td></tr></tbody></table><h3 id="基本指令："><a href="#基本指令：" class="headerlink" title="基本指令："></a>基本指令：</h3><p>正常模式：在目录页使用 <strong>vim 文件地址</strong> 进入正常模式，仅查看文件，按下[ i ] [ I ] [ a ] [ A ] [ o ] [ O ] [ r ] [ R ]，会进入插入模式 </p><p>插入模式：[ esc ]推出至正常模式，[ esc ] + [ : ] 进入命令模式</p><p>命令模式：[ : ] +  wq  写入并退出  ，[ : ] + [ q ] 退出不写入  ，[ : ] +  q!  强制退出  </p><p>拷贝当前行：  yy拷贝以下n行：【数字n】yy粘贴：p</p><p>删除当前行： dd删除以下n行： 【数字n】dd</p><p>查找： &#x2F;关键字 + [ Enter ]查找的下一个：[ n ]</p><p>显示行号： [ : ] + set nu不显示行号： [ : ] + setnonu</p><p>撤销： [ u ] 跳转至文尾： [ G ] 跳转至文首： [ gg ]</p><p>跳转行：  [ 数字 ] + [ shift ] + [ g ]</p><p>关机： shutdown -h now一分钟后关机：shutdown -h 1重启：shutdown -r now</p><p>超级登录：su - [ 用户名 ]注销：logout退出超级模式： exit</p><p>了解命令作用： man 命令</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/11/11/Java%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/11/Java%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于比较的排序算法，利用分治法来将一个序列分割成两个子序列进行排序，并利用递归的方式进行排序。快速排序是一种高效的排序算法，其时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><p>【算法步骤】</p><p>1.选择基准值：从数列中选择一个元素作为基准值（pivot）。</p><p>2.分割：将序列中大于基准值的元素放在基准值的右边，小于基准值的元素放在基准值的左边。此时，基准值的位置已经确定了。 </p><p>3.递归：对左右两边的子序列分别重复步骤1、步骤2，直到每个子序列只有一个元素时终止递归。</p><p>【时间复杂度】</p><ul><li>最好情况下，每次选出的基准值都刚好平分整个序列，此时排序效率最高，时间复杂度为O(nlogn)。</li><li>最坏情况下，每次选出的基准值总是序列中的最小或最大值，导致递归树退化成只有一条支线，此时时间复杂度为O(n²)。</li><li>平均情况下，快速排序的时间复杂度为O(nlogn)。</li></ul><p>【空间复杂度】</p><p>快速排序的空间复杂度为O(logn)，主要是由于递归调用的栈所占用的空间。</p><p>【适用场景】</p><p>快速排序适用于数据量较大、数值分布比较均匀的情况下。由于快速排序对于数据分布的依赖性比较强，如果数据分布不均匀，可能会影响排序效率，甚至导致时间复杂度退化到O(n²)。因此，如果要在数据分布不均匀的情况下进行排序，建议采用其他排序算法。</p><p>【实现代码】</p><p>以下是实现快速排序的Java代码：</p><pre><code>Copy Codepublic static void quickSort(int[] arr, int low, int high) &#123;    if (low &lt; high) &#123;        int pivot = partition(arr, low, high);        quickSort(arr, low, pivot - 1);        quickSort(arr, pivot + 1, high);    &#125;&#125;private static int partition(int[] arr, int low, int high) &#123;    int pivot = arr[high];    int i = low - 1;    for (int j = low; j &lt;= high - 1; j++) &#123;        if (arr[j] &lt; pivot) &#123;            i++;            swap(arr, i, j);        &#125;    &#125;    swap(arr, i + 1, high);    return i + 1;&#125;private static void swap(int[] arr, int i, int j) &#123;    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;</code></pre><p>其中，<code>quickSort</code>方法是快速排序的入口，它会递归调用自己对左右子序列进行排序。<code>partition</code>方法是分割方法，用于将序列分割成两个子序列，并返回基准值的位置。<code>swap</code>方法是交换数组中两个元素的值。</p><p>测试代码如下：</p><pre><code>Copy Codeint[] arr = &#123;5, 3, 1, 6, 8, 4, 2, 7&#125;;quickSort(arr, 0, arr.length - 1);System.out.println(Arrays.toString(arr));</code></pre><p>输出结果为：[1, 2, 3, 4, 5, 6, 7, 8]</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存淘汰测略</title>
      <link href="/2022/09/17/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>/2022/09/17/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="单线程的Redis为什么快？"><a href="#单线程的Redis为什么快？" class="headerlink" title="单线程的Redis为什么快？"></a>单线程的Redis为什么快？</h2><p><strong>为什么需要缓存淘汰测略：</strong></p><p>内存数据不淘汰会越来越多，最终导致内存溢出</p><h5 id="八种内存淘汰测略："><a href="#八种内存淘汰测略：" class="headerlink" title="八种内存淘汰测略："></a>八种内存淘汰测略：</h5><ol><li>不删除 key ，当到达最大阈值后报错：<strong>noeviction</strong></li><li>设过期 key 中选择使用数最小的           ：<strong>volatile - lrw</strong></li><li>在所有 key 中选择使用数最小的            ：<strong>allkeys - lru</strong></li><li>过期 key 中使用 lfu 算法                        ：<strong>volatile - lfu</strong></li><li>所有 key 用 lfu 算法                                 ：<strong>allkeys - lfu</strong></li><li>过期 key 随机删除                                    ：<strong>volatile - random</strong></li><li>所有 key 碎甲删除                                    ：<strong>allkeys - random</strong></li><li>过期 key 中最早过期的删除                     :  <strong>volatile - ttl</strong></li></ol><p><strong>lru：最近最少使用，实现方式：使用一个链表，被使用就放到表头，其他后推，超过表尾的就删除</strong>  这个方法可能用的少，但是实用</p><p>lfu：最近最不经常使用，实现方式：使用一个计数器，用的少的就删除，这个方法用的少</p><h5 id="何时淘汰删除："><a href="#何时淘汰删除：" class="headerlink" title="何时淘汰删除："></a>何时淘汰删除：</h5><p>消极处理：在读取数据前再判断</p><p>积极处理：周期性判断</p><p>主动处理：超出阈值就删除</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6常见问题</title>
      <link href="/2022/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片学习内容整理至b站 <a href="https://space.bilibili.com/526653251">IT老哥</a> 的视频 <a href="https://www.bilibili.com/video/BV1sR4y1c7Ni?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">《会了这些面试题后，可以挑战一下字节了》</a></p></blockquote><ul><li>单线程的Redis为什么快</li><li>五种基本数据类型底层采用什么数据结构</li><li>缓存雪崩，缓存穿透，缓存击穿，附加</li><li>Redis的过期淘汰机制</li><li>redis与memcached的区别</li><li>redis线程模型</li><li>哨兵Sentinel</li><li>如何实现redis事务</li></ul><h2 id="单线程的Redis为什么快？"><a href="#单线程的Redis为什么快？" class="headerlink" title="单线程的Redis为什么快？"></a>单线程的Redis为什么快？</h2><p>Redis有多快？官方给出的读写速度是10w&#x2F;s，在单线程的前提下跑出这个好成绩，原因有以下几点：</p><ul><li><strong>Redis是完全基于内存</strong>的，因此读写效率高，同时Redis的持久化操作是通过fork子进程和Linux系统的页面缓存技术完成，并不会影响Redis</li><li><strong>单线程操作</strong>：单线程避免了频繁上下文切换导致的性能开销</li><li>合理高效的<strong>数据结构</strong></li><li>采用了<strong>非阻塞的IO多路复用机制</strong>：多路I&#x2F;O复用模型是利用select，poll，epoll可以同时监察多个流的IO事件的能力，在空闲时阻塞当前线程，当有一个或多个流有IO事件时，就从阻塞中唤醒，程序再依次轮询所有的流，并且只依次顺序处理就绪的流，这种做法避免了大量无用操作</li></ul><h2 id="五种基本数据类型底层采用什么数据结构"><a href="#五种基本数据类型底层采用什么数据结构" class="headerlink" title="五种基本数据类型底层采用什么数据结构"></a>五种基本数据类型底层采用什么数据结构</h2><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>存储数字时：int存储长度大于39字节字符：raw存储长度小于39字节字符：embstr</p><p>raw与embstr都是由SDS动态字符串构成的。唯一区别是raw分配存储时，redisobject 和 sds 各分配一块，而 embstr 是 redisobject 在一块内存中</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：双向链表</p><h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：哈希表</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>列表所有对象都是整数，且元素数量小于512：inset否则：哈希表</p><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset:"></a>Zset:</h4><p>列表所有对象长度均小于64字节，且元素数量小于128：ziplist否则：跳表</p><h2 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h2><p>在高并发下，大量缓存key在同一时间集体失效，大量请求直接落在数据库上，导致数据库宕机</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><ul><li>随机设置key失效时间，避免大量key集体失效</li></ul><pre><code class="redis">setRedis(Key, value, time+Math.random()*10000);</code></pre><ul><li>如果是集群部署，可以将热点数据均匀分布在不同的Redis库中避免key全部失效</li><li>跑定时任务，在缓存失效前刷新新缓存</li><li>不设置过期时间（不推荐）</li></ul><h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>redis缓存没有数据库中没有相关数据（如用户查询携带id&#x3D;-1的相关数据并不断发起请求），redis中没有数据，无法进行阻拦，请求直接穿透到数据库，导致数据库压力过大宕机</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>对不存在的数据将其缓存到redis中，设置key，value值为null（不论是数据未null还是系统bug），设置一个短期过期时间，避免影响用户正常使用</li><li>拉黑用户IP</li><li>对参数进行校验，不合法参数进行拦截</li><li>布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap (位图) 中，一个一定不存在的数据会被这个bitmap拦截掉，减少对底层存储系统的查询压力</li></ul><h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>某一个热点key，在不停的扛着高并发，当这个热点key在失效的一瞬间，持续的高并发访问就击破缓存直接访问数据库，导致数据库宕机</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>设置热点数据“永不过期”</li><li>加上互斥锁：对于多个线程同时去查询数据库的热点数据，我们可以在第一个查询数据上的请求使用互斥锁锁住它</li></ul><p>其他线程需要使用就得等待，第一个线程查询到了数据，将数据放置redis中缓存起来，后面的进程就可以直接使用缓存数据</p><h2 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h2><p>提前避免以上三问题：将redis，mysql等搭建成高可用集群，放置单点</p><p>出现错误如何修补    ：服务中进行限流 + 降级，放置mysql被打崩溃</p><p>实在严重到宕机补救：Redis持久化 RDB + AOF，宕机重启，自动从磁盘加载数据，快速回复缓存数据</p><h2 id="Redis的过期淘汰机制："><a href="#Redis的过期淘汰机制：" class="headerlink" title="Redis的过期淘汰机制："></a>Redis的过期淘汰机制：</h2><p>Redis中数据过期策略采用定期删除 + 惰性删除策略</p><h4 id="1-定期删除，惰性删除策略是什么："><a href="#1-定期删除，惰性删除策略是什么：" class="headerlink" title="1.定期删除，惰性删除策略是什么："></a>1.定期删除，惰性删除策略是什么：</h4><ul><li>定期删除：Redis启用一个定时器定时监听所有key，判定key是否过期，过期就删除。尽管可以保证所有的过期key都会被删除，但是十分浪费cpu资源，且对于以及过期但是定时器还没启动的key，它任然可以使用。</li><li>惰性删除：在获得key时，先判断key是否以及过期过期就删除，缺点：如果这个key一直没被使用，那么它一直在内存，即便已经过期，这会浪费大量空间。</li></ul><h4 id="2-定期删除-惰性删除是如何工作的："><a href="#2-定期删除-惰性删除是如何工作的：" class="headerlink" title="2.定期删除 + 惰性删除是如何工作的："></a>2.定期删除 + 惰性删除是如何工作的：</h4><p>每次随机抽取一部分key进行检查，减少CPU资源的损耗，惰性删除策略互补了未检查到的key，基本上满足了所有要求</p><h4 id="3-补充的内存淘汰机制："><a href="#3-补充的内存淘汰机制：" class="headerlink" title="3.补充的内存淘汰机制："></a>3.补充的内存淘汰机制：</h4><ul><li><p>volatile - lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile - ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile - random：从已设置过期时间的数据集（server.db[i].expires）中挑选任意数据淘汰</p></li><li><p>allkeys - lru：当内存不足以容纳新写入的数据时，在键空间内，移除最近最少使用的key<strong>（这个最常用）</strong></p></li><li><p>allkeys - random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-eviction：禁止驱逐数据，永不过期，也就是当内存不足以写入新数据时，写入操作会报错<strong>（默认）</strong></p></li><li><p>volatile - lfu：4.0后加入，从已设过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p></li><li><p>allkeys - lfu：4.0后加入，当内存不足以写入新数据时，在键空间中，移除最不经常使用的key</p></li></ul><h2 id="Redis与memcached的区别："><a href="#Redis与memcached的区别：" class="headerlink" title="Redis与memcached的区别："></a>Redis与memcached的区别：</h2><p>存储方式上：memcached会将全部数据存入内存中，如果发生断电则会挂掉，数据不可以超过内存大小；redis有部分存在硬盘中，能保证数据的持久性</p><p>数据支持类型：memcached支持的数据类型相对简单；redis有复杂的数据类型</p><p>使用的底层模型不同：它们之间的底层实现，客户端之间通讯的应用协议不一样，redis自己构建了vm机制，因为一般的系统调用系统函数会浪费一定时间去移动和请求。value值大小不同，redis最大可到1gb；memcached只有1mb</p><h2 id="Redis线程模型："><a href="#Redis线程模型：" class="headerlink" title="Redis线程模型："></a>Redis线程模型：</h2><p>redis内部使用文件处理器 file event handler，这个文件事件处理器是单线程的，所以redis才叫单线程处理器模型。它采用IO多路复用机制监听多个socket，根据socket上事件处理器进行处理</p><p>文件事件处理器的结构包括4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）</li></ul><p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应事件处理器进行处理。</p><h2 id="哨兵Sentinel："><a href="#哨兵Sentinel：" class="headerlink" title="哨兵Sentinel："></a>哨兵Sentinel：</h2><p>哨兵是Redis高可用的解决方案，可以运行多个Sentinel组成一个哨兵分布式系统</p><p>哨兵主要解决的问题：故障转移，如果主节点挂掉，就进行主从切换，让从节点升级为主节点，继续对外提供服务</p><p>使用流言协议（gossip protocols）来接收主机是否下线；并使用投票协议（agreeement protocols）来决定是否执行自动故障转移；以及选择哪个服务器作为新的主服务器</p><h4 id="哨兵职责如下："><a href="#哨兵职责如下：" class="headerlink" title="哨兵职责如下："></a>哨兵职责如下：</h4><ul><li><p>监控：Sentinel会不断定期检查主服务器和从服务器是否运作正常</p></li><li><p>提醒：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或其他应用程序发送通知</p></li><li><p>自动故障迁移：当一个主服务器不能正常工作时，Sentinel会开启一次自动故障迁移操作，将失效服务器的其中一个从服务器升级为新的主服务器，并让失效服务器的其他服务器改为复制新的主服务器，当客户端连接失败主服务器时，集群也会向客户端返回新服务器地址，使得集群可以使用新主服务器替代失效服务器</p></li><li><p>统一配置管理：连接者询问Sentinel取得主从的地址</p></li></ul><h2 id="如何实现redis事务："><a href="#如何实现redis事务：" class="headerlink" title="如何实现redis事务："></a>如何实现redis事务：</h2><p>redis通过MULTI，EXEC，WATCH等命令来实现事务（transaction）功能，事务提供了一种将多个命令请求打包，然后一次性，按顺序的执行多个命令的机制，且在事务执行期间，服务器不会中断事务而改去执行其他客户端的请求，只有到这多个命令执行完毕后，才会接收其他命令</p><p>Redis事务也具有：原子性，一致性，隔离性；在特定情况下具有持久性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 —— 工厂模式</title>
      <link href="/2022/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-工厂模式"><a href="#设计模式-——-工厂模式" class="headerlink" title="设计模式 —— 工厂模式"></a>设计模式 —— 工厂模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>实现</li><li>优缺点</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>工厂模式（Factory Pattern）是<strong>创造型</strong>设计模式的一种，它提供了一种创建对象的最佳方式：不对对象暴露创建逻辑，而是通过共同的接口指向新创建的对象</p><p>定义：创建对应对象的工厂类，将创建对象的工作交给工厂，提供信息使工厂生产复杂对象</p><p>使用场所：任何需要生成复杂对象的地方</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>（工厂方法模式：建立统一的工厂接口，具体类的工厂实现公共接口）</p><pre><code class="java">// 实现一个计算机基本的加减乘除运算// 工厂接口public interface IFactory &#123;    Operation CreateOption();&#125;// 加法类工厂public class AddFactory implements IFctory &#123;    public Opetation CreateOption() &#123;        return new OperationAdd();    &#125;&#125;// 减法类工厂public class SubFactory implements IFctory &#123;    public Opetation CreateOption() &#123;        return new OperationSub();    &#125;&#125;// 乘法类工厂public class MulFactory implements IFctory &#123;    public Opetation CreateOption() &#123;        return new OperationMul();    &#125;&#125;// 除法类工厂public class DivFactory implements IFctory &#123;    public Opetation CreateOption() &#123;        return new OperationDiv();    &#125;&#125;</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：符合<strong>开闭原则</strong>，客户端可以不需要知道具体产品的类名，只需要知道对应工厂，一个类的创建是通过其子类的指定生成，子类对象会覆盖父类对象</p><p>缺点：代码更多了，要管理的对象也就更多了</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql备份</title>
      <link href="/2022/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%A4%87%E4%BB%BD/"/>
      <url>/2022/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><ul><li>数据库备份语句与恢复语句</li><li>注意事项</li><li>示例展示</li><li>遇到的问题</li></ul><h3 id="数据库备份语句与恢复语句"><a href="#数据库备份语句与恢复语句" class="headerlink" title="数据库备份语句与恢复语句"></a>数据库备份语句与恢复语句</h3><pre><code class="mysql">-- 数据库备份mysqldump -u [username] -p [database_name] &gt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要备份的数据库名</p><p>[base_path]：存储文件的地点、</p><pre><code class="mysql">-- 数据库恢复mysql -u [username] -p [database_name] &lt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要恢复的数据库名</p><p>[base_path]：存储文件的地点</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>备份是mysqldump，恢复是mysql</li><li>输入命令后，系统会要求你填写登录密码，如果在 -p 后填入密码会报错</li><li>最后的参数是路径+文件名+.sql后缀，记得查看是否有权限在目标地址写文件</li></ol><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><img src="/2022/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113332873.png" alt="image-20230227113332873"></p><p>没有报错信息就是最好的信息！</p><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li>输入：mysqldump -u root -p 02-index &gt;  C:\Users\13620\Desktop\02-index.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1045: Access denied for user ‘ODBC‘@’localhost’ (using password: YES) when trying to connect</strong></p><p>问题：没有对应地点的写入权限</p><p>解决：更改写如位置为D:\02-index.sql （有权限的地方都可以）</p><ol start="2"><li>输入：mysqldump -u root -p docker&gt;  C:\Users\13620\Desktop\docket.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1049: Unknown database ‘docker’ when selecting the database</strong></p><p><img src="/2022/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113618736.png" alt="image-20230227113618736"></p><p>问题：数据库表输入错误</p><p>解决：改对表名</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 单例模式</title>
      <link href="/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-单例模式"><a href="#设计模式-——-单例模式" class="headerlink" title="设计模式 —— 单例模式"></a>设计模式 —— 单例模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>实现</li><li>优缺点</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>单例模式是 <strong>创建型</strong> 设计模式的一种。让一个类只存在一个实例，也就是不允许其他人直接调用类，而是通过方法。</p><p>定义：确保一个类最多只有一个实例，并提供一个全局访问点</p><p>适用场景：例如平时的word文档，同时将一个文件打开两份进行修改会使得其中一份修改无效，所以不可以将一份文件打开为两份，在已经点开文件的同时在点击文件只会跳转到已打开的文件中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre><code class="java">// 需要单例的类有两种实现方法：预加载和懒加载// 预加载public class PreloadSingleton&#123;    public static PreloadSingleton instance = new PreloadSingleton();    // 提前将对象实例化，不允许其他类实例该对象    private PreloadSingleton()&#123;&#125;;        public static PreloadSingleton getInstance()&#123;        return instance;    &#125;&#125;//懒加载public class Singleton &#123;    private static Singleton instance = null;        private Singleton()&#123;&#125;;        // 不在一开始加载对象，减少系统开销，在第一次被调用时创建    public static Singlrton getInstance()&#123;        if(instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>预加载：只有return语句，可以保证线程安全，但是预加载会造成一定的内存浪费</p><p>懒加载：不浪费内存，便无法保证线程安全（if内存执行代码时非原子性的）且new Singleton()也无法保证执行的顺序性（初始化内存空间→初始化对象→设置对象指向内存地址）</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 适配器模式</title>
      <link href="/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-适配器模式"><a href="#设计模式-——-适配器模式" class="headerlink" title="设计模式 —— 适配器模式"></a>设计模式 —— 适配器模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>UML</li><li>实现</li><li>优缺点</li></ul><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>适配器模式是 <strong>结构型</strong> 设计模式的一种。类似于设计一个中间接口，使得两边可以适配使用</p><p>定义：将一个接口转化为客户端所期待的接口，从而使两个接口不兼容的类可以在一起工作</p><p>适用场景：存在现成的类可以使用，但是我们的系统不兼容它提供的接口，且我们无法对其进行修改；多个团队独立开发系统的各个部分，但是先无法确定接口</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML:"></a>UML:</h3><p><img src="/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/blog\source_posts\设计模式_适配器模式\image-20230227173420612.png" alt="image-20230227173420612"></p><ul><li>Target：客户端使用的目标接口<ul><li>operation方法：客户端使用的方法</li></ul></li><li>Adaptee：不兼容的类<ul><li>operation方法：类方法</li></ul></li><li>Adapter：适配器类<ul><li>debug方法：自己设定的，使用于接口转换的方法</li></ul></li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>实现背景：想要调出某学校某宿舍的全部学生信息，但是学校管理系统大更新了依次，现在无法调用以前的查询接口。</p><ol><li>确定目标接口</li></ol><pre><code class="java">// 旧查询接口,输入宿舍楼，宿舍编号返回信息（简单处理就不返回详细信息了）public interface SelectStu&#123;    void selectMessage(int HouseNum,int Num);&#125;</code></pre><ol start="2"><li>第二，三方接口实现</li></ol><pre><code class="java">// 输入宿舍楼名称，宿舍号返回信息public interface NowSelectSys&#123;    void fun(int HouseNum,String HouseName);&#125;// 实现类public class NowSelectSysImpl implements NowSelectSys&#123;    public void fun(int HouseNum,String HouseName)&#123;        System.out.println(&quot;返回了&quot;+HouseNum+HouseName+&quot;宿舍的信息&quot;);    &#125;&#125;</code></pre><ol start="3"><li>构建适配器</li></ol><pre><code class="java">public class SelectAdapter implements SelectStu &#123;    private NowSelectSys nowSelectSys;     // 数字的获取可以是其他程序或者一些方法，目的在将String变为int符合接口    private int HouseNum = 107;        public SelectAdapter(NowSelectSys nowSelectSys)&#123;        this.nowSelectSys = nowSelectSys;    &#125;        public void selectMessage(String HouseName,int HouseNum)&#123;        nowSelectSys.fun(HouseNum,HouseName);    &#125;&#125;</code></pre><ol start="4"><li>客户端调用接口</li></ol><pre><code class="java">SelectAdapterpublic class AdapterClient&#123;    public void SelectStudent()&#123;        SelectStu selectStu = new SelectAdapter(new NowSelectSysImpl);        selectStu.selectMessage(&quot;会泽大楼&quot;，&quot;一楼七号&quot;)    &#125;&#125;</code></pre><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>优点：增强了程序的可扩展性，减少对接口的修改</p><p>缺点：需要多管理一层Adapter</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 责任链模式</title>
      <link href="/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-责任链模式"><a href="#设计模式-——-责任链模式" class="headerlink" title="设计模式 —— 责任链模式"></a>设计模式 —— 责任链模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>UML</li><li>实现</li><li>优缺点</li></ul><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>责任链模式是 <strong>行为型</strong> 设计模式的一种。如其名一般，责任链模式使每个处理器依次连接在一起成为一条链，用户的请求任务顺着这条链传递，直到符合条件的处理器将其处理返回。</p><p>定义：避免请求者和发送者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止</p><p>适用场景：当同一种请求可能被不同对象处理时，使用责任链让请求传递，到达对应对象处理返回</p><h3 id="UML："><a href="#UML：" class="headerlink" title="UML："></a>UML：</h3><p><img src="/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/blog\source_posts\设计模式_责任链模式\image-20230227162446360.png" alt="image-20230227162446360"></p><ul><li>Handler：处理器接口<ul><li>setNextHandler方法：允许设置责任链的下一位，参数为下一位，无返回</li><li>handler方法：处理方法，责任链上的处理器都要符合处理方法（同一参数和返回，防止错误）</li></ul></li><li>ConcreateHandler：处理器，实现处理器接口，有多少个处理器定义多少个类<ul><li>nextHandler方法：设置下一位处理器</li><li>handler方法：处理请求</li></ul></li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>实现背景：员工A希望更新个人项目设备，向公司提出报销请求，数额为15w。每位领导权力不一样，能批付的金额也不一致，假设员工A的项目组长最大能批1w，部门经理批5w，总裁批20w。员工A会和项目组长沟通，但是15w金额超过项目组长的最大批付额，所以项目组长找到部门经理，有因为15w大于5W，部门经理找到总裁，总裁批准了，当然，如果大于20w就返回请求失败。</p><ol><li><strong>设计Handler接口（处理器接口）</strong></li></ol><pre><code class="java">public interface UseHandler &#123;    void setNextHandler(UseHandler nexthandler);    boolean handle(int amount);&#125;</code></pre><p>此处设计依据实际需要开发，返回boolean是因为我只需要直到amount值够不够就好</p><ol start="2"><li><strong>设计各处理器</strong></li></ol><pre><code class="java">// 项目组长public class GroupLeader implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 10_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;项目组长批准&quot;);            return true;        &#125;        System.out.println(&quot;超过我的限额，请求项目经理批准&quot;);        return nextHandler.handler(amount);    &#125;&#125;// 项目经理public class Manager implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 50_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;项目经理批准&quot;);            return true;        &#125;        System.out.println(&quot;超过我的限额，请求更高级批准&quot;);        return nextHandler.handler(amount);    &#125;&#125;// 总裁public class Leader implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 200_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;总裁批准&quot;);            return true;        &#125;        System.out.println(&quot;太贵了&quot;);        return false;    &#125;&#125;</code></pre><ol start="3"><li><strong>客户端连接各处理器，处理请求</strong></li></ol><pre><code class="java">public class processor &#123;    public void Use()&#123;        GroupLeader groupleader = new GroupLeader();        Manager manager = new Manager();        Leader leader = new Leader();                leader.setNextHandler(manager);        manager.setNextHander(groupleader);                System.out.println(&quot;我这有20w需要报销&quot;);        if(groupleader.handler(150_000))&#123;            System.out.println(&quot;谢谢领导&quot;);        &#125;else&#123;            System.out.println(&quot;无法报销，我知道了&quot;);        &#125;    &#125;&#125;</code></pre><p><strong>输出：</strong></p><p>我这有20w需要报销</p><p>超过我的限额，请求项目经理批准</p><p>超过我的限额，请求更高级批准</p><p>总裁批准</p><p>谢谢领导</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>优点：命令发出者和执行者解耦，单条命令可以让多个处理器处理，针对不同问题能区别处理</p><p>缺点：需要管理的类增多了，如果处理不合理可能形成环导致请求无法完成</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql连接本地数据库的问题</title>
      <link href="/2022/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql连接本地数据库时报网络问题"><a href="#MySql连接本地数据库时报网络问题" class="headerlink" title="MySql连接本地数据库时报网络问题"></a>MySql连接本地数据库时报网络问题</h1><p>今早起床学习大佬面经时，发现自己数据库都登不上去了<img src="/2022/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\63aae1ca1cac76b665567fb840a6da6.png" alt="63aae1ca1cac76b665567fb840a6da6"></p><p>不论是命令行还是Navicat登录都是报以上错误，可我这是个本地的数据库，不应该存在网络错误呀。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>经过大佬的指点，重启服务中的Mysql，数据库的访问就正常了<img src="/2022/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\image-20221130103336695.png" alt="image-20221130103336695"></p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>尽管问题很快被解决，但是我依然想不通为什么会报这种错误，认识到自己的不足，也就有了下面的学习，鉴于以往没有过这种错误，无从下手，我决定先翻译这段报错：</p><p><strong>‘‘读取初始通信数据包时失去与MySQL服务器的连接，系统错误: 0”</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http状态码</title>
      <link href="/2022/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2022/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>HTTP（超文本传输协议）常见状态码有以下几种：</p><ul><li>1XX （信息类状态码）：请求已经收到，进行后续处理</li><li>2XX （成功状态码）<ul><li>200 成功：请求已经被成功实现</li><li>201 Created：请求已经被实现，且现有一个新的资源已经依据请求的需要而建立</li><li>204 No Content：服务器成功处理了请求，但是没有返回任何实体内容</li></ul></li><li>3XX （重定向状态码）：需要镜像附加操作以完成请求<ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客户端发送了一个带条件的请求，服务器允许请求访问资源，但是请求的条件不满足</li></ul></li><li>4XX （客户端错误状态码）：请求包含错误语法或不能被执行<ul><li>400 Bad Request：请求报文存在错误语法</li><li>401 Unauthorized：表示发送的请求需要通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在</li></ul></li><li>5XX （服务器错误状态码）：服务器处理请求的过程中发生了错误<ul><li>500 Internal Server Error：服务器遇到了一个未曾预料到的状况，导致无法完成请求的处理</li><li>502 Bad Gateway：充当网关的服务器，从远处服务器收到了一个无效请求</li><li>503 Service Unavaliable：服务器暂时处于超负荷或停机状态，无法处理请求</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap常见问题</title>
      <link href="/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Hashmap是否线程安全？为什么？"><a href="#Hashmap是否线程安全？为什么？" class="headerlink" title="Hashmap是否线程安全？为什么？"></a>Hashmap是否线程安全？为什么？</h3><p>不安全，JDK7存在死循环和数据丢失问题。</p><p><strong>数据丢失</strong>：</p><ol><li><strong>并发赋值被覆盖</strong>：在createEntry方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖</li><li><strong>已遍历区间新增元素丢失</strong>：当某个线程在transfer方法迁移时，其他线程新增的元素可能以及落在已经遍历过的哈希槽上。遍历完成后，table数组引用指向了newTable，新增元素丢失</li><li><strong>新表被覆盖</strong>：如果resize完成，执行了table &#x3D; newTable，则后续元素就可以在新表上进行插入。但如果多线程同时resize，每个线程都会new一个数组，这是线程内的局部对象，线程之间不可见。迁移后resize的线程会赋值给table线程共享变量，可能会覆盖其他线程操作，在新表中插入的对象都会被丢弃。</li></ol><p><strong>死循环</strong>：</p><p>扩容时resize调用transfer使用头插法迁移元素，虽然newTable是局部变量，但原先的table中Entry链表是共享的，问题根源是Entry的next指针并发修改，某线程还没有将table设为newTable时用完了CPU时间片，导致数据丢失或死循环。</p><p>JDK8在resize方法中完成了扩容，并改为尾插法，不会产生死循环，但并发下仍可能丢失数据。可用ConcurrentHashMap 或 Collections.synchronizedMap包装成同步集合。</p><h3 id="JDK7与JDK8的hashmap有什么区别："><a href="#JDK7与JDK8的hashmap有什么区别：" class="headerlink" title="JDK7与JDK8的hashmap有什么区别："></a>JDK7与JDK8的hashmap有什么区别：</h3><p>JDK7是数组 + 链表，JDK8是数组 + 链表&#x2F;红黑树</p><ol><li><strong>链表插入方式不同</strong>：1.7之前，链表元素插入采用头插法，每当有新节点进入时，会插入在链表头部，由于不用遍历链表，这种插入方式效率高；1.8以后当节点插入时，因为需要判断元素个数而遍历链表（是否达到转为树的阈值），所以顺带改为尾插，即插到链表尾部，这解决了多线程下可能引发的死锁问题，因为头插法的链表在扩容移动时，会被逆序，即后插入的先处理，如果这时候有另一线程进行get操作，就可能引发死锁</li><li><strong>插入时机不同</strong>：1.7之前是扩容后再插入新的数据，并且不会先计算值的哈希值，最后单独计算；1.8之后是先插入再扩容，插入值和大家一起计算新的哈希值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get使用</title>
      <link href="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/"/>
      <url>/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/</url>
      
        <content type="html"><![CDATA[<p>原链接：<a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">视频同步笔记：狂神聊Git (qq.com)</a></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>在开发过程中用于管理我们的文件，目录或工程等内容的修改历史，方便查看历史记录，备份以便回复以前的版本的软件工程技术</p><ul><li>实现跨域多人协同开发</li><li>追踪和记载一个或多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量‘</li><li>并行开发，提高工作效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说；一种管理多人协同开发项目的技术</p><blockquote><p>常见版本控制工具：</p><p>GitSVNCVSVSSTFS</p></blockquote><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><blockquote><p>安装：</p></blockquote><p>进入官网，下载git（windows 64-bit.exe）&#x2F;  使用镜像下载 , 无脑下一步（<a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a>）</p><p>注：环境变量只是为了全局使用而已，不是必需品</p><blockquote><p>卸载：</p></blockquote><p>环境变量中删除Git , 再去卸载中心卸载程序</p><blockquote><p>使用：</p></blockquote><p>安装成功后，右键任意文件夹都会出现Git Bash（Unix与Linux风格命令行）和Git CMD（Windows风格命令行）</p><h3 id="Linux简单口令"><a href="#Linux简单口令" class="headerlink" title="Linux简单口令"></a>Linux简单口令</h3><pre><code class="Linux">cd改变目录cd..退回到上一级目录,直接cd进入默认目录pwd显示当前所在路径ls(||)ls和ls||都是列出当前目录中的所有文件,只不过后者列出的内容更为详细touch新建一个文件夹,如：touch index.js就会在当前目录下新建一个index.js文件rm删除一个文件,rm index.js就会删除index.js文件mkdir新建一个目录,就是新建一个文件夹rm -r 删除一个文件夹,rm -r src就是删除src文件夹mv移动文件,如mv index.html src 那么index.html就是移动的文件，src为目标文件夹（两者在同一目录下）reset重新初始化终端/清屏clear清理屏幕history查看历史命令exit退出#注释</code></pre><h5 id="Git配置：-所有的配置文件，其实都保存在本地"><a href="#Git配置：-所有的配置文件，其实都保存在本地" class="headerlink" title="Git配置：(所有的配置文件，其实都保存在本地)"></a>Git配置：(所有的配置文件，其实都保存在本地)</h5><h6 id="查看配置：git-config-l"><a href="#查看配置：git-config-l" class="headerlink" title="查看配置：git config -l"></a>查看配置：git config -l</h6><p><img src="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231706647.png" alt="image-20220603231706647"></p><h6 id="查看系统配置：git-config-–system-–list"><a href="#查看系统配置：git-config-–system-–list" class="headerlink" title="查看系统配置：git config –system –list"></a>查看系统配置：git config –system –list</h6><p><img src="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231858917.png" alt="image-20220603231858917"></p><h6 id="查看全局配置：git-config-–global-–list"><a href="#查看全局配置：git-config-–global-–list" class="headerlink" title="查看全局配置：git config –global –list"></a>查看全局配置：git config –global –list</h6><p><img src="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231922188.png" alt="image-20220603231922188"></p><pre><code class="linux">git config --global user.name &quot;设置名字&quot;git config --global user.email 邮箱地址</code></pre><h4 id="Git相关配置文件："><a href="#Git相关配置文件：" class="headerlink" title="Git相关配置文件："></a>Git相关配置文件：</h4><p>1)，Git&#x2F;etc&#x2F;gitconfig：Git安装目录下的gitconfig–system系统配置</p><p>2)，C:&#x2F;User&#x2F;Administrator（当前用户）&#x2F;.gitconfig：只适用于当前登录用户的配置–global全局配置</p><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）,暂存区（Stage&#x2F;Index）,资源库（Repository&#x2F;Git Directory）加上远程Git仓库（Remote Directory）</p><p><img src="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604102832395.png" alt="image-20220604102832395"></p><ul><li>Workspace：工作区，就是平时存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放改动，实际上只是一个文件，保存了即将提交到文件列表的信息</li><li>Repository：仓库区（本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器（一般用github或者gitee）</li></ul><p><img src="/2022/08/18/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604103432739.png" alt="image-20220604103432739"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>在工作目录添加,修改文件;</li><li>将需要的进行版本管理的文件放入暂存仓库</li><li>将暂存区文件提交到git仓库</li></ol><p>所以,git管理的文件有三种状态:已修改（modified），已暂存（staged），已提交（committed）</p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h3 id="仓库搭建"><a href="#仓库搭建" class="headerlink" title="仓库搭建"></a>仓库搭建</h3><p>创建本地仓库方法有两种：创建全新的仓库，克隆远程仓库</p><h5 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h5><pre><code class="git"># 在当前目录下新建一个Git代码库$ git init</code></pre><p>执行后在项目文件夹会多出一个.git的隐藏目录，关于版本等信息都在目录中</p><h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><pre><code class="git"># 克隆一个项目和它的全部代码历史（版本信息）$ git clone [url]</code></pre><p>前往gitee &#x2F; github上测试；</p><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<strong>git add</strong> 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用    <strong>git rm</strong>移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<strong>git checkout</strong> 则丢弃修改过, 返回到unmodify状态, 这个<strong>git checkout</strong>即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行<strong>git commit</strong>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行<strong>git reset HEAD filename</strong>取消暂存, 文件状态为Modified</li></ul><pre><code class="git"># 查看全部文件状态git status# 查看指定文件状态git status [filename]# 添加全部文件到暂存区git add .# 将暂存区内容提交至本地 -m为提交时编写备注git commit -m&quot;消息内容&quot;</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在项目文件夹中，并非所有数据都要我们上传和提交，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore“文件，此文件有以下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><pre><code class="git"># 为注解*.txt# 忽略所有.txt结尾的文件，上传的总文件中不会包含这些文件!lib.txt    # 但是lib.txt文件除外/temp# 仅忽略build/目录下的所有文件build/# 忽略bulid/目录下的所有文件doc/*.txt# 忽略doc/notes.txt等文件,单不包括doc/server/arch.txt</code></pre><h3 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h3><pre><code class=".gitignore">*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### IntelliJ IDEA ###*.iml*.ipr*.iws.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml*</code></pre><h1 id="使用码云（Gitee）"><a href="#使用码云（Gitee）" class="headerlink" title="使用码云（Gitee）"></a>使用码云（Gitee）</h1><p>设置本机SSH公钥，实现免密码登录！</p><pre><code class="git"># 进入C:/user/Administraror/.ssh 目录# (右键进入git命令行)生产公钥ssh-keygen</code></pre><p>将生产的id_rsa.pub文件中的信息复制，在码云<strong>安全设置</strong>的<strong>SSH公钥</strong>中粘贴即可</p><p>接下来就是创建仓库去使用了！</p><h1 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h1><p>1.新建项目，绑定git</p><ul><li>直接将远程的git文件拷贝到项目中（在别处get clone [url]，将产生的文件夹剪切）</li></ul><p>2.修改文件，提交文件</p><ul><li>左下角有<strong>Version Control</strong>显示版本信息，右上角有快捷图标</li></ul><h1 id="Git分支说明"><a href="#Git分支说明" class="headerlink" title="Git分支说明"></a>Git分支说明</h1><p>git分支中常见指令：</p><pre><code class="git"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支吧git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h1 id="Git后续操作"><a href="#Git后续操作" class="headerlink" title="Git后续操作"></a>Git后续操作</h1><blockquote><p>gitee官网中有命令大全和操作指南</p></blockquote><blockquote><p>团队很重要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层原理</title>
      <link href="/2022/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇知识梳理参考了B站up : <a href="https://space.bilibili.com/439213321">黑马程序员上海中心</a> 的视频 : <a href="https://www.bilibili.com/video/BV1FE411t7M7?share_source=copy_web&vd_source=9b42e96f6cc201a1ee177f1b86bb0b77">HashMap集合介绍+面试题讲解</a></p></blockquote><h1 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h1><ul><li>hashMap集合介绍</li><li>HashMap集合底层数据结构</li><li>hashMap继承关系</li><li>hashMap集合类成员</li><li>如何设计多个非重复的键值对要存储HashMap的初始化</li></ul><h3 id="HashMap集合介绍"><a href="#HashMap集合介绍" class="headerlink" title="HashMap集合介绍"></a>HashMap集合介绍</h3><p><img src="/2022/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20220814101149681.png" alt="image-20220814101149681"></p><p><img src="https://img-blog.csdnimg.cn/20200628084624157.png#pic_center" alt="HashMap"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http分析</title>
      <link href="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/252370220">图灵诸葛官方号</a>) 课程 <a href="https://www.bilibili.com/video/BV1V54y1y7c4?spm_id_from=333.337.search-card.all.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">程序员入门必备教程—HTTP协议详解</a>)</p></blockquote><ul><li>HTTP分层请求</li><li>HTTP协议</li><li>HTTP请求过程</li><li>TCP协议</li><li>HTTPS协议</li></ul><h1 id="Http分层"><a href="#Http分层" class="headerlink" title="Http分层:"></a>Http分层:</h1><p>网络需要完成的任务：防止数据丢包，避免数据重复，数据完整性校验，数字转模拟信号，…，信号衰减</p><p>为了完成不同层面的各个任务，简化网络的复杂度，网络通信被分解为多层次结构，每一层都紧挨着上层或下层进行交互，这样在修改甚至替换某一层的软件时，只需要层与层之间的接口保持不变，就不会影响其他层。</p><ul><li>OSI七层网络模型</li><li>TCP&#x2F;IP协议簇</li></ul><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819105355252.png" alt="image-20220819105355252"></p><h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><p>超文本传输协议（HyperText Transfer Protocol , HTTP）</p><p>一种无状态，以请求、应答方式运行的协议。它使用可扩展语义和子描述消息格式，与基于网络的草文本消息系统可以灵活互动</p><h5 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h5><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）:描述请求或响应的基本信息</li><li>头部字段集合（header）:使用key-value形式更详细的说明报文</li><li>空行</li><li>消息正文（entity）:实际传输的数据，不一定是文本，可以是图片，视频等二进制数据</li></ul><h5 id="请求行报文格式："><a href="#请求行报文格式：" class="headerlink" title="请求行报文格式："></a>请求行报文格式：</h5><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110831735.png" alt="image-20220819110831735"></p><ul><li>请求方法（METHOD）：如 GET &#x2F; HEAD &#x2F; PUT &#x2F; POST，表示对资源的操作</li><li>请求目标 ：通常是一个URL，标记了请求方法要操作的资源</li><li>版本号：表示报文使用的HTTP协议版本</li></ul><h5 id="响应行报文格式："><a href="#响应行报文格式：" class="headerlink" title="响应行报文格式："></a>响应行报文格式：</h5><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110855815.png" alt="image-20220819110855815"></p><ul><li>版本号 ：表示报文使用的HTTP协议版本</li><li>状态码（STATUS CODE）: 一个三位数，用代码的形式表示处理结果，比如200是成功，403是客户端访问被拒，500是服务器错误</li><li>原因（READON）：作为数字状态码补充，是更加详细的解释文字，协助理解原因</li></ul><h5 id="HTTP头字段："><a href="#HTTP头字段：" class="headerlink" title="HTTP头字段："></a>HTTP头字段：</h5><p>头部字段是key-value形式，key和value间使用 “  ：”做分隔，比如前后端分离时常遇到的要与后端协商传输数据类型 “ <strong>Content-type:application&#x2F;json</strong> ” ，最后用CRLF换行表示字段结束，HTTP头字段的使用比较灵活，不仅可以用Host,Connection等已有头字段，也可以任意添加自定义头，这就给HTTP协议带来了无限扩展可能。 </p><p><strong>注意事项</strong></p><ul><li>字段名称不区分大小写，但不允许出现空格和下划线“_”,可以使用连字符“-”，字段后必须紧跟“:”，中间不许有空格，但“:”后允许多个空格</li><li>字段顺序没有意义，任意排列不影响语序</li><li>字段原则上不允许重复，除非字段本身允许：Set-Cookie</li></ul><h5 id="常用头字段："><a href="#常用头字段：" class="headerlink" title="常用头字段："></a>常用头字段：</h5><p>HTTP协议有很多头字段，基本可以分为四大类：</p><ul><li>请求字段：请求头中的头字段：如Host，Referer</li><li>响应字段：响应头中的头字段：如Server，Date</li><li>通用字段：在响应头和请求头都可以出现的：Content-type，Connection</li></ul><h1 id="HTTP请求过程："><a href="#HTTP请求过程：" class="headerlink" title="HTTP请求过程："></a>HTTP请求过程：</h1><p>当用户在浏览器中输入网址后，网络协议都做了哪些工作？</p><ol><li>首先依据浏览器应用程序，解析出URL中的域名</li><li>依据域名获得的ip地址，首先从浏览器缓存中查看，没有就去本机域名解析文件hosts中查看，LDNS，Rootserver，国际定级域名服务商层层解析，直至找到</li><li>拿到ip地址后，浏览器发起对服务器的三次握手</li><li>握手建立连接后，开始组装http请求，发送报文</li><li>服务器收到请求报文后，开始请求报文解析，生成响应数据，发送响应数据</li><li>浏览器收到响应后，开始渲染页面</li></ol><blockquote><p> chrome:&#x2F;&#x2F;net-internals&#x2F;#events             查看浏览器缓存ip地址</p></blockquote><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819120503128.png" alt="image-20220819120503128"></p><h1 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h1><p>TCP协议是面向连接的，可靠的，基于字节流的传输层协议</p><h4 id="TCP属性："><a href="#TCP属性：" class="headerlink" title="TCP属性："></a>TCP属性：</h4><ul><li>基于连接：数据传输之间需要建立连接</li><li>全双工：双向传输</li><li>字节流：不限制数据大小，打包成为报文段，保证有序接收，重复报文自动丢弃</li><li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性</li><li>拥塞控制：防止网络出现恶性拥塞</li></ul><h4 id="TCP报文："><a href="#TCP报文：" class="headerlink" title="TCP报文："></a>TCP报文：</h4><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821101526541.png" alt="image-20220821101526541"></p><p>Source port：源端口Dest port：目的端口</p><p>Seq：请求数   ACK：应答数</p><p>Header length：首部长度Unused：保留字段</p><p>Receive window：当前可接收值 Urgent data：紧急报文指针</p><p>Options：可选参数   Data：数据</p><h4 id="TCP连接管理："><a href="#TCP连接管理：" class="headerlink" title="TCP连接管理："></a>TCP连接管理：</h4><p>TCP连接：四元组【源地址，源端口，目的地址，目的端口】</p><p>确认连接：三次握手</p><p>​a.同步通信双方的初始序列号（ISN）</p><p>​b.协商TCP通信参数（MSS，窗口信息，指定校验和算法）</p><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102017022.png" alt="image-20220821102017022"></p><p>内核操作：</p><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102108877.png" alt="image-20220821102108877"></p><p>关闭连接：四次挥手</p><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102157493.png" alt="image-20220821102157493"></p><h4 id="字节流协议："><a href="#字节流协议：" class="headerlink" title="字节流协议："></a>字节流协议：</h4><p>MSS：Max Segment Size：默认536byte实际数据</p><p>TCP会依据Seq报文序列号进行排序，使得文件被划分为小信息发送时不会乱序</p><h4 id="可靠性-x2F-重传机制："><a href="#可靠性-x2F-重传机制：" class="headerlink" title="可靠性&#x2F;重传机制："></a>可靠性&#x2F;重传机制：</h4><h5 id="1-ack丢失："><a href="#1-ack丢失：" class="headerlink" title="1.ack丢失："></a>1.ack丢失：</h5><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102424659.png" alt="image-20220821102424659"></p><h5 id="2-请求报文丢失"><a href="#2-请求报文丢失" class="headerlink" title="2.请求报文丢失"></a>2.请求报文丢失</h5><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102536666.png" alt="image-20220821102536666"></p><h5 id="3-滑动窗口协议："><a href="#3-滑动窗口协议：" class="headerlink" title="3.滑动窗口协议："></a>3.滑动窗口协议：</h5><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102644054.png" alt="image-20220821102644054"></p><p>每次发送一组报文，并确定最后的报文是否收到回信，如果收到，表示报文全部被接收，直接跳至下一组，不必有重复</p><p>如果没有收到最后的报文，则往前推，直至从收到回信的部分（如图，3，5没有回信只收到12的回信，则12确认发送成功，不论4是否成功，3，4，5都和后面数据一起发送）</p><h1 id="HTTPS协议："><a href="#HTTPS协议：" class="headerlink" title="HTTPS协议："></a>HTTPS协议：</h1><p>HTTP具有”明文“特点，整个传输过程完全透明，任何人都可以在链路中截获、修改和伪造，数据具有不可信性</p><p>使用HTTPS，所有HTTP请求都会在请求和响应之前进行加密</p><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821103501204.png" alt="image-20220821103501204"></p><h3 id="SSL-x2F-TSL："><a href="#SSL-x2F-TSL：" class="headerlink" title="SSL&#x2F;TSL："></a>SSL&#x2F;TSL：</h3><p>SSL即安全套接层，由网景公司于1994年发明，IETF在1999年将其改名为TLS传输层安全，三个主流版本为2006的1.1，2008的1.2，2018的1.3，每个版本都紧跟密码学的发展和互联网现状，持续强化安全和性能，已经成为信息安全领域的权威标准</p><h3 id="摘要算法："><a href="#摘要算法：" class="headerlink" title="摘要算法："></a>摘要算法：</h3><p>将任意长度的数据”压缩“为固定长度，且独一无二的”摘要“字符，可以将其与明文一起发送，接收端解压字符后可以对比查看明文是否被篡改</p><p>如：md5</p><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><h5 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h5><p>编码使用相同的密钥进行加密解密（AES，RC4,ChaCha20）</p><h5 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h5><p>有两个密钥，一个”公钥“，一个”私钥“。前者可以给任何人使用，随意分发。后者需要保密，网站秘密保存</p><p><img src="/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/blog\source_posts\剖析Http请求\image-20220821104242155.png" alt="image-20220821104242155"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6补充</title>
      <link href="/2022/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>事物，锁机制</li><li>事物冲突问题</li><li>redis事物三特性</li><li>持久化框架</li><li>Redis主从复制</li><li>Redis集群</li><li>Redis应用问题解决</li></ul><h3 id="事物，锁机制："><a href="#事物，锁机制：" class="headerlink" title="事物，锁机制："></a>事物，锁机制：</h3><p>Redis事物：一个单独的隔离操作；事物中所有命令都会序列化，按顺序执行。事物执行过程中不会被其他客户端发送过来的命令请求打断</p><p>Redis事物主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p><h4 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi | Exec | discard"></a>Multi | Exec | discard</h4><p>输入Multi开启事务，此时被成为组队阶段，<strong>输入的命令不会马上执行</strong>，而是<strong>依次进入命令队列</strong>，直到输入Exec后，将命令队列中命令依次执行，组队过程中可以通过discard来放弃组队</p><p><img src="/2022/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817101242222.png" alt="image-20220817101242222"></p><h4 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h4><ol><li>组队时命令发生错误，事物无法执行Exec后的命令语句，<strong>一个都不执行</strong></li><li>组队时无误，执行时出现部分错误，<strong>错误的不执行，其他的执行</strong></li></ol><h4 id="为什么需要做成事物："><a href="#为什么需要做成事物：" class="headerlink" title="为什么需要做成事物："></a>为什么需要做成事物：</h4><p>同一份数据被多处调用时，可能会使得值变得不合理，例如多人登录同一台TB账户购买东西，余额同时读取后再依次修改是不合理的</p><h3 id="事务冲突问题："><a href="#事务冲突问题：" class="headerlink" title="事务冲突问题："></a>事务冲突问题：</h3><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h4><p>每次拿数据时都认为别人会修改，所以每次拿取数据时就上锁，其他人拿数据时就会black（阻塞）直至开锁，<strong>牺牲性能换效果</strong></p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p><strong>添加版本信息</strong>，仅在修改信息时匹配版本是否一致，一致则成功修改，否则更新数据再执行</p><p><img src="/2022/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817103825221.png" alt="image-20220817103825221"></p><h4 id="WATCH-K"><a href="#WATCH-K" class="headerlink" title="WATCH  K:"></a>WATCH  K:</h4><p>在执行multi之前，<strong>先执行watch k监视一个或多个key值</strong>，如果在事物执行之前这个key被改动，那么事务将会被打断</p><h3 id="Redis事务的三特性："><a href="#Redis事务的三特性：" class="headerlink" title="Redis事务的三特性："></a>Redis事务的三特性：</h3><ul><li>单独的隔离操作：事务中所有命令都会序列化，按顺序执行。事务在执行过程中不会被其他客户端发送的命令请求打断</li><li>没有隔离级别概念：队列中的命令没有提交之前都不会实际执行，因为事务提交前任何指令都不会执行</li><li>不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6基础</title>
      <link href="/2022/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6/"/>
      <url>/2022/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>NoSQl概述</li><li>行式&#x2F;列式数据库（大数据时代）</li><li>key键操作</li><li>5种基本数据类型</li><li>配置文件</li><li>发布与订阅</li><li>3种新数据类型</li></ul><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p><strong>基于K-V的高性能NoSQl数据库，提供了各种数据结构存储，具有高性能的多线功能</strong>，支持String（字符串） , list（链表） , set （集合）, zset（sorted set：有序集合） 和 hash（哈希类型）</p><p>Redis支持各种方式的<strong>排序</strong>，为了保证效率，<strong>数据都是存储在缓存中的</strong>，但Redis会<strong>周期性</strong>把更新的数据写入磁盘，在此基础上<strong>实现了master-slave（主从）同步</strong></p><p>Redis是 <strong>单线程 + 多路复用IO</strong> 技术；使用 <strong>6379端口</strong></p><h3 id="NoSql-数据库"><a href="#NoSql-数据库" class="headerlink" title="NoSql 数据库"></a>NoSql 数据库</h3><p>NoSQL （Not Only SQL）：意为“不仅仅是SQL”，泛指<strong>非关系型数据库</strong></p><p>NoSQL 不依赖业务逻辑存储方式，而是以简单的<strong>key-value</strong>模式存储，因此增加了数据库的扩展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><p>适用场景：</p><ul><li>对数据高并发读写</li><li>海量数据的读写</li><li>对数据高可扩展性</li></ul><p>不适用场景</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储</li></ul><p><strong>总之：用不着sql和用了sql也不行的情况，考虑Nosql</strong></p><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><p><img src="/2022/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6/image-20220816091921656.png" alt="image-20220816091921656"></p><h3 id="列式数据库："><a href="#列式数据库：" class="headerlink" title="列式数据库："></a>列式数据库：</h3><p><img src="/2022/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_6/image-20220816092128015.png" alt="image-20220816092128015"></p><h3 id="Key键操作"><a href="#Key键操作" class="headerlink" title="Key键操作"></a>Key键操作</h3><pre><code class="redis">keys *//查看全部keyexists K//查找key是否存在，返回1：存在；返回0：不存在type K//查看key是什么类型del K//删除对应K-V,返回1：成功unlink K//非阻塞删除对应K-Vexpire K int//为给定的K设置过期时间ttl K//查看还有多久数据过期（取不到）返回-1:永不过期,返回-2：已经过期select int//切换库dbsize//查看当前数据库的key数量flushdb//清空当前库flushall//通杀全部库</code></pre><h3 id="5种基本数据类型："><a href="#5种基本数据类型：" class="headerlink" title="5种基本数据类型："></a>5种基本数据类型：</h3><ul><li>String（字符串）</li><li>List（链表）</li><li>Set（集合）</li><li>Hash（哈希）</li><li>Zset（有序集合）</li></ul><h4 id="String（字符串）："><a href="#String（字符串）：" class="headerlink" title="String（字符串）："></a>String（字符串）：</h4><p>string是 <strong>二进制安全</strong> 的,意味着Redis的string可以包含任何数据，包括jpg图片或者序列化对象。</p><p>string是Redis中最基本的数据类型，一个·Redis中的value最多可以是 <strong>512M</strong></p><p>string底层数据结构就是<strong>简单的动态字符串</strong>，结构上类似Java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配</p><p>在字符串长度小于1M时，扩容为每次扩大一倍，大于1M时，每次扩容1M</p><p><strong>常见命令</strong></p><pre><code class="redis">set K V//设置键值对/覆盖已有的K-V键值对get K//取出K对应的Vappend K V//在原有K对应的V`后添加Vstrlen K//获取K对应V的长度setnx K V//设置键值对，如果已有K，返回0：设置失败，否则返回1：设置成功mset K1 V1 K2 V2..//设置一个或多个键值对mget K1 k2..//取出一个或多个V值getrange K int1 int2//获取K对应V的int1-int2部分内容：从0开始setrange K int V//将K对应V的int之后部分添加V再接原字符setex K int V//设置K-V同时设置过期时间getset K V //获取旧值，同时将新值写入// 原子操作*incr K//将K对应V值+1；如果V不是数字类型返回0，否则返回+1后的值decr K//将K对应V值-1；...否则返回-1的值incrby K int//将K对应V值+int;...decrby K int//...-int...msetnx K1 V1 K2 V2//同时设置多个K-V,当且仅当key都不存在</code></pre><h6 id="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"><a href="#原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）" class="headerlink" title="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"></a>原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）</h6><p>注：java中的i++并非是原子操作</p><p>![image-20220816101653161](.&#x2F;Redis 6&#x2F;image-20220816101653161.png)</p><h4 id="List（链表）："><a href="#List（链表）：" class="headerlink" title="List（链表）："></a>List（链表）：</h4><p><strong>单键多值</strong> ，即一个K对应多个V。底层实现是 <strong>双向链表</strong> ，数据结构为 <strong>快速链表</strong>（quickList）即在列表元素较少时使用的结构式ziplist（压缩列表），它将所有元素挨在一起存储，分配一块连续的内存。当数据量较大时才会改为quicklist</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><pre><code class="redis">lpush K V1 V2...//从左边(头节点)加入一个或多个值rpush K V1 V2... //从右边(尾节点)加入一个或多个值lrange K int1 int2  //从左边取出int1-int2的数据(顺序)：0是第一个，-1是最后一个lpop K //从左边吐出一个值,值在键在，值光键亡rpop K //从右边吐出一个值,...rpoplpush K1 K2//从K1右边取出值加到K2左边lindex K int //按照索引下标获得元素llen K//获得列表长度linsert K before V1 V2 //在V1前添加一个V2linsert K after V1 V2 //在V1后添加一个V2lrem K int V//从左边删除int个Vlset K int V//将列表K下标为int的值替换为V</code></pre><h4 id="Set（集合）："><a href="#Set（集合）：" class="headerlink" title="Set（集合）："></a>Set（集合）：</h4><p>set可以 <strong>自动排重</strong> ，且提供了<strong>判断某个成员是否在一个set集合</strong>的接口。</p><p>Redis的set是String类型的<strong>无序集合</strong>，底层是一个<strong>value为null的hash表</strong>，所以添加，删除，查找复杂度都是O(1)</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">sadd K V1 V2...//将一个或多个members元素添加至key中，已存在的会被忽略smembers K//取出该集合的所有值sismember K V//判断K集合中是否右V值，有返回1，否则返回0scard K//返回集合元素个数srem K V1 V2//删除集合中的一个或多个元素spop K//随机从集合中取出一个值，值完键亡srandmemberK int//随机取出int个值，不会在集合中删除smove K1 K2 V1 V2...//将K1中元素V1，v2..移动到K2中，返回移动元素个数sinter K1 K2//返回两个集合的交集元素sunion K1 K2//返回两个集合的并集元素sdiff K1 K2//返回两个集合的差集元素（在K1而不在K2）</code></pre><h4 id="Hash（哈希）："><a href="#Hash（哈希）：" class="headerlink" title="Hash（哈希）："></a>Hash（哈希）：</h4><p>Redis Hash是一个<strong>键值对集合</strong>，其value对应一个<strong>String类型的field</strong>和value映射表，适合用于存储对象，类似Java中的Map&lt;String, Object&gt;</p><p>![image-20220816150802600](.&#x2F;Redis 6&#x2F;image-20220816150802600.png)</p><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">hset K field value//在K中添加一个field-value对hget K field//返回K中field对应的值hmset K f1 v1 f2 v2//在K中批量设置field-value对hexists K field//查看中是否存在fieldhkeys K//列出K集合中全部的fieldhvals K//列出K集合中全部的valuehincrby K field int //给K中的field对应value值hsetnx K field value//为K添加field-value对，如果field原本存在则不会添加</code></pre><h4 id="Zset（有序集合）："><a href="#Zset（有序集合）：" class="headerlink" title="Zset（有序集合）："></a>Zset（有序集合）：</h4><p>Zset与set相同，是 <strong>没有重复元素</strong> 的字符串集合。不同之处是Zset每个成员都关联了一个<strong>评分（score）</strong>,score用于按照从低到高的方式对集合成员进行排序。</p><p><strong>集合成员是唯一的，但评分可以重复</strong></p><h5 id="常用命令：-1"><a href="#常用命令：-1" class="headerlink" title="常用命令："></a><strong>常用命令：</strong></h5><pre><code class="redis">zadd K score1 v1 s2 v2//添加一个或多个评分-值zrange K int1 int2 //返回排序从int1到int2的值zrange K int1 int2 withscores //返回排序从int1到int2的值，同时返回评分zrangebyscore K int1 int2//返回score在int1至int2中间的值，可以加withscoreszrevrangebyscore K int1 int2//逆序返回score在int1至int2中间的值，可以加with...zincrby K int V//给K中V的score增加intzrem K V//删除指定值zcount K int1 int2//统计集合中在int1-int2中的元素个数zrank K V//返回该值在集合中的排名，从0开始</code></pre><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>配置文件：redis.conf</p><blockquote><p>vi &#x2F;etc&#x2F;redis.conf</p></blockquote><pre><code class="redis">bind 127.0.0.1#限制仅本地连接protected-mode yes#仅本地访问，改为no即可允许非本地访问port:6379#端口tcp-backlog 511#目前已经完成三次握手以及正在三次握手的队列timeout0#超时时限，设为0则永不超时tcp-keepalive 300#心跳监测连接，每隔300s检查一次daemonize yes#允许后台启动pidfile...#保存进程号的位子loglevel notice#log保护级别：debug&gt;verbose&gt;notice&gt;warninglogfile &quot;&quot;#日志输出路径，默认为空database 16#redis默认16个数据库，用户默认使用0号库#密码requirepass与客户端LIMITSmaxmemory 10000#最大内存maxmemory-sample 5#样本数量maxclients 10000#最大连接数#持久化设置</code></pre><h3 id="发布与订阅："><a href="#发布与订阅：" class="headerlink" title="发布与订阅："></a>发布与订阅：</h3><pre><code class="redis"># /usr/local/bin/redis-cliSUBSCRIBE channel1#订阅channel1频道publicsh  channels hello#使channel1发布消息“hello”</code></pre><p>一种消息的沟通模式：<strong>频道收到消息后，所有订阅的对象都会收到对应消息</strong></p><h3 id="3种新数据类型："><a href="#3种新数据类型：" class="headerlink" title="3种新数据类型："></a>3种新数据类型：</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps:"></a>Bitmaps:</h4><p>BitMaps本身就是字符串Key-Value，但是可以对字符串进行位运算，可以把Bitmaps想象为一个以位为单位的数组，数组只能存储0和1，数组下标在BotMaps中被成为偏移量，最左边为0.</p><h5 id="常用命令：-2"><a href="#常用命令：-2" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">setbit K int1 int2#对K中int1号位子上改为int2（0/1）getbit K int#获取K中偏移量int中的值bitcount K#统计K中被设为1的数量bitcount K int1 int2 #统计K中int1到int2之间1的数量bitop and K1 K2#对K1，K2中为1的偏移量取与集，返回统计值bitop or K1 K2#对K1，K2中为1的偏移量取并集，...bitop not K1 K2#对K1，K2中为1的偏移量取差集，...bitop xor K1 K2#对K1，K2中为1的偏移量取异或，...</code></pre><p>![image-20220817090407369](.&#x2F;Redis 6&#x2F;image-20220817090407369.png)</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog:"></a>HyperLogLog:</h4><p>HyperLogLog只会根据输入元素计算*<strong>基数</strong>，不会存储输入元素本身</p><p><strong>基数</strong>：集合中不重复元素的总值被称为基数，如{1，6，3，4，3，9}，不重复元素为1，3，4，6，9 基数为5</p><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">pfadd K V1 V2#添加一个或多个元素pfcount K#统计基数pfmerge K1 K2 K3#将K2,K3中的值全部合并至K1</code></pre><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial:"></a>Geospatial:</h4><p>GEO:Geographic地理位置信息的缩写，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等操作</p><p>有效范围：经度：-180——180；纬度：-85——85</p><h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">geoadd K int1 int2 V  #设置K中的V：经度为int1，纬度为int2geopos K V#获取K中V的经纬度geodist K V1 V2m#获取V1到V2的直线距离，以米做单位（km千米，mi英里,ft英尺）georadius K int1 int2 int3 km#对K中处于经度int1纬度int2方圆int3km内的信息返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法题</title>
      <link href="/2022/08/13/leetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2022/08/13/leetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点："><a href="#1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点：" class="headerlink" title="1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点："></a>1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点：</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ol><li>遍历整个二叉树，将所有节点的父节点以&lt;Node，Node&gt;形式存入hashmap中</li><li>创建HashSet，从node1开始依据HashMap依次将自己的父节点存入HashSet中</li><li>从node2开始溯洄父节点，一旦存在HashSet中就停止，此时就是首个公共祖先节点</li></ol><pre><code class="java">//主函数public static Node finFather(Node head, Node node1, Node2) &#123;    HashMap&lt;Node,Node&gt; hashmap = new HashMap&lt;&gt;();    hashmap.put(head,head);     process(head,hashmap);    HashSet&lt;Node&gt; set1 = new HashSet&lt;&gt;();        Node o1 = node1;    //循环至头节点停下    while(o1 != hashmap.get(o1))&#123;        set1.add(o1);        o1 = hashmap.get(o1);    &#125;    //将头节点添加    set1.add(head);        Node o2 = node2;    while(set1.get(o2)==null)&#123;        o2 = hashmap.get(o2);    &#125;    return o2;&#125;//存储父节点函数public static void process(Node head, HashMap&lt;Node.Node&gt; hashmap) &#123;    if(hashmap == null) return;    hashmap.put(head.left,head);    hashmap.put(head.right,head);    process(head.left,hashmap);    process(head.right,hashmap);&#125;</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>分析node1与node2可能的关系：</p><ol><li>node1是node2的祖先 &#x2F; node2是node1的祖先：返回node1 &#x2F; node2</li><li>node1与node2彼此不互为公共祖先，返回向上汇聚的祖先节点</li></ol><pre><code class="java">public static Node findFather(Node head, Node node1, Node node2) &#123;    if(head == null || head == node1 || head == node2) &#123;        return head;    &#125;    Node left = findFather(head.left, node1, node2);    Node right = findFather(head.right, node1, node2);    if(left != null &amp;&amp; right != null) &#123;        return head;    &#125;    return left != null ? left : right;&#125;</code></pre><h3 id="2-二叉树找到一个节点的后继节点："><a href="#2-二叉树找到一个节点的后继节点：" class="headerlink" title="2.二叉树找到一个节点的后继节点："></a>2.二叉树找到一个节点的后继节点：</h3><pre><code class="java">public class Node &#123;    public Node left;    public Node right;    public Node parent;//指向父节点    public int value;        public Node(int val) &#123;        this.value = val;    &#125;&#125;</code></pre><p><strong>后继节点</strong>：中序遍历二叉树后，每个节点的下一个节点是此节点的后继节点</p><p>（中序遍历打印每一位节点，相邻的后一个打印的节点是前一位的后继节点，相邻的前一节点是后一节点的前驱节点）</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><p>中序遍历生成列表，依次查询列表找到后继节点</p><h5 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h5><p>分析后继节点的可能情况：</p><ol><li>当前节点存在右树：后继节点是右树的最左节点</li><li>当前节点没有右树：判断是否为父节点的左孩子：是，父节点为后继；不是，继续看父节点（没有右数说明已经是某左子树最后一个节点）</li><li>前两者无法找到后继节点：后继节点为空，这个节点是二叉树中序遍历的最后一个节点</li></ol><pre><code class="java">//主程序public static Node getNextNode(Node node) &#123;    if(node == null) return node;    if(node.right != null) &#123;//情况1        return getLeftMost(node);    &#125;else &#123;        Node parent = node.parent;        while(parent != null &amp;&amp; parent.left != node) &#123;//情况2和3            node = parent;            parent = node.parent;        &#125;        return parent;    &#125;&#125;//走左子树public static Node getLeftMost(Node node) &#123;    if(node == null) &#123;        return node;    &#125;    while(node.left != null) &#123;        node = node.left;    &#125;    return node;&#125;</code></pre><h3 id="3-二叉树序列化与反序列化"><a href="#3-二叉树序列化与反序列化" class="headerlink" title="3.二叉树序列化与反序列化"></a>3.二叉树序列化与反序列化</h3><p>内存 → 字符串 ：序列化</p><p>字符串 → 内存：反序列化</p><h5 id="先序序列化："><a href="#先序序列化：" class="headerlink" title="先序序列化："></a>先序序列化：</h5><pre><code class="java">public static String serialTree(Node head) &#123;    if(head == null) return &quot;#_&quot;;    String res = head.value + &quot;_&quot;;    res += serialTree(head.left);    res += serialTree(head.right);    return res;&#125;</code></pre><h5 id="先序反序列化："><a href="#先序反序列化：" class="headerlink" title="先序反序列化："></a>先序反序列化：</h5><pre><code class="java">//排序public static Node reconSerialTree(String str) &#123;    String[] values = str.split(&quot;_&quot;);    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    for(int i = 0; i != values.length; i++) &#123;        queue.add(values[i]);    &#125;    return reconOrder(queue);&#125;//组成树public static Node reconOrder(Queue&lt;String&gt; queue) &#123;    String value = queue.poll();    if(value.equals(&quot;#&quot;))&#123;        return null;    &#125;    Node head = new Node(Integer.valueOf(value));    head.left = reconOrder(queue);    head.right = reconOrder(queue);    return head;&#125;</code></pre><h5 id="中序，后序同理"><a href="#中序，后序同理" class="headerlink" title="中序，后序同理"></a>中序，后序同理</h5>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉数："><a href="#二叉数：" class="headerlink" title="二叉数："></a>二叉数：</h1><ul><li><p>二叉树递归遍历</p></li><li><p>二叉树非递归遍历</p></li><li><p>宽度优先遍历</p></li><li><p>搜索二叉树</p></li><li><p>完全二叉树</p></li><li><p>满二叉树</p></li><li><p>平衡二叉树</p><hr></li></ul><pre><code class="java">// 二叉树节点class Node&lt;V&gt; &#123;    V value;    Node left;    Node right;&#125;</code></pre><p>头节点：也叫根节点，二叉树最顶端的节点（无无父结点）</p><p>叶节点：左右子节点都为null</p><p>子树：以任意一节点为根，其衍生下可以直接相连或经过节点相连的全部节点组成的树</p><h3 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h3><h4 id="使用递归方式实现："><a href="#使用递归方式实现：" class="headerlink" title="使用递归方式实现："></a>使用递归方式实现：</h4><pre><code class="java">// 二叉树每个节点遍历时都有三次访问public static void f(Node head) &#123;    //1:start    if (head == null) &#123;        return null;    &#125;    ...    // 1:end    f(head.left);    // 2:start    ...    // 2:end    f(head.right);    // 3:start    ...    // 3:end&#125;</code></pre><p>*<strong>先序，中序，后序遍历即是在第一次，第二次，第三次访问节点时做反应</strong></p><p><img src="/2022/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220812185607833.jpg" alt="image-20220812185607833"></p><h5 id="遍历打印（每次访问打印一次value）："><a href="#遍历打印（每次访问打印一次value）：" class="headerlink" title="遍历打印（每次访问打印一次value）："></a>遍历打印（每次访问打印一次value）：</h5><p>1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1</p><h5 id="先序访问顺序（对每颗子树-头左右）："><a href="#先序访问顺序（对每颗子树-头左右）：" class="headerlink" title="先序访问顺序（对每颗子树 头左右）："></a>先序访问顺序（对每颗子树 头左右）：</h5><p>1 2 4 5 3 6 7</p><h5 id="中序访问顺序（对每颗子树-左头右）："><a href="#中序访问顺序（对每颗子树-左头右）：" class="headerlink" title="中序访问顺序（对每颗子树 左头右）："></a>中序访问顺序（对每颗子树 左头右）：</h5><p>4 2 5 1 6 3 7</p><h5 id="后序访问顺序（对每颗子树-左右头）："><a href="#后序访问顺序（对每颗子树-左右头）：" class="headerlink" title="后序访问顺序（对每颗子树 左右头）："></a>后序访问顺序（对每颗子树 左右头）：</h5><p>4 5 2 6 7 3 1</p><hr><h3 id="使用非递归方式实现二叉树："><a href="#使用非递归方式实现二叉树：" class="headerlink" title="使用非递归方式实现二叉树："></a>使用非递归方式实现二叉树：</h3><h5 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h5><ol><li>创建一个栈（Stack）对象，将头节点压入栈列</li><li>弹出栈顶节点 Car</li><li>打印处理 Car</li><li>先压入右节点，再压入左节点（有就压）</li><li>返回第二步，直至栈空</li></ol><pre><code class="java">//代码实现public static void preOrder(Node head) &#123;    if(head != null)&#123;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();        stack.push(head);        while(!stack.isEmpty()) &#123;            head = stack.pop();            System.out.println(head.value());            if(head.right != null) &#123;                stack.push(head.right);            &#125;            if(head.left != null) &#123;                stack.push(head.left);                    &#125;        &#125;    &#125;&#125;</code></pre><h5 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h5><ol><li>创建一个栈，将数的最左边界依次压入</li><li>弹出打印栈顶元素，若栈顶存在右子树，将右子树的最左边界依次压入</li><li>循环2，直至栈空</li></ol><pre><code class="java">public static void (Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();        while(!stack.isEmpty() || head != null) &#123;            if(head != null) &#123;                stack.push(head);                head = head.left;            &#125;else &#123;            head = stack.pop();            System.out.println(head.value());               head = head.right;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h5><ol><li>创建两个栈（存储栈和收集栈）</li><li>弹出存储栈头节点，压入收集栈</li><li>将2中弹出的节点，以先压左节点再压右节点的顺序压入存储栈</li><li>返回2，直到存储栈为空</li><li>依次打印收集栈顺序</li></ol><pre><code class="java">public static void posOrder(Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; st1 = new Stack&lt;&gt;();        Stacj&lt;Node&gt; st2 = new Stack&lt;&gt;();        st1.push(head);        while(!st1.isEmpty())&#123;            head = st1.pop();            st2.push(head);            if(head.left != null)&#123;                st1.push(head.left);            &#125;            if(head.right != null) &#123;                st1.push(head.right);            &#125;        &#125;        while(!st2.isEmpty())&#123;            System.out.println(st2.pop().value);        &#125;    &#125;&#125;</code></pre><hr><h3 id="实现二叉树的宽度优先遍历："><a href="#实现二叉树的宽度优先遍历：" class="headerlink" title="实现二叉树的宽度优先遍历："></a>实现二叉树的宽度优先遍历：</h3><h5 id="使用队列："><a href="#使用队列：" class="headerlink" title="使用队列："></a>使用队列：</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>弹出打印队列首个对象，将其左子树先放入队列，再放其右子树（如果有）</li><li>循环2，直到队列为空</li></ol><pre><code class="java">public static void widthOrder(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        System.out.println(head.value);        if(head.left != null) &#123;            queue.add(head.left);        &#125;        if(head.right != null) &#123;            queue.add(head.right);        &#125;    &#125;&#125;</code></pre><h5 id="算法题：求一个二叉树的最大宽度？"><a href="#算法题：求一个二叉树的最大宽度？" class="headerlink" title="算法题：求一个二叉树的最大宽度？"></a>算法题：求一个二叉树的最大宽度？</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>创建一个hashMap对象，用于记录节点与当前所在深度，将&lt;head, 1&gt;记录</li><li>创建初始深度（int）设为1，初始节点数（int）设为0，初始最大值（int）设为Integer.MIN_VALUE;</li><li>弹出队列首个对象，并根据HashMap判断该节点是否是当前深度的节点，是：节点数++，否：最大值&#x3D;max（max，节点数），深度++，节点数设为1</li><li>将其左子树先放入队列，hashMap放入&lt;head.left，深度+1&gt;；再放其右子树，hashMap放入&lt;head.right，深度+1&gt;（如果有）</li><li>循环2-5，直到队列为空</li><li>调用Max函数计算最后一行节点个数和最大节点的比较</li></ol><pre><code class="java">public static void getMaxWidth(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    HashMap&lt;Node,Integer&gt; levelMap = new HashMap&lt;&gt;();    levelMap.put(head,1);    int curlevel = 1;//当前层数    int curNodeNum = 0;//当前节点数    int max = Integer.MIN_VALUE;//最大节点值    while(!queue.isEmpty()) &#123;        head = queue.poll();        int levelNode = levelMap.get(head);        if(levelNode == curlevel) &#123;//判断是否变层            cerNodeNum ++;//未变层，节点数++        &#125;else &#123;            max = Math.max(max, curNodeNum);//下一层，结算上一层的max，重置当前节点数            curLevel ++;            curNodeNum = 1;        &#125;        if(head.left != null) &#123;            queue.add(head.left);            levelMap.put(head.left,curlevel+1)//记录左子树以及其对应层，用于后续判断        &#125;        if(head.right != null) &#123;            queue.add(head.right);            levelMap.put(head.right,curlevel+1)//记录右子树以及其对应层，用于后续判断        &#125;    &#125;    max = Math(max, curNodeNum);&#125;</code></pre><h5 id="不使用哈希表完成上述题目："><a href="#不使用哈希表完成上述题目：" class="headerlink" title="*不使用哈希表完成上述题目："></a>*不使用哈希表完成上述题目：</h5><p>使用两个Node变量替代哈希表（当前层最后的节点，下一层最后的节点）</p><p>将head赋予当前层最后节点，在每次新添左右节点时，分别更新下一层最后节点为左右节点</p><p>每次队列弹出都检查是否是当前层最后节点，是：更新最大值，拷贝下一层最后节点至当前层最后节点，层数++；否：节点数++</p><h3 id="二叉树深度优先遍历：先序遍历"><a href="#二叉树深度优先遍历：先序遍历" class="headerlink" title="二叉树深度优先遍历：先序遍历"></a>二叉树深度优先遍历：先序遍历</h3><hr><h3 id="搜索二叉树："><a href="#搜索二叉树：" class="headerlink" title="搜索二叉树："></a>搜索二叉树：</h3><p>对于每一个子树，都满足其左树值比根节点值小，右树值比根节点大（一般不存在重复值）</p><h5 id="如何判断是否是搜索二叉树：中序遍历为升序"><a href="#如何判断是否是搜索二叉树：中序遍历为升序" class="headerlink" title="如何判断是否是搜索二叉树：中序遍历为升序"></a>如何判断是否是搜索二叉树：中序遍历为升序</h5><pre><code class="java">public static int prevalue = Integer.MIN_VALUE;public static boolean isBSt(Node head) &#123;    if(head == null) return true;    boolean isLeftBst = isBST(head.left);//左子树是否为搜索二叉树    if(!isLeftBst) return false;    if(head.value &lt;= preValue) &#123;//升序判断，动态检查        return false;    &#125;else &#123;        preValue = head.value;    &#125;    return isBST(head.right);//左子树是搜索二叉树，右子树是否为搜索二叉树&#125;</code></pre><p>非遍历判断同理</p><h5 id="总结返回信息："><a href="#总结返回信息：" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左子树：1.左树应是搜索二叉树2.获取左数的最大值（用于与根比较）</p><p>对于右子树：1.右树应是搜索二叉树2.获取右数的最小值（用于与根比较）</p><p>统一左右子树返回信息：是否是搜索二叉树，最小值，最大值</p><h5 id="判断是否为搜索二叉树："><a href="#判断是否为搜索二叉树：" class="headerlink" title="判断是否为搜索二叉树："></a>判断是否为搜索二叉树：</h5><pre><code class="java">public static boolean checkBST(Node head) &#123;    return process(head).isBST;&#125;//返回类型public static class ReturnType &#123;    public boolean isBST;    public int min;    public int max;        public ReturnData(boolean isb, int min, int max)&#123;        this.isBST = isb;        this.min = min;        this.max = max;    &#125;&#125;public static ReturnType process(Node x) &#123;    if(x == null) return null;    ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);    //获得整个子树的最大最小值    int min = x.value;    int max = x.value;    if(leftData != null) &#123;        min = Math.min(min,leftData.min);        max = Math.max(max,leftData.max);    &#125;    if(rightData != null) &#123;        min = Math.min(min,rightData.min);        max = Math.max(max,rightData.max);    &#125;           boolean isBST = true;    if(leftData != null &amp;&amp; (!leftData.isBST || leftData.max &gt;= x.value) &#123;        isBST = false;    &#125;    if(rightData != null &amp;&amp; (!rightData.isBST || x.value &gt;= rightData.min) &#123;        isBST = false;    &#125;       return new ReturnType(isBST,min,max);&#125;</code></pre><h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p>所有节点依次按从左往右依次放入的二叉树属于完全二叉树</p><ol><li>任意一节点有右孩子无左孩子 → 不是完全二叉树</li><li><strong>宽度优先遍历</strong>且在<strong>不违反1</strong>前提下，出现首个左右孩子不双全时，之后的节点都应该是叶子节点</li></ol><pre><code class="java">public static boolean isCBT(Node head) &#123;    if(head == null) return true;    //是否遇到过左右孩子不双全的判断    boolean leaf = false;    Node l = null;    Node r = null;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        l = head.left;        r = head.right;        if((leaf &amp;&amp; (l!=null || r!=null))//条件2          ||           (l == null &amp;&amp; r == null)//条件1          )&#123;            return false;        &#125;        if(l != null) &#123;            queue.add(l);        &#125;        if(r != null) &#123;            queue.add(r);        &#125;        if(l == null || r == null) &#123;            //leaf 为不可逆改变            leaf = true;        &#125;       &#125;    return true;&#125;</code></pre><h3 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h3><p>子节点要么都有，要么都没有，不存在只存在一边节点的二叉树</p><h5 id="判断是否为满二叉树："><a href="#判断是否为满二叉树：" class="headerlink" title="判断是否为满二叉树："></a>判断是否为满二叉树：</h5><pre><code class="java">public static boolean isFBT(Node head) &#123;    if(head == null) &#123;        return true;    &#125;    info data = process(head);    return data.nodes == ((1&lt;&lt;data.height) - 1);&#125;//返回信息public static class Info &#123;    public int height;//高度    public int nodes;//节点数        public Info(int hei, int nod) &#123;        this.height = hei;        this.nodes = nod;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static Info process(Node x) &#123;    if(x == null) &#123;        return new Info(0, 0);    &#125;        Info leftData = process(x.left);    Info rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    int nodes = leftData.nodes + rightData.nodes + 1;        return new Info(height, nodes);&#125;</code></pre><h3 id="平衡二叉树："><a href="#平衡二叉树：" class="headerlink" title="平衡二叉树："></a>平衡二叉树：</h3><p>对于任意一颗子树，其左树高度和右树高度差不少过1</p><ol><li>节点左树是平衡二叉树</li><li>节点右树是平衡二叉树</li><li>|节点左树高度 - 节点右数高度| &lt;&#x3D; 1</li></ol><p>以上条件对每个节点都成立，这个树就是平衡二叉树，否则不是</p><h5 id="总结返回信息：-1"><a href="#总结返回信息：-1" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左树，我们希望知道：1.左树是否是平衡二叉树2.左树高度</p><p>对于右数，我们希望知道：1.右树是否是平衡二叉树2.右数高度</p><p>左右树需要的信息一致；</p><h5 id="判断是否为平衡二叉树："><a href="#判断是否为平衡二叉树：" class="headerlink" title="判断是否为平衡二叉树："></a>判断是否为平衡二叉树：</h5><pre><code class="java">//返回值的变动，调用其他方法返回public static boolean isBT(Node head) &#123;    return process(head).isBalanced;&#125;//返回信息public static class ReturnType &#123;    public boolean isBalanced;//是否是平衡二叉树    public int height;//高度        public ReturnType(boolean isB, int hei) &#123;        this.isBalanced = isB;        this.height = hei;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static ReturnType process(Node x) &#123;    if(x == null) &#123;        return new ReturnType(true, 0);    &#125;        ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    boolean isBalance = leftData.isBalanced &amp;&amp; rightData.isBalanced                        &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; 2;        return new ReturnType(isBalance, height);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h1><ul><li>类，超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装器与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射</li><li>继承的设计技巧</li></ul><h3 id="类，超类和子类："><a href="#类，超类和子类：" class="headerlink" title="类，超类和子类："></a>类，超类和子类：</h3><h5 id="使用关键字：extends-表示继承"><a href="#使用关键字：extends-表示继承" class="headerlink" title="使用关键字：extends 表示继承"></a>使用关键字：extends 表示继承</h5><pre><code class="java">public class A extends B &#123;    ...&#125;</code></pre><p>超类 &#x3D; 基类 &#x3D; 父类子类 &#x3D; 孩子类</p><h5 id="使用父类的方法：-super"><a href="#使用父类的方法：-super" class="headerlink" title="使用父类的方法： super"></a>使用父类的方法： super</h5><pre><code class="java">super.fun();//使用父类的fun方法super();//使用父类的构造器方法</code></pre><h5 id="多态：可将子类对象赋予给超类变量"><a href="#多态：可将子类对象赋予给超类变量" class="headerlink" title="多态：可将子类对象赋予给超类变量"></a>多态：可将子类对象赋予给超类变量</h5><pre><code class="java">Employee e;//Manager extends Employeee = new Employee();//OKe = new Manager();      //ok</code></pre><p>强制类型转换：A a &#x3D; (A) b;后续使用可能会报错</p><p>在超类强转为子类前可以使用：instanceof 监测是否能强转</p><pre><code class="java">if(b instanceof a)&#123;//如果b能强转为a，就可以将b转为a给予其他变量使用    c = (a)b;&#125;</code></pre><h5 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h5><p>使用abstract关键字的方法不需要具体实现</p><p>含有抽象方法的对象必须为抽象对象，抽象对象不可以被实例化</p><h3 id="Object：所有子类的超类"><a href="#Object：所有子类的超类" class="headerlink" title="Object：所有子类的超类"></a>Object：所有子类的超类</h3><h5 id="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"><a href="#equals方法：监测对象是否相等，比较对象的各个属性而非具体地址" class="headerlink" title="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"></a>equals方法：监测对象是否相等，比较对象的各个属性而非具体地址</h5><h5 id="hashCode方法：散列码，由对象导出的整型数"><a href="#hashCode方法：散列码，由对象导出的整型数" class="headerlink" title="hashCode方法：散列码，由对象导出的整型数"></a>hashCode方法：散列码，由对象导出的整型数</h5><p>每个对象的散列码基本不相同，可以用作区分不同对象的标识</p><h5 id="toString方法：返回字符串类型对象信息"><a href="#toString方法：返回字符串类型对象信息" class="headerlink" title="toString方法：返回字符串类型对象信息"></a>toString方法：返回字符串类型对象信息</h5><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><h5 id="ArrayList：自定义类型数组"><a href="#ArrayList：自定义类型数组" class="headerlink" title="ArrayList：自定义类型数组"></a>ArrayList：自定义类型数组</h5><pre><code class="java">ArrayList&lt;ClassName&gt; a = new ArrayLisrt&lt;&gt;();//ArrayList数组中全是ClassName类型对象var b = new ArrayList&lt;ClassName&gt;();//效果同上，java 10以后可以使用var避免重复书写类名</code></pre><p>使用trimToSIze()方法裁剪数组多余部分</p><h5 id="数组列表访问对象："><a href="#数组列表访问对象：" class="headerlink" title="数组列表访问对象："></a>数组列表访问对象：</h5><pre><code class="java">var A = new ArrayList&lt;ClassB&gt;();A.set(i,Obj);//使用set方法赋值，第几位，赋什么A.get(i);//获得第几位的信息A.size();//获取列表数量，不可以用length</code></pre><h3 id="对象包装器和自动包装"><a href="#对象包装器和自动包装" class="headerlink" title="对象包装器和自动包装"></a>对象包装器和自动包装</h3><p>有时会需要将int这样的基本类转换为对象，我们称这样的类为包装器：<br><strong>int - Integetlong - Longfloat - Floatdouble - Doubleshort - Shortchar -  Characterboolean - Boolean</strong></p><p>前六个类派生于公类Number</p><p>包装器类是不可变的，一旦构造便不允许更改其包装在其中的值，同时包装器也是final，不可以派生子类</p><pre><code class="java">ArrayList&lt;int&gt; ... //是错误的ArrayList&lt;Integer&gt; ... //是正确的</code></pre><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>在类后加上… 即可</p><pre><code class="java">public static double max(double... values)&#123;    double larger = Double.NEGATIVE_INFINITY    for(double v : values) if (v&gt;larger) larger = v;    return larger;&#125;double a = max(3.1, 40.2, -5);</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code class="java">public enum Size &#123; SMALL, MEDIUM, LAGER, EXTRA_LARGE &#125;;//枚举的各个方法static Enum valueOf(Class enumClass, String name)//返回给定类中有指定名字的枚举常量String toString()//返回枚举常量名int ordinal()//返回枚举常量在enum声明中的位子，从0开始记数int compareTo(E other)//如果枚举常量在other之前，返回负整数；如果other==this,返回0；否则返回正整数。枚举常量次序在enum声明中给出</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序被成为反射</p><h5 id="Class类："><a href="#Class类：" class="headerlink" title="Class类："></a>Class类：</h5><pre><code class="java">Employee A;Class cl = a.getClass();//保存一个Class类型实例，可以使用对应方法，如getName()String name = cl.getName();//name = &quot;Employee&quot;String ckassName = &quot;java.util.Random&quot;;Class cl = Class.forName(className);//效果同上Class c1 = Employee.class;//效果同上</code></pre><h5 id="异常：非检查型异常（unchecked），检查型异常（checked）"><a href="#异常：非检查型异常（unchecked），检查型异常（checked）" class="headerlink" title="异常：非检查型异常（unchecked），检查型异常（checked）"></a>异常：非检查型异常（unchecked），检查型异常（checked）</h5><p>异常可以通过在类名后添加 throws … 对应语句</p><h5 id="资源-："><a href="#资源-：" class="headerlink" title="资源 ："></a>资源 ：</h5><pre><code class="java">Class cl = ResourceTest.class;URL url = cl.getResource(&quot;b.gif&quot;);...//多种方法</code></pre><h5 id="检查类的结构：FIeld，Method，Constructor"><a href="#检查类的结构：FIeld，Method，Constructor" class="headerlink" title="检查类的结构：FIeld，Method，Constructor"></a>检查类的结构：FIeld，Method，Constructor</h5><p>java.lang.reflect 中的三个方法：FIeld，Method，Constructor 分别用于返回 字段，方法 和 构造器 的名称</p><p>其中：getDeclareFields，getDeclareMethods，getDeclareConstructors 返回声明中的全部字段，方法，构造器的数组</p><p>通过setAccessible方法可以覆盖Java的访问控制，避免私有属性调用报错</p><h5 id="newInstance方法："><a href="#newInstance方法：" class="headerlink" title="newInstance方法："></a>newInstance方法：</h5><p>提供Array的元素类型，提供数组长度即可生成对应数组</p><h5 id="invoke方法："><a href="#invoke方法：" class="headerlink" title="invoke方法："></a>invoke方法：</h5><p>允许调用Method中的方法</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口，lambda表达式与内部类"><a href="#接口，lambda表达式与内部类" class="headerlink" title="接口，lambda表达式与内部类"></a>接口，lambda表达式与内部类</h1><ul><li>接口</li><li>lambda表达式</li><li>内部类</li><li>服务加载器 (null)</li><li>代理</li></ul><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>使用关键字： interface (定义接口)， implements (实现接口)</p><p>接口中的方法自动为public，写接口时不需要赋予public权限词</p><h5 id="实现接口需要实现其全部方法"><a href="#实现接口需要实现其全部方法" class="headerlink" title="实现接口需要实现其全部方法"></a>实现接口需要实现其全部方法</h5><pre><code class="java">interface A;class B implements A;A a = new A();//错误A b;b = new B();//正确,可以声明接口变量，实例化为实现接口的对象</code></pre><h5 id="java是单继承，每个类只能有一个超类，但能实现很多接口"><a href="#java是单继承，每个类只能有一个超类，但能实现很多接口" class="headerlink" title="java是单继承，每个类只能有一个超类，但能实现很多接口"></a>java是单继承，每个类只能有一个超类，但能实现很多接口</h5><p>*使用 static ，private 关键词创造静态私有方法</p><p>使用 default 关键字创造默认方法，可以直接在接口中提供默认实现</p><pre><code class="java">public interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123; return 0; &#125;&#125;</code></pre><h5 id="默认方法冲突："><a href="#默认方法冲突：" class="headerlink" title="默认方法冲突："></a>默认方法冲突：</h5><ol><li>超类优先：如果超类提供了一个具体方法，同名且有相同参数的默认方法会被忽略</li><li>接口冲突：两个接口提供了同名同参的方法时，必须覆盖这个方法依解决问题（声明实现其中一个）</li></ol><h3 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="*lambda表达式："></a>*lambda表达式：</h3><p>目的： 方便的传递代码块</p><pre><code class="java">// 有参数lambda表达式(String first, String second) -&gt;&#123;    if(first.length() &lt; second.length()) return -1;    else if(first.length() &gt; second.length) return 1;    else return 0;&#125;// 无参数lambda表达式() -&gt;&#123;    for(int i=0; i&lt;100; i++)        System.out.println(i);&#125;//方法引用 (::)...//构造器引用 (new)</code></pre><h5 id="Comparing比较器"><a href="#Comparing比较器" class="headerlink" title="Comparing比较器"></a>Comparing比较器</h5><h3 id="内部类："><a href="#内部类：" class="headerlink" title="*内部类："></a>*内部类：</h3><p>内部类是定义在另一个类中的类，可以简洁的回调：</p><ol><li>内部类对同一个包中的其他类隐藏</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原有的私有数据</li></ol><h5 id="外围类引用：OuterClass-this"><a href="#外围类引用：OuterClass-this" class="headerlink" title="外围类引用：OuterClass.this"></a>外围类引用：OuterClass.this</h5><h5 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h5><p>不仅在类中，同时在局部（方法）中定义类，被称为局部内部类</p><h5 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h5><p>直接new对象并给定义（属性方法）不用设类名</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><p>将内部类声明为static就不会产生引用</p><h3 id="服务加载器："><a href="#服务加载器：" class="headerlink" title="服务加载器："></a>服务加载器：</h3><p>null</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理类包含以下方法：</p><ul><li>指定接口所需要的全部方法</li><li>Object类中的全部方法，如toString，equals等</li></ul><p>创建代理对象需要使用 Proxy 类的newProxyInstance方法，对应的三个参数为：</p><ul><li>一个类加载器 （class loader）</li><li>一个Class对象数组</li><li>一个调用处理器</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与类</title>
      <link href="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
      <url>/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="对象与类："><a href="#对象与类：" class="headerlink" title="对象与类："></a>对象与类：</h1><ul><li>面向对象程序设计概述</li><li>适用预定义类</li><li>用户自定义方法</li><li>静态字段与静态方法</li><li>方法参数</li><li>对象构造</li><li>包</li><li>JAR文件</li><li>文档注释</li><li>类设计技巧</li></ul><h3 id="面向对象程序设计概述-OOP"><a href="#面向对象程序设计概述-OOP" class="headerlink" title="面向对象程序设计概述(OOP)"></a>面向对象程序设计概述(OOP)</h3><h5 id="类：存储数据字段和方法的摸具"><a href="#类：存储数据字段和方法的摸具" class="headerlink" title="类：存储数据字段和方法的摸具"></a>类：存储数据字段和方法的摸具</h5><h5 id="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"><a href="#封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法" class="headerlink" title="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"></a>封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法</h5><h5 id="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"><a href="#对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）" class="headerlink" title="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"></a>对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）</h5><h5 id="识别类：Item，Order等为人熟悉的人为设计类"><a href="#识别类：Item，Order等为人熟悉的人为设计类" class="headerlink" title="识别类：Item，Order等为人熟悉的人为设计类"></a>识别类：Item，Order等为人熟悉的人为设计类</h5><h5 id="类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a"><a href="#类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a" class="headerlink" title="类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)"></a>类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)</h5><h3 id="使用预定义类："><a href="#使用预定义类：" class="headerlink" title="使用预定义类："></a>使用预定义类：</h3><p>使用构造器（constructor 构造函数）在目标类前加上 new 操作符</p><p>表示时间点的Date类</p><p>*表示日历的LocalDate类</p><h3 id="用户自定义类与自定义方法："><a href="#用户自定义类与自定义方法：" class="headerlink" title="用户自定义类与自定义方法："></a>用户自定义类与自定义方法：</h3><p>使用class关键字自定义类</p><p>“javac className*.java”与”javac classNameTest.java”都可以视为编译className类</p><h5 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h5><ul><li>构造器需要与类名同名</li><li>每个类可以有一个以上的构造器（0，1，2…个不同参数）</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作符一起调用</li></ul><p>var声明局部变量：仅能用于方法中，参数与字段仍需要声明</p><h5 id="实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"><a href="#实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改" class="headerlink" title="实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"></a>实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改</h5><h3 id="静态字段与静态方法："><a href="#静态字段与静态方法：" class="headerlink" title="静态字段与静态方法："></a>静态字段与静态方法：</h3><p>静态常量：static final</p><p>静态方法：static</p><p>工厂方法：使用静态方法构造对象</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>形参与实参</p><h3 id="对象构造："><a href="#对象构造：" class="headerlink" title="对象构造："></a>对象构造：</h3><h5 id="重载：多个方法具有相同的函数名，不同的参数"><a href="#重载：多个方法具有相同的函数名，不同的参数" class="headerlink" title="重载：多个方法具有相同的函数名，不同的参数"></a>重载：多个方法具有相同的函数名，不同的参数</h5><h5 id="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）"><a href="#默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）" class="headerlink" title="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）"></a>默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）</h5><h5 id="调用其他构造器：this-…"><a href="#调用其他构造器：this-…" class="headerlink" title="调用其他构造器：this(…)"></a>调用其他构造器：this(…)</h5><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><h5 id="英特网域名的作用之一就是保证-包名的唯一性"><a href="#英特网域名的作用之一就是保证-包名的唯一性" class="headerlink" title="英特网域名的作用之一就是保证 包名的唯一性"></a>英特网域名的作用之一就是保证 包名的唯一性</h5><h5 id="引入类的方法："><a href="#引入类的方法：" class="headerlink" title="引入类的方法："></a>引入类的方法：</h5><ol><li>直接使用 包名.类名</li><li>提前使用import声明引入包类</li></ol><p>包访问权限（public-全部，private-本类，protected-本包与子类，默认-本包）</p><h5 id="包-类路径：设置类路径-classpath（命令行指令）"><a href="#包-类路径：设置类路径-classpath（命令行指令）" class="headerlink" title="包.类路径：设置类路径 -classpath（命令行指令）"></a>包.类路径：设置类路径 -classpath（命令行指令）</h5><h3 id="JAR文件（java归档文件）："><a href="#JAR文件（java归档文件）：" class="headerlink" title="JAR文件（java归档文件）："></a>JAR文件（java归档文件）：</h3><p>jar文件是一种zip压缩文件</p><p>*目前常使用maven等协助打包</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>注释要写全，写细</p><h3 id="类设计技巧："><a href="#类设计技巧：" class="headerlink" title="类设计技巧："></a>类设计技巧：</h3><ol><li>保证数据私有</li><li>对数据进行初始化</li><li>不要在类中使用过多的基本类型</li><li>不是所有字段都需要单独的字段访问器和字段更改器</li><li>分解有过多指责的类</li><li>类名与方法名要能体现他们的职责</li><li>优先使用不可变的类</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计结构</title>
      <link href="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序设计结构"><a href="#Java程序设计结构" class="headerlink" title="Java程序设计结构"></a>Java程序设计结构</h1><ul><li>数据类型</li><li>变量与常量</li><li>运算符</li><li>字符串</li><li>输入输出</li><li>控制流</li><li>大数</li><li>数组</li></ul><h4 id="保留字与关键字："><a href="#保留字与关键字：" class="headerlink" title="保留字与关键字："></a>保留字与关键字：</h4><p>关键字：目前已经有特殊作用的单词字符，例如static，class等</p><p>保留字：包括关键字，同时还有部分目前未被使用，但未来可能会被使用的单词字符</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>八种基本类型，包括</p><ul><li><p>四种整型：int（四字节，正负21e），short（二字节，正负三万二），</p><p>​long（八字节，正负900ee），byte（一字节，-128—127）</p></li><li><p>两种浮点型：float（四字节），double（八字节）</p></li><li><p>一种字符型：char（二字节），用于表示Unicode编码的代码单元</p></li><li><p>一种用于表真值：boolean</p></li></ul><p>浮点数遵循IEEE 754规范：</p><p>NAN为非数字，例如0&#x2F;0会得到Double.NAN；</p><p>无穷大（正负）是特殊浮点Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY</p><h3 id="变量与常量："><a href="#变量与常量：" class="headerlink" title="变量与常量："></a>变量与常量：</h3><h5 id="变量：需要显式初始化变量"><a href="#变量：需要显式初始化变量" class="headerlink" title="变量：需要显式初始化变量"></a>变量：需要显式初始化变量</h5><pre><code class="java">boolean flag = false;</code></pre><h5 id="常量：使用关键字-static-final-设置常量，"><a href="#常量：使用关键字-static-final-设置常量，" class="headerlink" title="常量：使用关键字 static final 设置常量，"></a>常量：使用关键字 static final 设置常量，</h5><pre><code class="java">public static final int age = 18;</code></pre><h5 id="枚举类型：在有限集合内取值可以自定义枚举类型"><a href="#枚举类型：在有限集合内取值可以自定义枚举类型" class="headerlink" title="枚举类型：在有限集合内取值可以自定义枚举类型"></a>枚举类型：在有限集合内取值可以自定义枚举类型</h5><pre><code class="java">enum Size &#123; SMALL，MEDIUM，LARGE，EXTRA_LARGE &#125;;Size a = SIze.SMALL;</code></pre><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><h5 id="算数运算符（加减乘除余）：-x2F"><a href="#算数运算符（加减乘除余）：-x2F" class="headerlink" title="算数运算符（加减乘除余）：+ - * &#x2F; %"></a>算数运算符（加减乘除余）：+ - * &#x2F; %</h5><p>int类型会向下取整</p><h5 id="数学函数："><a href="#数学函数：" class="headerlink" title="数学函数："></a>数学函数：</h5><p>Math.sqrt（int a）：对a求平方根</p><p>Math.abs（int a） ：对a取绝对值</p><p>Math.round（double a）：对a四舍五入转为整型int</p><h5 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h5><p><img src="/2022/08/11/Java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/changeSize.jpg" alt="changeSize"></p><p>实线为无信息丢失的转换，虚线为存在精度丢失的转换</p><h5 id="关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D"><a href="#关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D" class="headerlink" title="关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;"></a>关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;</h5><h5 id="位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt"><a href="#位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt" class="headerlink" title="位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;"></a>位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;</h5><h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><h5 id="子串：（subString方法）"><a href="#子串：（subString方法）" class="headerlink" title="子串：（subString方法）"></a>子串：（subString方法）</h5><pre><code class="java">String str = &quot;Hello&quot;;String s = str.subString(0,3);//s = &quot;Hel&quot;,即0到2</code></pre><h5 id="相等：-equals方法"><a href="#相等：-equals方法" class="headerlink" title="相等：(equals方法)"></a>相等：(equals方法)</h5><pre><code class="java">if(str.equals(s))&#123;    return false;&#125;</code></pre><h5 id="空串与Null串："><a href="#空串与Null串：" class="headerlink" title="空串与Null串："></a>空串与Null串：</h5><pre><code class="java">if(str.length() == 0)//判断是否为空串：“”if(str == null)//判断是否为null串</code></pre><h5 id="构建字符串：（Stringbuilder类）"><a href="#构建字符串：（Stringbuilder类）" class="headerlink" title="构建字符串：（Stringbuilder类）"></a>构建字符串：（Stringbuilder类）</h5><pre><code class="java">//节省空间和时间的字节构建类型，直接append添加,toString成符StringBuilder bs = new StringBuilder();bs.append(&quot;a&quot;);bs.append(&quot;b&quot;);String s = bs.toString();</code></pre><h3 id="输入和输出："><a href="#输入和输出：" class="headerlink" title="输入和输出："></a>输入和输出：</h3><h5 id="Util-Scanner类："><a href="#Util-Scanner类：" class="headerlink" title="Util.Scanner类："></a>Util.Scanner类：</h5><pre><code class="java">Scanner in = new Scanner(System.in);String name = in.nextLine();int age = in.nextInt();</code></pre><h5 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h5><pre><code class="java">double x = 10000 / 3.0;System.out.printf(&quot;%8.2f&quot;,x);//返回八个字符，小数点算一个，且返回小数点后两位，不够八位在前补充空格                                //x = 3333.33      </code></pre><h5 id="转换符："><a href="#转换符：" class="headerlink" title="转换符："></a>转换符：</h5><p>d：十进制x：十六进制o：八进制f：定点浮点数e：指数浮点数    ….</p><h3 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h3><h5 id="块作用域：-…"><a href="#块作用域：-…" class="headerlink" title="块作用域：{…}"></a>块作用域：{…}</h5><p>块内变量不会带到块外使用，块外已定义变量不允许块内重复定义</p><h5 id="判断：if，if-else，if-else-if-else"><a href="#判断：if，if-else，if-else-if-else" class="headerlink" title="判断：if，if-else，if-else if-else"></a>判断：if，if-else，if-else if-else</h5><h5 id="循环：for，-while，-do-while"><a href="#循环：for，-while，-do-while" class="headerlink" title="循环：for， while， do-while"></a>循环：for， while， do-while</h5><h5 id="多重选择：switch-case-default"><a href="#多重选择：switch-case-default" class="headerlink" title="多重选择：switch-case-default"></a>多重选择：switch-case-default</h5><h5 id="跳出：return，break，continue"><a href="#跳出：return，break，continue" class="headerlink" title="跳出：return，break，continue"></a>跳出：return，break，continue</h5><h3 id="大数："><a href="#大数：" class="headerlink" title="大数："></a>大数：</h3><p>java.Math包下的：BigInteger和Bigdecimal（比int和double都更加精确）</p><pre><code class="java">BigDecimal a = new BigDecimal(&quot;0.1&quot;);//String转Big,精确BigDecimal a = new BigDecimal(0.1);//Double转Big,不精确，可能变成0.0999999998之类的</code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h5 id="声明与初始化："><a href="#声明与初始化：" class="headerlink" title="声明与初始化："></a>声明与初始化：</h5><pre><code class="java">int[] a;//声明int[] b = new int[100];//初始化a = &#123;1,2,3,4,5&#125;//赋值</code></pre><h5 id="循环：for，for-each"><a href="#循环：for，for-each" class="headerlink" title="循环：for，for-each"></a>循环：for，for-each</h5><h5 id="数组拷贝：Arrays-copyOf-：生成新数组的深拷贝"><a href="#数组拷贝：Arrays-copyOf-：生成新数组的深拷贝" class="headerlink" title="数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝"></a>数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝</h5><pre><code class="java">int[] c = Arrays.copyOf(a,a.length);//第一个参数为拷贝对象，第二个参数为创建数组c的长度</code></pre><h5 id="数组排序：Arrays-sort-：快速排序"><a href="#数组排序：Arrays-sort-：快速排序" class="headerlink" title="数组排序：Arrays.sort()：快速排序"></a>数组排序：Arrays.sort()：快速排序</h5>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
