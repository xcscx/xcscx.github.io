<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/02/27/Mysql%E5%A4%87%E4%BB%BD/"/>
      <url>/2023/02/27/Mysql%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><ul><li>数据库备份语句与恢复语句</li><li>注意事项</li><li>示例展示</li><li>遇到的问题</li></ul><h3 id="数据库备份语句与恢复语句"><a href="#数据库备份语句与恢复语句" class="headerlink" title="数据库备份语句与恢复语句"></a>数据库备份语句与恢复语句</h3><pre><code class="mysql">-- 数据库备份mysqldump -u [username] -p [database_name] &gt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要备份的数据库名</p><p>[base_path]：存储文件的地点、</p><pre><code class="mysql">-- 数据库恢复mysql -u [username] -p [database_name] &lt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要恢复的数据库名</p><p>[base_path]：存储文件的地点</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>备份是mysqldump，恢复是mysql</li><li>输入命令后，系统会要求你填写登录密码，如果在 -p 后填入密码会报错</li><li>最后的参数是路径+文件名+.sql后缀，记得查看是否有权限在目标地址写文件</li></ol><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><img src="/2023/02/27/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113332873.png" alt="image-20230227113332873"></p><p>没有报错信息就是最好的信息！</p><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li>输入：mysqldump -u root -p 02-index &gt;  C:\Users\13620\Desktop\02-index.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1045: Access denied for user ‘ODBC‘@’localhost’ (using password: YES) when trying to connect</strong></p><p>问题：没有对应地点的写入权限</p><p>解决：更改写如位置为D:\02-index.sql （有权限的地方都可以）</p><ol start="2"><li>输入：mysqldump -u root -p docker&gt;  C:\Users\13620\Desktop\docket.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1049: Unknown database ‘docker’ when selecting the database</strong></p><p><img src="/2023/02/27/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113618736.png" alt="image-20230227113618736"></p><p>问题：数据库表输入错误</p><p>解决：改对表名</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题</title>
      <link href="/2022/12/21/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/12/21/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-和-JRE-和-JVM-分别是什么，有什么区别？"><a href="#JDK-和-JRE-和-JVM-分别是什么，有什么区别？" class="headerlink" title="JDK 和 JRE 和 JVM 分别是什么，有什么区别？"></a>JDK 和 JRE 和 JVM 分别是什么，有什么区别？</h2><p>1，**JDK (Java Development Kit)**：JDK是Java开发工具包，包含了编写，编译，调试和运行java程序所需要的所有工具和组件，比如编译器（javac），javaAPI，调用工具等。JDK是针对Java开发人员的，它包含JRE，还有一编译器和其他工具，可以用来编写和调试Java程序。</p><p>2，**JRE (Java Runtime Environment)**：JRE是java运行时环境，包括了Java虚拟机（JVM）和Java标准类库（JavaAPI）JRE是争对Java应用程序的，它提供了在计算机上运行的Java应用程序所需的最小环境。</p><p>3，**JVM (Java Virtual Machine)**：JVM是Java虚拟机，是Java程序运行的环境。JVM负责将java代码解释或编译为本地机器代码，并在运行时提供必要的环境支持，比如内存管理，垃圾回收，安全新等。JVM的主要作用时将Java代码转化为可以在计算机上运行的机器码，并负责程序的执行。</p><p>综上所述，JDK，JRE和JVM在区别上可以总结如下：</p><p><strong>JDK时Java开发工具包</strong>，包括了编译器，JavaAPI，调试工具等，用于Java开发应用程序</p><p><strong>JRE是Java运行时环境</strong>，包括了Java虚拟机和Java标准类库，用于在计算机上运行Java应用程序</p><p><strong>JVM是Java虚拟机</strong>，是Java程序运行的环境，负责将java代码转换为可以在计算机上运行的机器码，并提供必要的环境支持</p><h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>字节码是Java程序编译后的中间代码，是一种可移植的二进制代码，可以在任何支持Java虚拟机（JVM）的平台上运行。字节码通过Java源代码编译为字节码指令序列，使得Java程序可以跨平台运行，即使在不同的操作系统和硬件平台上也可以运行。</p><p>字节码采用中间代码的形式，相比于直接将程序编译为特定平台上的机器码，有以下几个好处</p><ol><li>可移植性：由于字节码是中间代码，所以可以在任何支持JVM的平台上运行，使得Java程序具有很好的可移植性。这也是Java跨平台的重要特征之一。</li><li>安全性：由于字节码需要在JVM中运行，所以可以对字节码进行安全检查，以确定程序不会对系统造成威胁。</li><li>性能：由于字节码是一种紧凑的二进制格式，相比于直接编译为机器码，可以更快速的加载和传输，同时也可以在运行时动态优化，提高程序的执行效率。</li><li>可读性：相比于直接编译为机器码，字节码具有更好的可读性，可以方便的进行反汇编和调试</li></ol><p>因此，采用字节码作为中间代码的最大好处是提高了Java程序的可移植性，安全性，性能和可读性。这也是Java跨平台和安全性的基础</p><h2 id="什么是数据库事务？讲一下事务的-ACID-特性？"><a href="#什么是数据库事务？讲一下事务的-ACID-特性？" class="headerlink" title="什么是数据库事务？讲一下事务的 ACID 特性？"></a>什么是数据库事务？讲一下事务的 ACID 特性？</h2><p>数据库事务是指数据库管理系统DBMS中的一个操作序列，这些操作必须作为一个不可分割的单元执行，要么全部执行成功，要么全部失败回滚。事务通常涉及到对数据库中的数据进行读写操作。</p><p>事务的ACID特性是指其四个关键特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）</p><ol><li>原子性：事务是一个原子操作，要么全部提交，要么全部回滚。当一个事务执行期间发生故障，操作系统便会自动将其回滚到事务执行之前的状态，保证数据的一致性。</li><li>一致性：事务执行结束后，数据必须保持一致的状态。在事务执行期间，数据库的数据可以处于中间状态，但是在事务完成时必须保持数据的一致性。</li><li>隔离性：数据库系统必须保证事务之间的相互隔离，不会相互干扰。隔离级别不同，会影响事务的并发性和一致性，比如出现脏读，不可重复读，幻读等。</li><li>持久性：一旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发生故障或者宕机，数据也能够保持不变。</li></ol><p>ACID特性是保证事务正确性和数据一致性的重要手段。在设计数据库应用程序时，应该根据具体的业务需求和数据库安全性要求，选择合适的隔离级别和事务提交策略，保证事务的可靠性和数据的一致性。</p><h2 id="Java-和-C-、Go-语言的区别，各自的优缺点？"><a href="#Java-和-C-、Go-语言的区别，各自的优缺点？" class="headerlink" title="Java 和 C++、Go 语言的区别，各自的优缺点？"></a>Java 和 C++、Go 语言的区别，各自的优缺点？</h2><p><strong>Java是一种面向对象的编程语言</strong>，醉蛛被设计用于开发嵌入式系统，现在广泛应用于企业应用，Web应用和移动应用开发等领域。Java优点包括：</p><ol><li>跨平台性强：Java虚拟机（JVM）可以在不同操作系统上运行java程序，使得开发者可以编写一次代码并在多个平台上运行</li><li>安全性高：Java有很多安全特征，例如自动内存管理，类的访问权限控制，异常处理等，可以有效避免一些常见安全漏洞</li><li>生态系统完备：Java的生态系统非常完善，有很多成熟的框架和工具可以帮助开发者快速构建复杂的应用</li></ol><p><strong>C++是一种系统级编程语言</strong>，最初设计用于操作系统和系统软件的开发，现在也广泛用于游戏，图形图像处理，嵌入式系统等领域。C++的优点包括：</p><ol><li>新能高：C++是一种编译型语言，可以生成高效的机器代码，所以在处理大量数据和对计算效率又要求的应用场合下具有优势</li><li>控制能力强：C++具有非常高的控制能力，可以直接操作计算机的硬件和内存等资源</li><li>应用领域广泛：C++适用于开发大型系统，高性能应用和底层软件，如操作系统，数据库，游戏引擎等</li></ol><p><strong>Go是一种开源的编程语言</strong>，由Google公司开发，被设计用于开发高并发，分布式系统。Go的优点包括：</p><ol><li>并发能力强：Go具有轻量级的线程（goroutine）基于消息传递的通道（channel），可以方便地实现并发编程</li><li>内存管理高效：Go的内存管理采用自动垃圾回收装置，使得开发者可以更加专注于业务逻辑</li><li>语言特性简单：Go的语法简单易懂，代码易于阅读和维护，同时提供了丰富的标准库和工具支持</li></ol><h2 id="什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？"><a href="#什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？" class="headerlink" title="什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？"></a>什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？</h2><p>Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，也被称为数据结构等服务。它支持多种类型的数据结构，如字符串，哈希，列表，集合，有序集合等，并提供了丰富的操作这些数据结构的命令。</p><p>Redis的特点包括：</p><ol><li>高性能：Redis使用内存来存储数据，并且数据存储在单一进程中，因此速度非常快</li><li>多样的数据类型：Redis支持多种数据结构，包括字符串，哈希，列表，集合，有序集合等。</li><li>持久化：Redis支持多种持久化方式，包括RDB快照和AOF日志</li><li>分布式：Redis支持分布式部署，可以将数据分布在多个节点上</li><li>简单易用：Redis提供了丰富的命令，使得操作数据非常方便</li></ol><p>Redis的常见应用场景包括：</p><ol><li>缓存：Redis可以作为缓存使用，加速数据读取和响应速度</li><li>消息队列：Redis提供了列表和发布&#x2F;订阅功能，可以用来实现消息队列</li><li>计算器：Redis的计算器功能非常高效，可以用来实现页面访问量，点击量等的·计数</li><li>排行榜：Redis的有序集合功能可以用来实现排行榜</li><li>分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问</li><li>实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析的速度</li></ol><p>总之，Redis具有高性能，多样的数据类型，分布式，简单易懂等特点，可以应用于各种场景，特别适合用于解决读写频繁的问题</p><h2 id="简述计算机网络七层模型和各自的作用？"><a href="#简述计算机网络七层模型和各自的作用？" class="headerlink" title="简述计算机网络七层模型和各自的作用？"></a>简述计算机网络七层模型和各自的作用？</h2><p>计算机网路七层模型是一个把网络通信协议分为七个层次的标准模型，其目的是为了让计算机网络的设计和管理更加灵活和模块化。这个模型被称为OSI模型（Open System Interconnection Model）,它由国际标准话组织（ISO）于1984年发布，是一个开放的标准模型。</p><p>每个层次都有自己独立功能和责任，这种分层的方式使得每个层次都可以独立工作，同时还能够很好地协调上下层之间的数据传输，而不需要依赖于其他层次的实现细节。以下是每个层的具体功能和责任：</p><ol><li>物理层：主要负责通过物理媒介传输比特流，如光纤，电缆，无线电波等。物理层规定了物理连接的规范，包括电缆类型，接口规范等</li><li>数据链路层：主要负责把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配，数据流量控制，错误校验等</li><li>网络层：主要负责数据在网络中的传输，包括路由选择，分组转发，数据报文的封装等。网络层还处理数据包的寻址和控制流量等</li><li>传输层：主要负责数据传输的可靠性和流量控制等，同时还包括分段，组装，连接建立和断开等功能。传输层最重要的两个协议是TCP和UDP</li><li>会话层：主要负责建立，管理和终止会话，提供会话控制和同步等服务。会话层层还负责处理多个应用程序之间的数据交换。</li><li>表示层：主要负责数据格式转换，加密解密，压缩解压等服务。表示层使得应用程序可以使用不同数格式和编码，同时还提供数据的安全性和完整的保护服务</li><li>应用层：主要提供各种服务和应用程序，如电子邮件，文件传输，远程登录，Web浏览等，应用层服务可以使用不同协议实现，如HTTP，SMTP，FTP，TELNET等</li></ol><p>现在较为常用的是TCP&#x2F;IP模型，它包含四层：应用层，传输层，网路层和数据链路层。</p><h2 id="JDK-动态代理和-CGLIB-动态代理的区别是什么？"><a href="#JDK-动态代理和-CGLIB-动态代理的区别是什么？" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理的区别是什么？"></a>JDK 动态代理和 CGLIB 动态代理的区别是什么？</h2><p>JDK动态代理和CGLIB动态代理都是Java中动态代理的两种实现方式，它们的区别主要在以下几个方面：</p><ol><li>实现方式：JDK动态代理是通过<strong>反射</strong>实现的，而CGBIL动态代理是通过<strong>继承目标类</strong>来实现的</li><li>目标类限制：JDK动态代理要求目标类必须<strong>实现接口</strong>，而CGBIL动态代理没有这个限制</li><li>性能：JDK动态代理相对于CGBIL动态代理来说，因为实现方式的不同，生成的代理效率会低一些</li><li>对象类型：JDK动态代理只能代理实现了接口的类，而CGBIL动态代理可以代理任何类</li><li>依赖库：JDK动态代理是Java自带的库，不需要额外的依赖，而CGBIL动态代理需要依赖cglib库</li></ol><p>在使用动态代理时，可以根据需要和具体场景选择合适的实现方式，JDK动态代理适用于接口代理的场景，而CGBIL动态代理适用于类代理场景</p><h2 id="MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用"><a href="#MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用" class="headerlink" title="MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用"></a>MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用</h2><p>MySQL是一款流行的关系型数据库，其日志是关键功能之一。MySQL包括三种类型的日志：binlog，redolog和undolog，它们分别有各自的作用和特点。</p><ol><li>binlog（Binary log）：MySQL种的二进制日志文件，用于记录MySQL服务器上所有的更新和修改操作。它可以记录所有的DDL（Data Definition Language）和DML（Data Modification Language）操作，包括对表结构的更改，数据的插入，修改，删除等等。binlog是在事务提交后生成的，因此可以用于恢复数据库。</li><li>redolog（Redo log）：用于恢复数据，保证数据的一致性和持久性。当MySQL发生修改时，redolog会将这些操作记录下来，并写入磁盘。这样，当MySQL发生宕机或崩溃时，通过redolog就可以回复数据。</li><li>undolog（Undo log）：用于回滚操作，当MySQL发生事务回滚时，undolog会记录这些操作并写入磁盘。这样，当MySQL需要回滚时，通过重放undolog就可以回滚事务。</li></ol><p>区别：</p><p>​binlog和redolog都是MySQL中的二进制日志，但是它们的作用和实现方式有所不同。binlog是MySQL操作的记录日志，而redolog是保证数据一致性和持久性的日志。此外，binlog是逻辑日志，redolog是物理日志。binlog可以跨平台使用，而eredolog不行。undolog和redolog区别是：undolog用于回滚操作，redolog用于回复数据。</p><h2 id="Spring-框架是什么？使用-Spring-框架有哪些好处？"><a href="#Spring-框架是什么？使用-Spring-框架有哪些好处？" class="headerlink" title="Spring 框架是什么？使用 Spring 框架有哪些好处？"></a>Spring 框架是什么？使用 Spring 框架有哪些好处？</h2><p>Spring框架是一个开源的Java企业应用程序框架，它通过依赖注入（DI：Dependency Injection）和面向切面编程（Aspect Oriented Proframming）等技术为开发者提供了一个全面的编程和配置模型。它可以降低Java开发的复杂度，提高代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。</p><p>使用Spring框架有以下好处：</p><ol><li>依赖注入（DI）：通过Spring框架的依赖注入功能，开发者可以将应用程序中的不同组件之间的依赖关系交给Spring来管理，从而降低组件之间的耦合度，并方便后续的组件替换和维护。</li><li>支持切面编程（AOP：Aspect Oriented Programming）：Spring框架提供了面向切面编程的支持，可以将不同组件关联起来，从而降低了应用程序中的重复代码量，并提高了代码的可重用性和可维护性。</li><li>提供了多种技术整合方案：Spring框架可以与其他的Java企业引用程序框架和技术进行整合，如Hibernate，Mybatis，Struts，JSF等，从而降低了技术整合的复杂度</li><li>支持声明式事务管理：Spring框架提供了声明事务管理的支持，开发者可以通过配置来管理应用程序中的事务，从而简化了事务管理的过程。</li><li>提供了Ioc容器：Spring框架提供了一个Ioc容器，可以实现对应程序的不同组件进行管理，并支持对组件进行AOP增强，从而实现了应用程序中的组件解耦和高度可配置性。</li><li>便于配置：Spring框架可以方便的进行单元测试和集成测试，提高了代码的可测试性和可靠性</li></ol><h2 id="Java-中-final-关键字有什么用"><a href="#Java-中-final-关键字有什么用" class="headerlink" title="Java 中 final 关键字有什么用"></a>Java 中 final 关键字有什么用</h2><p>在Java中，final关键字用于表示一个不可变的常量或一个不可变的变量，final关键字开源修饰类、方法和变量</p><ol><li>final修饰类，表示该类不能被继承。final类中的方法都是默认final，不能被子类重写</li><li>final修饰方法，表示该方法不能被子类重写</li><li>final修饰变量，表示该变量只能被赋予一次。final修饰的变量必须在申明时或构造函数中初始化，且不能再被改变。常用于定义变量。</li></ol><p>除此之外，使用final修饰的变量在编译时就确定了其值，因此在运行时访问比非final变量更快</p><p>使用final关键字可以带来的好处：</p><ol><li>安全性：将变量声明为final可以防止它被改变，从而提高安全性</li><li>可读性：将常量声明为final可以提高代码的可读性，因为常量的值不会被改变</li><li>优化：final变量在编译时被转变为常量，这可以提高程序的性能</li></ol><h2 id="HTTP-是哪一层的协议？简述它的作用？"><a href="#HTTP-是哪一层的协议？简述它的作用？" class="headerlink" title="HTTP 是哪一层的协议？简述它的作用？"></a>HTTP 是哪一层的协议？简述它的作用？</h2><p>HTTP是应用层协议，主要用于Web浏览器和Web服务器之间的传递数据。它是一种无状态的协议，即服务器不会保存关于客户端的任何信息，每次客户端发送请求，服务器都会返回响应。HTTP协议通常基于TCP协议，使用TCP的80端口作为默认的传输端口。HTTP协议主要作用包括：</p><ol><li>建立连接：客户端与服务器建立TCP链接，然后发送HTTP请求，服务器接收请求并处理</li><li>发送请求：客户端发送HTTP请求到服务器，包括请求方法（GET，POST，PUT等），请求头（如User-Agent，Accept等）和请求正文（可选）等信息。</li><li>请求处理：服务器接收并解析HTTP请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端</li><li>返回响应：服务器返回HTTP响应，包括响应状态码（如200 OK，404 Not Found等），响应头（如Content-Type,Cache_Control等）和响应正文（可选）等信息。</li><li>关闭连接：客户端接收到响应后，关闭TCP连接</li></ol><p>HTTP的响应报文主要包括以下几个部分：</p><ol><li>状态行：包含HTTP协议版本，状态码和状态消息。</li><li>响应头：包含一些响应头部信息，例如Server，Control-Type，Content_Length等</li><li>空行：表示响应头结束</li><li>响应体：实际响应数据，例如网页的HTML代码，图片，音频等。</li></ol><p>HTTP的状态码指示了服务器对请求的处理结果。常见的状态码包括200 OK（请求成功），301 MovedPermanently（永久重定向），404 Not Found（未找到资源）和500 Internal Server Error（服务器内部错误）等</p><p>总之，HTTP协议的作用是规定了Web应用程序中客户端和服务器之间的通讯方式和数据传输格式，是支持Web应用开发的基础协议。</p><h2 id="什么是进程和线程？它们有哪些区别和联系？"><a href="#什么是进程和线程？它们有哪些区别和联系？" class="headerlink" title="什么是进程和线程？它们有哪些区别和联系？"></a>什么是进程和线程？它们有哪些区别和联系？</h2><p>在操作系统中，<strong>进程是指一个正在执行的程序</strong>，而<strong>线程是进程的一部分，是一个程序中执行的代码片段</strong></p><p><strong>进程是操作系统资源分配的最小单位</strong>，一个进程至少包括一个线程，进程拥有自己的内存空间，文件句柄，环境变量等资源系统。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通讯需要通过进程间通信机制（IPC）来实现</p><p><strong>线程是程序执行的最小单位</strong>，一个进程中可以包含多个线程，它们共享进程的内存空间和资源系统。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通讯可以通过共享内存，信号量等机制实现</p><p>进程与线程的区别与联系如下：</p><ol><li>资源分配：进程拥有自己的内存空间等系统资源，而是线程共享进程的资源</li><li>独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源</li><li>调度：进程间调度开销比线程大，线程调度开销小，可以并发执行</li><li>并发性：多个进程之间相互独立，多个线程可以并发执行</li><li>同步：进程间通讯需要通过IPC机制，线程间同步可以通过共享内存，信号量等机制实现、</li></ol><p>实际开发中，多线程应用更加常见，因为线程开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。</p><h2 id="Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？"><a href="#Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？" class="headerlink" title="Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？"></a>Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？</h2><p>在Java中mhashCode和equals方法都是Object类的方法。它们作用如下：</p><p>hashCode方法返回对象的哈希码，用于支持基于哈希表的集合，如HashMap，HashSet等。如果两个对象的equals方法返回true，则它们的hashCode方法必然返回相同的值，反之则不必然</p><p>equals方法用于比较对象是否相等。默认情况下，equals方法使用的是 &#x3D;&#x3D; 操作符，即只有两个对象引用指向同一个对象时才会返回true。但是，大部分情况下，我们需要重写equals方法来实现自己定义的相等规则。</p><p>两者之间的区别在于hashCode方法返回的是一个int类型的数值，而equals方法返回的是一个boolean类型的值。</p><p>hashCode方法用于快速比较两个对象是否不同，毕竟如果哈希码不同，那么它们肯定不相等。equals方法用于判断两个对象是否真正相等，这个判断比较复杂，需要根据对象的实际情况来定义</p><p>另外，需要注意的是， &#x3D;&#x3D; 操作符用于比较两个对象的引用是否相等，即它们是否指向同一个对象，而equals方法则用于比较两个对象的值是否相等</p><p>在Java中，对象值的比较往往需要更具对象实际情况来定义，因此一般需要重写equals方法</p><h2 id="Spring-的两大核心概念是什么？简单讲一下你对它们的理解"><a href="#Spring-的两大核心概念是什么？简单讲一下你对它们的理解" class="headerlink" title="Spring 的两大核心概念是什么？简单讲一下你对它们的理解"></a>Spring 的两大核心概念是什么？简单讲一下你对它们的理解</h2><p>Spring 框架的两大核心概念是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）</p><p><strong>控制反转</strong>指的是将对象的创建和依赖注入由应用代码转移到Spring容器中进行，即由Spring容器负责创建对象和管理它们之间的依赖关系。这样，应用代码只需要关注业务逻辑的实现，而不是关注对象的创建和管理，降低了应用代码的复杂度，提高了代码的可重用性和可维护性。</p><p><strong>面向切面编程</strong>是指将业务逻辑无关的代码（如日志，安全，事务等）从业务逻辑中剥离出来，以便于统一管理和维护。通过AOP，我们可以将这些业务逻辑无关的横切关注点（Cross-cutting Concerns）定义切面（Aspect），并将它们织入到业务逻辑中，从而实现了业务逻辑与横切关注点的解耦</p><p>这两个概念是Spring框架的核心，它们使得Spring框架具有了高度的可用性，灵活性和模块性，极大的提高了应用程序的开发效率和代码的可维护性</p><h2 id="死锁是什么？如何预防和避免死锁？"><a href="#死锁是什么？如何预防和避免死锁？" class="headerlink" title="死锁是什么？如何预防和避免死锁？"></a>死锁是什么？如何预防和避免死锁？</h2><p>死锁是指两个或多个进程在执行过程中因争夺资源而造成的一种僵局，当进程处于死锁状态时，它们将无法继续执行，而只能相互等待，直到被外部程序干预或者自行放弃。</p><p>预防和避免死锁需要采取一些措施，包括：</p><ol><li><strong>避免资源独占</strong>：尽量避免一个进程在获得了某些资源后再次请求其他资源，而采取应用所需资源一次性申请到位。</li><li><strong>避免资源持有和等待</strong>：当一个进程占用了一些资源并等待另一些资源时，其他进程就无法使用这些资源，容易发送死锁。因此，尽可能减少资源的持有和等待时间。</li><li><strong>避免资源互斥</strong>：有些资源在同一时间只能被一个进程占用，比如打印机，磁带机等，需要采用一些技术手段来避免资源的互斥问题。</li><li><strong>引入资源掠夺策略</strong>：当一个进程请求的资源被其他进程占用时，可以采取掠夺资源的策略，即暂停占用该资源的进程，直到该资源被释放后再恢复该进程的执行。</li><li><strong>引入进程抢占策略</strong>：当一个进程等待时间过长时，可以采取抢占其他资源的策略，即终端正在执行的进程，强制释放其占用的资源</li></ol><p>以上是一些避免和预防死锁的方法，具体选择哪种方法需要根据具体情况进行分析和判断。</p><h2 id="什么是反射机制？说说反射机制的优缺点、应用场景？"><a href="#什么是反射机制？说说反射机制的优缺点、应用场景？" class="headerlink" title="什么是反射机制？说说反射机制的优缺点、应用场景？"></a>什么是反射机制？说说反射机制的优缺点、应用场景？</h2><p>Java反射机制是指在运行时动态的获取了类的信息、创建对象以及调用对象的属性和方法的机制。Java反射机制提供了运行时检查Java类信息的能力，让Java程序可以通过程序获取其本身的信息。</p><p>Java反射机制的优点：</p><ol><li>可以动态的获取类的信息，不需要在编译时就知道类的信息</li><li>可以动态的创建对象，不需要在编译时就知道对象的类型</li><li>可以动态的调用对象的属性和方法，可以在运行时动态的改变对象的行为</li></ol><p>Java反射机制的缺点：</p><ol><li>由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性</li><li>由于反射是动态的，所以它会破坏Java的封装性，可能会使代码变得复杂和不稳定</li></ol><p>Java反射机制的应用场景：</p><ol><li>动态代理。动态代理可以使用反射机制在运行时动态的创建代理对象，而不需要在编译时就知道接口的实现类</li><li>单元测试。JUnit等单元测试框架可以使用在反射机制在运行时动态的获取类的方法信息，实现自动化测试</li><li>配置文件加载。许多框架（如Spring）使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。</li></ol><h2 id="数据库索引是什么，有什么作用，什么场景适合使用索引？"><a href="#数据库索引是什么，有什么作用，什么场景适合使用索引？" class="headerlink" title="数据库索引是什么，有什么作用，什么场景适合使用索引？"></a>数据库索引是什么，有什么作用，什么场景适合使用索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大的提高数据检索的效率。</p><p>索引的作用是通过构建一个额外的数据结构（B-tree，哈希表等）来加速数据的检索。它是在数据库表上查询的一种数据结构，它包含一些指向表中数据的指针，可以快速定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列缩影，组合缩影，全文索引等待多种方式来创建</p><p>适合使用索引的场景包括：</p><ol><li>频繁查询的列，如主键，外键等。</li><li>经常作为查询条件的列，如WHERE，ORDER BY，GROUP BY等语句中的列。</li><li>经常需要连接的列，如多表联合查询时的列</li><li>数据量较大的表，通过索引可以加快数据的检索速度</li></ol><p>索引的优点是可以提高数据库的查询速度，缩短数据检索的时间，提高系统的性能。但是索引也有缺点：</p><ol><li>占用额外的存储空间，增加了存储成本</li><li>建立索引需要时间，增加了系统的开销</li><li>数据库的更新操作（增删改）会导致索引的重建，避免过度索引导致系统性能下降</li></ol><h2 id="HTTP-有哪些常见的状态码？"><a href="#HTTP-有哪些常见的状态码？" class="headerlink" title="HTTP 有哪些常见的状态码？"></a>HTTP 有哪些常见的状态码？</h2><p>HTTP（超文本传输协议）常见的状态码有以下几种：</p><ul><li><p>1XX（信息类状态码）：指示已经收到请求，正在继续处理</p></li><li><p>2XX（成功状态码）：请求已经被接收，理解和接受</p><ul><li>200 OK：请求已经成功处理</li><li>201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li><li>204 No Content：服务器依据成功处理了请求，但是没有返回任何实体内容</li></ul></li><li><p>3XX（重定向状态码）：需要镜像附加操作以完成请求</p><ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客服端发送了一个带条件的请求，服务器允许请求访问资源，但是请求为满足条件</li></ul></li><li><p>4XX（客户端错误状态码）：请求包含错误语法或不能被执行</p><ul><li>400 Bad Request：请求报文存在语法错误</li><li>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在。</li></ul></li><li><p>5XX（服务器错误状态码）：服务器在处理请求的过程中发生了错误</p><ul><li>500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。</li><li>502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效请求。</li><li>503 Service Unavailable：服务器暂时处于超负荷或正在停机维护，无法处理请求</li></ul></li></ul><p>状态码是服务器读客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理</p><h2 id="访问修饰符-public、private、protected，以及无修饰符（默认）时的区别"><a href="#访问修饰符-public、private、protected，以及无修饰符（默认）时的区别" class="headerlink" title="访问修饰符 public、private、protected，以及无修饰符（默认）时的区别"></a>访问修饰符 public、private、protected，以及无修饰符（默认）时的区别</h2><p>在Java中，访问修饰符指的是控制类，接口，方法，属性等成员的访问范围。Java提供了四种访问修饰符，分别是public，private，protected和默认（无修饰符）</p><ul><li>public：可以被任何类或对象访问</li><li>private：只能被定义该成员的类访问，其他类无法访问</li><li>protected：可以被当前类，子类和同一个包中的类访问</li><li>默认（无修饰符）：可以被同一个包中的类访问</li></ul><p>各个修饰符的特点：</p><ul><li>public可以被任何类或对象访问，因此其访问范围最大，但也可能会存在安全问题。</li><li>private限制了访问范围，可以有效保护数据的安全，但是可能会增加代码的耦合度</li><li>protected提供了一种在继承中使用的访问控制方式，但是可能会导致模块间的耦合</li><li>默认（无修饰符）访问范围比protected更小，只能被同一个包中的类访问，可以减小模块间的耦合</li></ul><p>访问修饰符的选择需要根据具体情况来考虑，不能一概而论。通常情况下，应该尽可能的将成员设置为private，只在需要的情况下使用 public 或 protected</p><p>在同一个类中，成员可以直接访问其他成员，无论其访问修饰符是什么</p><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p>线程间通信是多线程编程中非常重要的一个概念。在多线程编程中，有时候需要让线程之间进行数据交换，协作工作。以下是几种线程间的通信方式：</p><ol><li>共享内存：线程之间通过访问同一块共享内存区域来实现数据交换</li><li>消息队列：一个线程向消息队列中放入一条消息，另一个线程从消息队列中取出消息。</li><li>管道（Pipe）：管道是一种半双工的通信方式，一个进程可以向管道中写入数据，另一个进程可以从管道中读取数据</li><li>信号（Signal）：信号是一种异步通信的方式，进程收到信号后，会根据信号的类型做出相应的处理</li><li>互斥锁（Mutex）：用于同步访问共享资源，防止多个线程同时访问共享资源，产生冲突</li><li>条件变量（Condition Variable）：用于线程之间的协调和通信，一个线程可以通过条件变量等待某个·条件的出现，另一个线程可以通过条件变量通知正在等待的线程</li></ol><h2 id="什么是分布式？为什么需要分布式？"><a href="#什么是分布式？为什么需要分布式？" class="headerlink" title="什么是分布式？为什么需要分布式？"></a>什么是分布式？为什么需要分布式？</h2><p>分布式是指在堕胎计算机上协同完成工作的系统，这些计算机通过网络连接在一起，共同完成一个任务。</p><p>分布式系统能够有效解决单台计算机处理能力不足，系统容易宕机，数据存储容量有限等问题，同时能够提高系统的可靠性，可用性和性能，适用于数据量较大，并发量高，访问平凡的场景。此外，分布式系统还可以通过横向扩展的方式提高系统的性能和可靠性，同时降低单点故障的风险，提高了系统的可伸缩性，方便进行升级和维护。</p><p>在分布式系统中，由于数据和计算任务被分布在多台计算器上，不同计算机之间需要进行通信和协调，因此需要解决分布式一致性，负载均衡，故障回复，数据共享和安全等问题，同时需要考虑数据的一致性和可靠性。因此，分布式系统的设计和实现比单机系统更加复杂和困难，需要考虑到多个因素的综合影响。</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql连接本地数据库时报网络问题"><a href="#MySql连接本地数据库时报网络问题" class="headerlink" title="MySql连接本地数据库时报网络问题"></a>MySql连接本地数据库时报网络问题</h1><p>今早起床学习大佬面经时，发现自己数据库都登不上去了<img src="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\63aae1ca1cac76b665567fb840a6da6.png" alt="63aae1ca1cac76b665567fb840a6da6"></p><p>不论是命令行还是Navicat登录都是报以上错误，可我这是个本地的数据库，不应该存在网络错误呀。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>经过大佬的指点，重启服务中的Mysql，数据库的访问就正常了<img src="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\image-20221130103336695.png" alt="image-20221130103336695"></p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>尽管问题很快被解决，但是我依然想不通为什么会报这种错误，认识到自己的不足，也就有了下面的学习，鉴于以往没有过这种错误，无从下手，我决定先翻译这段报错：</p><p><strong>‘‘读取初始通信数据包时失去与MySQL服务器的连接，系统错误: 0”</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6常见问题</title>
      <link href="/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片学习内容整理至b站 <a href="https://space.bilibili.com/526653251">IT老哥</a> 的视频 <a href="https://www.bilibili.com/video/BV1sR4y1c7Ni?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">《会了这些面试题后，可以挑战一下字节了》</a></p></blockquote><ul><li>单线程的Redis为什么快</li><li>五种基本数据类型底层采用什么数据结构</li><li>缓存雪崩，缓存穿透，缓存击穿，附加</li><li>Redis的过期淘汰机制</li><li>redis与memcached的区别</li><li>redis线程模型</li><li>哨兵Sentinel</li><li>如何实现redis事务</li></ul><h2 id="单线程的Redis为什么快？"><a href="#单线程的Redis为什么快？" class="headerlink" title="单线程的Redis为什么快？"></a>单线程的Redis为什么快？</h2><p>Redis有多快？官方给出的读写速度是10w&#x2F;s，在单线程的前提下跑出这个好成绩，原因有以下几点：</p><ul><li><strong>Redis是完全基于内存</strong>的，因此读写效率高，同时Redis的持久化操作是通过fork子进程和Linux系统的页面缓存技术完成，并不会影响Redis</li><li><strong>单线程操作</strong>：单线程避免了频繁上下文切换导致的性能开销</li><li>合理高效的<strong>数据结构</strong></li><li>采用了<strong>非阻塞的IO多路复用机制</strong>：多路I&#x2F;O复用模型是利用select，poll，epoll可以同时监察多个流的IO事件的能力，在空闲时阻塞当前线程，当有一个或多个流有IO事件时，就从阻塞中唤醒，程序再依次轮询所有的流，并且只依次顺序处理就绪的流，这种做法避免了大量无用操作</li></ul><h2 id="五种基本数据类型底层采用什么数据结构"><a href="#五种基本数据类型底层采用什么数据结构" class="headerlink" title="五种基本数据类型底层采用什么数据结构"></a>五种基本数据类型底层采用什么数据结构</h2><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>存储数字时：int存储长度大于39字节字符：raw存储长度小于39字节字符：embstr</p><p>raw与embstr都是由SDS动态字符串构成的。唯一区别是raw分配存储时，redisobject 和 sds 各分配一块，而 embstr 是 redisobject 在一块内存中</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：双向链表</p><h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：哈希表</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>列表所有对象都是整数，且元素数量小于512：inset否则：哈希表</p><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset:"></a>Zset:</h4><p>列表所有对象长度均小于64字节，且元素数量小于128：ziplist否则：跳表</p><h2 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h2><p>在高并发下，大量缓存key在同一时间集体失效，大量请求直接落在数据库上，导致数据库宕机</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><ul><li>随机设置key失效时间，避免大量key集体失效</li></ul><pre><code class="redis">setRedis(Key, value, time+Math.random()*10000);</code></pre><ul><li>如果是集群部署，可以将热点数据均匀分布在不同的Redis库中避免key全部失效</li><li>跑定时任务，在缓存失效前刷新新缓存</li><li>不设置过期时间（不推荐）</li></ul><h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>redis缓存没有数据库中没有相关数据（如用户查询携带id&#x3D;-1的相关数据并不断发起请求），redis中没有数据，无法进行阻拦，请求直接穿透到数据库，导致数据库压力过大宕机</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>对不存在的数据将其缓存到redis中，设置key，value值为null（不论是数据未null还是系统bug），设置一个短期过期时间，避免影响用户正常使用</li><li>拉黑用户IP</li><li>对参数进行校验，不合法参数进行拦截</li><li>布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap (位图) 中，一个一定不存在的数据会被这个bitmap拦截掉，减少对底层存储系统的查询压力</li></ul><h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>某一个热点key，在不停的扛着高并发，当这个热点key在失效的一瞬间，持续的高并发访问就击破缓存直接访问数据库，导致数据库宕机</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>设置热点数据“永不过期”</li><li>加上互斥锁：对于多个线程同时去查询数据库的热点数据，我们可以在第一个查询数据上的请求使用互斥锁锁住它</li></ul><p>其他线程需要使用就得等待，第一个线程查询到了数据，将数据放置redis中缓存起来，后面的进程就可以直接使用缓存数据</p><h2 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h2><p>提前避免以上三问题：将redis，mysql等搭建成高可用集群，放置单点</p><p>出现错误如何修补    ：服务中进行限流 + 降级，放置mysql被打崩溃</p><p>实在严重到宕机补救：Redis持久化 RDB + AOF，宕机重启，自动从磁盘加载数据，快速回复缓存数据</p><h2 id="Redis的过期淘汰机制："><a href="#Redis的过期淘汰机制：" class="headerlink" title="Redis的过期淘汰机制："></a>Redis的过期淘汰机制：</h2><p>Redis中数据过期策略采用定期删除 + 惰性删除策略</p><h4 id="1-定期删除，惰性删除策略是什么："><a href="#1-定期删除，惰性删除策略是什么：" class="headerlink" title="1.定期删除，惰性删除策略是什么："></a>1.定期删除，惰性删除策略是什么：</h4><ul><li>定期删除：Redis启用一个定时器定时监听所有key，判定key是否过期，过期就删除。尽管可以保证所有的过期key都会被删除，但是十分浪费cpu资源，且对于以及过期但是定时器还没启动的key，它任然可以使用。</li><li>惰性删除：在获得key时，先判断key是否以及过期过期就删除，缺点：如果这个key一直没被使用，那么它一直在内存，即便已经过期，这会浪费大量空间。</li></ul><h4 id="2-定期删除-惰性删除是如何工作的："><a href="#2-定期删除-惰性删除是如何工作的：" class="headerlink" title="2.定期删除 + 惰性删除是如何工作的："></a>2.定期删除 + 惰性删除是如何工作的：</h4><p>每次随机抽取一部分key进行检查，减少CPU资源的损耗，惰性删除策略互补了未检查到的key，基本上满足了所有要求</p><h4 id="3-补充的内存淘汰机制："><a href="#3-补充的内存淘汰机制：" class="headerlink" title="3.补充的内存淘汰机制："></a>3.补充的内存淘汰机制：</h4><ul><li><p>volatile - lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile - ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile - random：从已设置过期时间的数据集（server.db[i].expires）中挑选任意数据淘汰</p></li><li><p>allkeys - lru：当内存不足以容纳新写入的数据时，在键空间内，移除最近最少使用的key<strong>（这个最常用）</strong></p></li><li><p>allkeys - random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-eviction：禁止驱逐数据，永不过期，也就是当内存不足以写入新数据时，写入操作会报错<strong>（默认）</strong></p></li><li><p>volatile - lfu：4.0后加入，从已设过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p></li><li><p>allkeys - lfu：4.0后加入，当内存不足以写入新数据时，在键空间中，移除最不经常使用的key</p></li></ul><h2 id="Redis与memcached的区别："><a href="#Redis与memcached的区别：" class="headerlink" title="Redis与memcached的区别："></a>Redis与memcached的区别：</h2><p>存储方式上：memcached会将全部数据存入内存中，如果发生断电则会挂掉，数据不可以超过内存大小；redis有部分存在硬盘中，能保证数据的持久性</p><p>数据支持类型：memcached支持的数据类型相对简单；redis有复杂的数据类型</p><p>使用的底层模型不同：它们之间的底层实现，客户端之间通讯的应用协议不一样，redis自己构建了vm机制，因为一般的系统调用系统函数会浪费一定时间去移动和请求。value值大小不同，redis最大可到1gb；memcached只有1mb</p><h2 id="Redis线程模型："><a href="#Redis线程模型：" class="headerlink" title="Redis线程模型："></a>Redis线程模型：</h2><p>redis内部使用文件处理器 file event handler，这个文件事件处理器是单线程的，所以redis才叫单线程处理器模型。它采用IO多路复用机制监听多个socket，根据socket上事件处理器进行处理</p><p>文件事件处理器的结构包括4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）</li></ul><p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应事件处理器进行处理。</p><h2 id="哨兵Sentinel："><a href="#哨兵Sentinel：" class="headerlink" title="哨兵Sentinel："></a>哨兵Sentinel：</h2><p>哨兵是Redis高可用的解决方案，可以运行多个Sentinel组成一个哨兵分布式系统</p><p>哨兵主要解决的问题：故障转移，如果主节点挂掉，就进行主从切换，让从节点升级为主节点，继续对外提供服务</p><p>使用流言协议（gossip protocols）来接收主机是否下线；并使用投票协议（agreeement protocols）来决定是否执行自动故障转移；以及选择哪个服务器作为新的主服务器</p><h4 id="哨兵职责如下："><a href="#哨兵职责如下：" class="headerlink" title="哨兵职责如下："></a>哨兵职责如下：</h4><ul><li><p>监控：Sentinel会不断定期检查主服务器和从服务器是否运作正常</p></li><li><p>提醒：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或其他应用程序发送通知</p></li><li><p>自动故障迁移：当一个主服务器不能正常工作时，Sentinel会开启一次自动故障迁移操作，将失效服务器的其中一个从服务器升级为新的主服务器，并让失效服务器的其他服务器改为复制新的主服务器，当客户端连接失败主服务器时，集群也会向客户端返回新服务器地址，使得集群可以使用新主服务器替代失效服务器</p></li><li><p>统一配置管理：连接者询问Sentinel取得主从的地址</p></li></ul><h2 id="如何实现redis事务："><a href="#如何实现redis事务：" class="headerlink" title="如何实现redis事务："></a>如何实现redis事务：</h2><p>redis通过MULTI，EXEC，WATCH等命令来实现事务（transaction）功能，事务提供了一种将多个命令请求打包，然后一次性，按顺序的执行多个命令的机制，且在事务执行期间，服务器不会中断事务而改去执行其他客户端的请求，只有到这多个命令执行完毕后，才会接收其他命令</p><p>Redis事务也具有：原子性，一致性，隔离性；在特定情况下具有持久性</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http状态码</title>
      <link href="/2022/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2022/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>HTTP（超文本传输协议）常见状态码有以下几种：</p><ul><li>1XX （信息类状态码）：请求已经收到，进行后续处理</li><li>2XX （成功状态码）<ul><li>200 成功：请求已经被成功实现</li><li>201 Created：请求已经被实现，且现有一个新的资源已经依据请求的需要而建立</li><li>204 No Content：服务器成功处理了请求，但是没有返回任何实体内容</li></ul></li><li>3XX （重定向状态码）：需要镜像附加操作以完成请求<ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客户端发送了一个带条件的请求，服务器允许请求访问资源，但是请求的条件不满足</li></ul></li><li>4XX （客户端错误状态码）：请求包含错误语法或不能被执行<ul><li>400 Bad Request：请求报文存在错误语法</li><li>401 Unauthorized：表示发送的请求需要通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在</li></ul></li><li>5XX （服务器错误状态码）：服务器处理请求的过程中发生了错误<ul><li>500 Internal Server Error：服务器遇到了一个未曾预料到的状况，导致无法完成请求的处理</li><li>502 Bad Gateway：充当网关的服务器，从远处服务器收到了一个无效请求</li><li>503 Service Unavaliable：服务器暂时处于超负荷或停机状态，无法处理请求</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap常见问题</title>
      <link href="/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Hashmap是否线程安全？为什么？"><a href="#Hashmap是否线程安全？为什么？" class="headerlink" title="Hashmap是否线程安全？为什么？"></a>Hashmap是否线程安全？为什么？</h3><p>不安全，JDK7存在死循环和数据丢失问题。</p><p><strong>数据丢失</strong>：</p><ol><li><strong>并发赋值被覆盖</strong>：在createEntry方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖</li><li><strong>已遍历区间新增元素丢失</strong>：当某个线程在transfer方法迁移时，其他线程新增的元素可能以及落在已经遍历过的哈希槽上。遍历完成后，table数组引用指向了newTable，新增元素丢失</li><li><strong>新表被覆盖</strong>：如果resize完成，执行了table &#x3D; newTable，则后续元素就可以在新表上进行插入。但如果多线程同时resize，每个线程都会new一个数组，这是线程内的局部对象，线程之间不可见。迁移后resize的线程会赋值给table线程共享变量，可能会覆盖其他线程操作，在新表中插入的对象都会被丢弃。</li></ol><p><strong>死循环</strong>：</p><p>扩容时resize调用transfer使用头插法迁移元素，虽然newTable是局部变量，但原先的table中Entry链表是共享的，问题根源是Entry的next指针并发修改，某线程还没有将table设为newTable时用完了CPU时间片，导致数据丢失或死循环。</p><p>JDK8在resize方法中完成了扩容，并改为尾插法，不会产生死循环，但并发下仍可能丢失数据。可用ConcurrentHashMap 或 Collections.synchronizedMap包装成同步集合。</p><h3 id="JDK7与JDK8的hashmap有什么区别："><a href="#JDK7与JDK8的hashmap有什么区别：" class="headerlink" title="JDK7与JDK8的hashmap有什么区别："></a>JDK7与JDK8的hashmap有什么区别：</h3><p>JDK7是数组 + 链表，JDK8是数组 + 链表&#x2F;红黑树</p><ol><li><strong>链表插入方式不同</strong>：1.7之前，链表元素插入采用头插法，每当有新节点进入时，会插入在链表头部，由于不用遍历链表，这种插入方式效率高；1.8以后当节点插入时，因为需要判断元素个数而遍历链表（是否达到转为树的阈值），所以顺带改为尾插，即插到链表尾部，这解决了多线程下可能引发的死锁问题，因为头插法的链表在扩容移动时，会被逆序，即后插入的先处理，如果这时候有另一线程进行get操作，就可能引发死锁</li><li><strong>插入时机不同</strong>：1.7之前是扩容后再插入新的数据，并且不会先计算值的哈希值，最后单独计算；1.8之后是先插入再扩容，插入值和大家一起计算新的哈希值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get使用</title>
      <link href="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/"/>
      <url>/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/</url>
      
        <content type="html"><![CDATA[<p>原链接：<a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">视频同步笔记：狂神聊Git (qq.com)</a></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>在开发过程中用于管理我们的文件，目录或工程等内容的修改历史，方便查看历史记录，备份以便回复以前的版本的软件工程技术</p><ul><li>实现跨域多人协同开发</li><li>追踪和记载一个或多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量‘</li><li>并行开发，提高工作效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说；一种管理多人协同开发项目的技术</p><blockquote><p>常见版本控制工具：</p><p>GitSVNCVSVSSTFS</p></blockquote><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><blockquote><p>安装：</p></blockquote><p>进入官网，下载git（windows 64-bit.exe）&#x2F;  使用镜像下载 , 无脑下一步（<a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a>）</p><p>注：环境变量只是为了全局使用而已，不是必需品</p><blockquote><p>卸载：</p></blockquote><p>环境变量中删除Git , 再去卸载中心卸载程序</p><blockquote><p>使用：</p></blockquote><p>安装成功后，右键任意文件夹都会出现Git Bash（Unix与Linux风格命令行）和Git CMD（Windows风格命令行）</p><h3 id="Linux简单口令"><a href="#Linux简单口令" class="headerlink" title="Linux简单口令"></a>Linux简单口令</h3><pre><code class="Linux">cd改变目录cd..退回到上一级目录,直接cd进入默认目录pwd显示当前所在路径ls(||)ls和ls||都是列出当前目录中的所有文件,只不过后者列出的内容更为详细touch新建一个文件夹,如：touch index.js就会在当前目录下新建一个index.js文件rm删除一个文件,rm index.js就会删除index.js文件mkdir新建一个目录,就是新建一个文件夹rm -r 删除一个文件夹,rm -r src就是删除src文件夹mv移动文件,如mv index.html src 那么index.html就是移动的文件，src为目标文件夹（两者在同一目录下）reset重新初始化终端/清屏clear清理屏幕history查看历史命令exit退出#注释</code></pre><h5 id="Git配置：-所有的配置文件，其实都保存在本地"><a href="#Git配置：-所有的配置文件，其实都保存在本地" class="headerlink" title="Git配置：(所有的配置文件，其实都保存在本地)"></a>Git配置：(所有的配置文件，其实都保存在本地)</h5><h6 id="查看配置：git-config-l"><a href="#查看配置：git-config-l" class="headerlink" title="查看配置：git config -l"></a>查看配置：git config -l</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231706647.png" alt="image-20220603231706647"></p><h6 id="查看系统配置：git-config-–system-–list"><a href="#查看系统配置：git-config-–system-–list" class="headerlink" title="查看系统配置：git config –system –list"></a>查看系统配置：git config –system –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231858917.png" alt="image-20220603231858917"></p><h6 id="查看全局配置：git-config-–global-–list"><a href="#查看全局配置：git-config-–global-–list" class="headerlink" title="查看全局配置：git config –global –list"></a>查看全局配置：git config –global –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231922188.png" alt="image-20220603231922188"></p><pre><code class="linux">git config --global user.name &quot;设置名字&quot;git config --global user.email 邮箱地址</code></pre><h4 id="Git相关配置文件："><a href="#Git相关配置文件：" class="headerlink" title="Git相关配置文件："></a>Git相关配置文件：</h4><p>1)，Git&#x2F;etc&#x2F;gitconfig：Git安装目录下的gitconfig–system系统配置</p><p>2)，C:&#x2F;User&#x2F;Administrator（当前用户）&#x2F;.gitconfig：只适用于当前登录用户的配置–global全局配置</p><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）,暂存区（Stage&#x2F;Index）,资源库（Repository&#x2F;Git Directory）加上远程Git仓库（Remote Directory）</p><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604102832395.png" alt="image-20220604102832395"></p><ul><li>Workspace：工作区，就是平时存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放改动，实际上只是一个文件，保存了即将提交到文件列表的信息</li><li>Repository：仓库区（本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器（一般用github或者gitee）</li></ul><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604103432739.png" alt="image-20220604103432739"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>在工作目录添加,修改文件;</li><li>将需要的进行版本管理的文件放入暂存仓库</li><li>将暂存区文件提交到git仓库</li></ol><p>所以,git管理的文件有三种状态:已修改（modified），已暂存（staged），已提交（committed）</p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h3 id="仓库搭建"><a href="#仓库搭建" class="headerlink" title="仓库搭建"></a>仓库搭建</h3><p>创建本地仓库方法有两种：创建全新的仓库，克隆远程仓库</p><h5 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h5><pre><code class="git"># 在当前目录下新建一个Git代码库$ git init</code></pre><p>执行后在项目文件夹会多出一个.git的隐藏目录，关于版本等信息都在目录中</p><h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><pre><code class="git"># 克隆一个项目和它的全部代码历史（版本信息）$ git clone [url]</code></pre><p>前往gitee &#x2F; github上测试；</p><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<strong>git add</strong> 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用    <strong>git rm</strong>移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<strong>git checkout</strong> 则丢弃修改过, 返回到unmodify状态, 这个<strong>git checkout</strong>即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行<strong>git commit</strong>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行<strong>git reset HEAD filename</strong>取消暂存, 文件状态为Modified</li></ul><pre><code class="git"># 查看全部文件状态git status# 查看指定文件状态git status [filename]# 添加全部文件到暂存区git add .# 将暂存区内容提交至本地 -m为提交时编写备注git commit -m&quot;消息内容&quot;</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在项目文件夹中，并非所有数据都要我们上传和提交，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore“文件，此文件有以下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><pre><code class="git"># 为注解*.txt# 忽略所有.txt结尾的文件，上传的总文件中不会包含这些文件!lib.txt    # 但是lib.txt文件除外/temp# 仅忽略build/目录下的所有文件build/# 忽略bulid/目录下的所有文件doc/*.txt# 忽略doc/notes.txt等文件,单不包括doc/server/arch.txt</code></pre><h3 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h3><pre><code class=".gitignore">*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### IntelliJ IDEA ###*.iml*.ipr*.iws.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml*</code></pre><h1 id="使用码云（Gitee）"><a href="#使用码云（Gitee）" class="headerlink" title="使用码云（Gitee）"></a>使用码云（Gitee）</h1><p>设置本机SSH公钥，实现免密码登录！</p><pre><code class="git"># 进入C:/user/Administraror/.ssh 目录# (右键进入git命令行)生产公钥ssh-keygen</code></pre><p>将生产的id_rsa.pub文件中的信息复制，在码云<strong>安全设置</strong>的<strong>SSH公钥</strong>中粘贴即可</p><p>接下来就是创建仓库去使用了！</p><h1 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h1><p>1.新建项目，绑定git</p><ul><li>直接将远程的git文件拷贝到项目中（在别处get clone [url]，将产生的文件夹剪切）</li></ul><p>2.修改文件，提交文件</p><ul><li>左下角有<strong>Version Control</strong>显示版本信息，右上角有快捷图标</li></ul><h1 id="Git分支说明"><a href="#Git分支说明" class="headerlink" title="Git分支说明"></a>Git分支说明</h1><p>git分支中常见指令：</p><pre><code class="git"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支吧git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h1 id="Git后续操作"><a href="#Git后续操作" class="headerlink" title="Git后续操作"></a>Git后续操作</h1><blockquote><p>gitee官网中有命令大全和操作指南</p></blockquote><blockquote><p>团队很重要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层原理</title>
      <link href="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇知识梳理参考了B站up : <a href="https://space.bilibili.com/439213321">黑马程序员上海中心</a> 的视频 : <a href="https://www.bilibili.com/video/BV1FE411t7M7?share_source=copy_web&vd_source=9b42e96f6cc201a1ee177f1b86bb0b77">HashMap集合介绍+面试题讲解</a></p></blockquote><h1 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h1><ul><li>hashMap集合介绍</li><li>HashMap集合底层数据结构</li><li>hashMap继承关系</li><li>hashMap集合类成员</li><li>如何设计多个非重复的键值对要存储HashMap的初始化</li></ul><h3 id="HashMap集合介绍"><a href="#HashMap集合介绍" class="headerlink" title="HashMap集合介绍"></a>HashMap集合介绍</h3><p><img src="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20220814101149681.png" alt="image-20220814101149681"></p><p><img src="https://img-blog.csdnimg.cn/20200628084624157.png#pic_center" alt="HashMap"></p>]]></content>
      
      
      <categories>
          
          <category> 代码底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http分析</title>
      <link href="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/252370220">图灵诸葛官方号</a>) 课程 <a href="https://www.bilibili.com/video/BV1V54y1y7c4?spm_id_from=333.337.search-card.all.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">程序员入门必备教程—HTTP协议详解</a>)</p></blockquote><ul><li>HTTP分层请求</li><li>HTTP协议</li><li>HTTP请求过程</li><li>TCP协议</li><li>HTTPS协议</li></ul><h1 id="Http分层"><a href="#Http分层" class="headerlink" title="Http分层:"></a>Http分层:</h1><p>网络需要完成的任务：防止数据丢包，避免数据重复，数据完整性校验，数字转模拟信号，…，信号衰减</p><p>为了完成不同层面的各个任务，简化网络的复杂度，网络通信被分解为多层次结构，每一层都紧挨着上层或下层进行交互，这样在修改甚至替换某一层的软件时，只需要层与层之间的接口保持不变，就不会影响其他层。</p><ul><li>OSI七层网络模型</li><li>TCP&#x2F;IP协议簇</li></ul><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819105355252.png" alt="image-20220819105355252"></p><h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><p>超文本传输协议（HyperText Transfer Protocol , HTTP）</p><p>一种无状态，以请求、应答方式运行的协议。它使用可扩展语义和子描述消息格式，与基于网络的草文本消息系统可以灵活互动</p><h5 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h5><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）:描述请求或响应的基本信息</li><li>头部字段集合（header）:使用key-value形式更详细的说明报文</li><li>空行</li><li>消息正文（entity）:实际传输的数据，不一定是文本，可以是图片，视频等二进制数据</li></ul><h5 id="请求行报文格式："><a href="#请求行报文格式：" class="headerlink" title="请求行报文格式："></a>请求行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110831735.png" alt="image-20220819110831735"></p><ul><li>请求方法（METHOD）：如 GET &#x2F; HEAD &#x2F; PUT &#x2F; POST，表示对资源的操作</li><li>请求目标 ：通常是一个URL，标记了请求方法要操作的资源</li><li>版本号：表示报文使用的HTTP协议版本</li></ul><h5 id="响应行报文格式："><a href="#响应行报文格式：" class="headerlink" title="响应行报文格式："></a>响应行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110855815.png" alt="image-20220819110855815"></p><ul><li>版本号 ：表示报文使用的HTTP协议版本</li><li>状态码（STATUS CODE）: 一个三位数，用代码的形式表示处理结果，比如200是成功，403是客户端访问被拒，500是服务器错误</li><li>原因（READON）：作为数字状态码补充，是更加详细的解释文字，协助理解原因</li></ul><h5 id="HTTP头字段："><a href="#HTTP头字段：" class="headerlink" title="HTTP头字段："></a>HTTP头字段：</h5><p>头部字段是key-value形式，key和value间使用 “  ：”做分隔，比如前后端分离时常遇到的要与后端协商传输数据类型 “ <strong>Content-type:application&#x2F;json</strong> ” ，最后用CRLF换行表示字段结束，HTTP头字段的使用比较灵活，不仅可以用Host,Connection等已有头字段，也可以任意添加自定义头，这就给HTTP协议带来了无限扩展可能。 </p><p><strong>注意事项</strong></p><ul><li>字段名称不区分大小写，但不允许出现空格和下划线“_”,可以使用连字符“-”，字段后必须紧跟“:”，中间不许有空格，但“:”后允许多个空格</li><li>字段顺序没有意义，任意排列不影响语序</li><li>字段原则上不允许重复，除非字段本身允许：Set-Cookie</li></ul><h5 id="常用头字段："><a href="#常用头字段：" class="headerlink" title="常用头字段："></a>常用头字段：</h5><p>HTTP协议有很多头字段，基本可以分为四大类：</p><ul><li>请求字段：请求头中的头字段：如Host，Referer</li><li>响应字段：响应头中的头字段：如Server，Date</li><li>通用字段：在响应头和请求头都可以出现的：Content-type，Connection</li></ul><h1 id="HTTP请求过程："><a href="#HTTP请求过程：" class="headerlink" title="HTTP请求过程："></a>HTTP请求过程：</h1><p>当用户在浏览器中输入网址后，网络协议都做了哪些工作？</p><ol><li>首先依据浏览器应用程序，解析出URL中的域名</li><li>依据域名获得的ip地址，首先从浏览器缓存中查看，没有就去本机域名解析文件hosts中查看，LDNS，Rootserver，国际定级域名服务商层层解析，直至找到</li><li>拿到ip地址后，浏览器发起对服务器的三次握手</li><li>握手建立连接后，开始组装http请求，发送报文</li><li>服务器收到请求报文后，开始请求报文解析，生成响应数据，发送响应数据</li><li>浏览器收到响应后，开始渲染页面</li></ol><blockquote><p> chrome:&#x2F;&#x2F;net-internals&#x2F;#events             查看浏览器缓存ip地址</p></blockquote><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819120503128.png" alt="image-20220819120503128"></p><h1 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h1><p>TCP协议是面向连接的，可靠的，基于字节流的传输层协议</p><h4 id="TCP属性："><a href="#TCP属性：" class="headerlink" title="TCP属性："></a>TCP属性：</h4><ul><li>基于连接：数据传输之间需要建立连接</li><li>全双工：双向传输</li><li>字节流：不限制数据大小，打包成为报文段，保证有序接收，重复报文自动丢弃</li><li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性</li><li>拥塞控制：防止网络出现恶性拥塞</li></ul><h4 id="TCP报文："><a href="#TCP报文：" class="headerlink" title="TCP报文："></a>TCP报文：</h4><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821101526541.png" alt="image-20220821101526541"></p><p>Source port：源端口Dest port：目的端口</p><p>Seq：请求数   ACK：应答数</p><p>Header length：首部长度Unused：保留字段</p><p>Receive window：当前可接收值 Urgent data：紧急报文指针</p><p>Options：可选参数   Data：数据</p><h4 id="TCP连接管理："><a href="#TCP连接管理：" class="headerlink" title="TCP连接管理："></a>TCP连接管理：</h4><p>TCP连接：四元组【源地址，源端口，目的地址，目的端口】</p><p>确认连接：三次握手</p><p>​a.同步通信双方的初始序列号（ISN）</p><p>​b.协商TCP通信参数（MSS，窗口信息，指定校验和算法）</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102017022.png" alt="image-20220821102017022"></p><p>内核操作：</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102108877.png" alt="image-20220821102108877"></p><p>关闭连接：四次挥手</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102157493.png" alt="image-20220821102157493"></p><h4 id="字节流协议："><a href="#字节流协议：" class="headerlink" title="字节流协议："></a>字节流协议：</h4><p>MSS：Max Segment Size：默认536byte实际数据</p><p>TCP会依据Seq报文序列号进行排序，使得文件被划分为小信息发送时不会乱序</p><h4 id="可靠性-x2F-重传机制："><a href="#可靠性-x2F-重传机制：" class="headerlink" title="可靠性&#x2F;重传机制："></a>可靠性&#x2F;重传机制：</h4><h5 id="1-ack丢失："><a href="#1-ack丢失：" class="headerlink" title="1.ack丢失："></a>1.ack丢失：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102424659.png" alt="image-20220821102424659"></p><h5 id="2-请求报文丢失"><a href="#2-请求报文丢失" class="headerlink" title="2.请求报文丢失"></a>2.请求报文丢失</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102536666.png" alt="image-20220821102536666"></p><h5 id="3-滑动窗口协议："><a href="#3-滑动窗口协议：" class="headerlink" title="3.滑动窗口协议："></a>3.滑动窗口协议：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102644054.png" alt="image-20220821102644054"></p><p>每次发送一组报文，并确定最后的报文是否收到回信，如果收到，表示报文全部被接收，直接跳至下一组，不必有重复</p><p>如果没有收到最后的报文，则往前推，直至从收到回信的部分（如图，3，5没有回信只收到12的回信，则12确认发送成功，不论4是否成功，3，4，5都和后面数据一起发送）</p><h1 id="HTTPS协议："><a href="#HTTPS协议：" class="headerlink" title="HTTPS协议："></a>HTTPS协议：</h1><p>HTTP具有”明文“特点，整个传输过程完全透明，任何人都可以在链路中截获、修改和伪造，数据具有不可信性</p><p>使用HTTPS，所有HTTP请求都会在请求和响应之前进行加密</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821103501204.png" alt="image-20220821103501204"></p><h3 id="SSL-x2F-TSL："><a href="#SSL-x2F-TSL：" class="headerlink" title="SSL&#x2F;TSL："></a>SSL&#x2F;TSL：</h3><p>SSL即安全套接层，由网景公司于1994年发明，IETF在1999年将其改名为TLS传输层安全，三个主流版本为2006的1.1，2008的1.2，2018的1.3，每个版本都紧跟密码学的发展和互联网现状，持续强化安全和性能，已经成为信息安全领域的权威标准</p><h3 id="摘要算法："><a href="#摘要算法：" class="headerlink" title="摘要算法："></a>摘要算法：</h3><p>将任意长度的数据”压缩“为固定长度，且独一无二的”摘要“字符，可以将其与明文一起发送，接收端解压字符后可以对比查看明文是否被篡改</p><p>如：md5</p><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><h5 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h5><p>编码使用相同的密钥进行加密解密（AES，RC4,ChaCha20）</p><h5 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h5><p>有两个密钥，一个”公钥“，一个”私钥“。前者可以给任何人使用，随意分发。后者需要保密，网站秘密保存</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/blog\source_posts\剖析Http请求\image-20220821104242155.png" alt="image-20220821104242155"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6事事务以及集群</title>
      <link href="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>事物，锁机制</li><li>事物冲突问题</li><li>redis事物三特性</li><li>持久化框架</li><li>Redis主从复制</li><li>Redis集群</li><li>Redis应用问题解决</li></ul><h3 id="事物，锁机制："><a href="#事物，锁机制：" class="headerlink" title="事物，锁机制："></a>事物，锁机制：</h3><p>Redis事物：一个单独的隔离操作；事物中所有命令都会序列化，按顺序执行。事物执行过程中不会被其他客户端发送过来的命令请求打断</p><p>Redis事物主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p><h4 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi | Exec | discard"></a>Multi | Exec | discard</h4><p>输入Multi开启事务，此时被成为组队阶段，<strong>输入的命令不会马上执行</strong>，而是<strong>依次进入命令队列</strong>，直到输入Exec后，将命令队列中命令依次执行，组队过程中可以通过discard来放弃组队</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817101242222.png" alt="image-20220817101242222"></p><h4 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h4><ol><li>组队时命令发生错误，事物无法执行Exec后的命令语句，<strong>一个都不执行</strong></li><li>组队时无误，执行时出现部分错误，<strong>错误的不执行，其他的执行</strong></li></ol><h4 id="为什么需要做成事物："><a href="#为什么需要做成事物：" class="headerlink" title="为什么需要做成事物："></a>为什么需要做成事物：</h4><p>同一份数据被多处调用时，可能会使得值变得不合理，例如多人登录同一台TB账户购买东西，余额同时读取后再依次修改是不合理的</p><h3 id="事务冲突问题："><a href="#事务冲突问题：" class="headerlink" title="事务冲突问题："></a>事务冲突问题：</h3><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h4><p>每次拿数据时都认为别人会修改，所以每次拿取数据时就上锁，其他人拿数据时就会black（阻塞）直至开锁，<strong>牺牲性能换效果</strong></p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p><strong>添加版本信息</strong>，仅在修改信息时匹配版本是否一致，一致则成功修改，否则更新数据再执行</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817103825221.png" alt="image-20220817103825221"></p><h4 id="WATCH-K"><a href="#WATCH-K" class="headerlink" title="WATCH  K:"></a>WATCH  K:</h4><p>在执行multi之前，<strong>先执行watch k监视一个或多个key值</strong>，如果在事物执行之前这个key被改动，那么事务将会被打断</p><h3 id="Redis事务的三特性："><a href="#Redis事务的三特性：" class="headerlink" title="Redis事务的三特性："></a>Redis事务的三特性：</h3><ul><li>单独的隔离操作：事务中所有命令都会序列化，按顺序执行。事务在执行过程中不会被其他客户端发送的命令请求打断</li><li>没有隔离级别概念：队列中的命令没有提交之前都不会实际执行，因为事务提交前任何指令都不会执行</li><li>不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h3 id="持久化框架："><a href="#持久化框架：" class="headerlink" title="持久化框架："></a>持久化框架：</h3><h4 id="RDB（Redis-DataBase）："><a href="#RDB（Redis-DataBase）：" class="headerlink" title="RDB（Redis DataBase）："></a>RDB（Redis DataBase）：</h4><p>将指定时间间隔内将内存中数据集快照写入磁盘</p><h4 id="AOF（Append-Of-File）："><a href="#AOF（Append-Of-File）：" class="headerlink" title="AOF（Append Of File）："></a>AOF（Append Of File）：</h4><h3 id="主从复制："><a href="#主从复制：" class="headerlink" title="主从复制："></a>主从复制：</h3><h3 id="集群："><a href="#集群：" class="headerlink" title="集群："></a>集群：</h3><h3 id="应用问题："><a href="#应用问题：" class="headerlink" title="应用问题："></a>应用问题：</h3><h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><h4 id="分布式锁："><a href="#分布式锁：" class="headerlink" title="分布式锁："></a>分布式锁：</h4>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6基础</title>
      <link href="/2022/08/15/Redis_6/"/>
      <url>/2022/08/15/Redis_6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>NoSQl概述</li><li>行式&#x2F;列式数据库（大数据时代）</li><li>key键操作</li><li>5种基本数据类型</li><li>配置文件</li><li>发布与订阅</li><li>3种新数据类型</li></ul><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p><strong>基于K-V的高性能NoSQl数据库，提供了各种数据结构存储，具有高性能的多线功能</strong>，支持String（字符串） , list（链表） , set （集合）, zset（sorted set：有序集合） 和 hash（哈希类型）</p><p>Redis支持各种方式的<strong>排序</strong>，为了保证效率，<strong>数据都是存储在缓存中的</strong>，但Redis会<strong>周期性</strong>把更新的数据写入磁盘，在此基础上<strong>实现了master-slave（主从）同步</strong></p><p>Redis是 <strong>单线程 + 多路复用IO</strong> 技术；使用 <strong>6379端口</strong></p><h3 id="NoSql-数据库"><a href="#NoSql-数据库" class="headerlink" title="NoSql 数据库"></a>NoSql 数据库</h3><p>NoSQL （Not Only SQL）：意为“不仅仅是SQL”，泛指<strong>非关系型数据库</strong></p><p>NoSQL 不依赖业务逻辑存储方式，而是以简单的<strong>key-value</strong>模式存储，因此增加了数据库的扩展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><p>适用场景：</p><ul><li>对数据高并发读写</li><li>海量数据的读写</li><li>对数据高可扩展性</li></ul><p>不适用场景</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储</li></ul><p><strong>总之：用不着sql和用了sql也不行的情况，考虑Nosql</strong></p><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><p><img src="/2022/08/15/Redis_6/image-20220816091921656.png" alt="image-20220816091921656"></p><h3 id="列式数据库："><a href="#列式数据库：" class="headerlink" title="列式数据库："></a>列式数据库：</h3><p><img src="/2022/08/15/Redis_6/image-20220816092128015.png" alt="image-20220816092128015"></p><h3 id="Key键操作"><a href="#Key键操作" class="headerlink" title="Key键操作"></a>Key键操作</h3><pre><code class="redis">keys *//查看全部keyexists K//查找key是否存在，返回1：存在；返回0：不存在type K//查看key是什么类型del K//删除对应K-V,返回1：成功unlink K//非阻塞删除对应K-Vexpire K int//为给定的K设置过期时间ttl K//查看还有多久数据过期（取不到）返回-1:永不过期,返回-2：已经过期select int//切换库dbsize//查看当前数据库的key数量flushdb//清空当前库flushall//通杀全部库</code></pre><h3 id="5种基本数据类型："><a href="#5种基本数据类型：" class="headerlink" title="5种基本数据类型："></a>5种基本数据类型：</h3><ul><li>String（字符串）</li><li>List（链表）</li><li>Set（集合）</li><li>Hash（哈希）</li><li>Zset（有序集合）</li></ul><h4 id="String（字符串）："><a href="#String（字符串）：" class="headerlink" title="String（字符串）："></a>String（字符串）：</h4><p>string是 <strong>二进制安全</strong> 的,意味着Redis的string可以包含任何数据，包括jpg图片或者序列化对象。</p><p>string是Redis中最基本的数据类型，一个·Redis中的value最多可以是 <strong>512M</strong></p><p>string底层数据结构就是<strong>简单的动态字符串</strong>，结构上类似Java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配</p><p>在字符串长度小于1M时，扩容为每次扩大一倍，大于1M时，每次扩容1M</p><p><strong>常见命令</strong></p><pre><code class="redis">set K V//设置键值对/覆盖已有的K-V键值对get K//取出K对应的Vappend K V//在原有K对应的V`后添加Vstrlen K//获取K对应V的长度setnx K V//设置键值对，如果已有K，返回0：设置失败，否则返回1：设置成功mset K1 V1 K2 V2..//设置一个或多个键值对mget K1 k2..//取出一个或多个V值getrange K int1 int2//获取K对应V的int1-int2部分内容：从0开始setrange K int V//将K对应V的int之后部分添加V再接原字符setex K int V//设置K-V同时设置过期时间getset K V //获取旧值，同时将新值写入// 原子操作*incr K//将K对应V值+1；如果V不是数字类型返回0，否则返回+1后的值decr K//将K对应V值-1；...否则返回-1的值incrby K int//将K对应V值+int;...decrby K int//...-int...msetnx K1 V1 K2 V2//同时设置多个K-V,当且仅当key都不存在</code></pre><h6 id="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"><a href="#原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）" class="headerlink" title="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"></a>原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）</h6><p>注：java中的i++并非是原子操作</p><p>![image-20220816101653161](.&#x2F;Redis 6&#x2F;image-20220816101653161.png)</p><h4 id="List（链表）："><a href="#List（链表）：" class="headerlink" title="List（链表）："></a>List（链表）：</h4><p><strong>单键多值</strong> ，即一个K对应多个V。底层实现是 <strong>双向链表</strong> ，数据结构为 <strong>快速链表</strong>（quickList）即在列表元素较少时使用的结构式ziplist（压缩列表），它将所有元素挨在一起存储，分配一块连续的内存。当数据量较大时才会改为quicklist</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><pre><code class="redis">lpush K V1 V2...//从左边(头节点)加入一个或多个值rpush K V1 V2... //从右边(尾节点)加入一个或多个值lrange K int1 int2  //从左边取出int1-int2的数据(顺序)：0是第一个，-1是最后一个lpop K //从左边吐出一个值,值在键在，值光键亡rpop K //从右边吐出一个值,...rpoplpush K1 K2//从K1右边取出值加到K2左边lindex K int //按照索引下标获得元素llen K//获得列表长度linsert K before V1 V2 //在V1前添加一个V2linsert K after V1 V2 //在V1后添加一个V2lrem K int V//从左边删除int个Vlset K int V//将列表K下标为int的值替换为V</code></pre><h4 id="Set（集合）："><a href="#Set（集合）：" class="headerlink" title="Set（集合）："></a>Set（集合）：</h4><p>set可以 <strong>自动排重</strong> ，且提供了<strong>判断某个成员是否在一个set集合</strong>的接口。</p><p>Redis的set是String类型的<strong>无序集合</strong>，底层是一个<strong>value为null的hash表</strong>，所以添加，删除，查找复杂度都是O(1)</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">sadd K V1 V2...//将一个或多个members元素添加至key中，已存在的会被忽略smembers K//取出该集合的所有值sismember K V//判断K集合中是否右V值，有返回1，否则返回0scard K//返回集合元素个数srem K V1 V2//删除集合中的一个或多个元素spop K//随机从集合中取出一个值，值完键亡srandmemberK int//随机取出int个值，不会在集合中删除smove K1 K2 V1 V2...//将K1中元素V1，v2..移动到K2中，返回移动元素个数sinter K1 K2//返回两个集合的交集元素sunion K1 K2//返回两个集合的并集元素sdiff K1 K2//返回两个集合的差集元素（在K1而不在K2）</code></pre><h4 id="Hash（哈希）："><a href="#Hash（哈希）：" class="headerlink" title="Hash（哈希）："></a>Hash（哈希）：</h4><p>Redis Hash是一个<strong>键值对集合</strong>，其value对应一个<strong>String类型的field</strong>和value映射表，适合用于存储对象，类似Java中的Map&lt;String, Object&gt;</p><p>![image-20220816150802600](.&#x2F;Redis 6&#x2F;image-20220816150802600.png)</p><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">hset K field value//在K中添加一个field-value对hget K field//返回K中field对应的值hmset K f1 v1 f2 v2//在K中批量设置field-value对hexists K field//查看中是否存在fieldhkeys K//列出K集合中全部的fieldhvals K//列出K集合中全部的valuehincrby K field int //给K中的field对应value值hsetnx K field value//为K添加field-value对，如果field原本存在则不会添加</code></pre><h4 id="Zset（有序集合）："><a href="#Zset（有序集合）：" class="headerlink" title="Zset（有序集合）："></a>Zset（有序集合）：</h4><p>Zset与set相同，是 <strong>没有重复元素</strong> 的字符串集合。不同之处是Zset每个成员都关联了一个<strong>评分（score）</strong>,score用于按照从低到高的方式对集合成员进行排序。</p><p><strong>集合成员是唯一的，但评分可以重复</strong></p><h5 id="常用命令：-1"><a href="#常用命令：-1" class="headerlink" title="常用命令："></a><strong>常用命令：</strong></h5><pre><code class="redis">zadd K score1 v1 s2 v2//添加一个或多个评分-值zrange K int1 int2 //返回排序从int1到int2的值zrange K int1 int2 withscores //返回排序从int1到int2的值，同时返回评分zrangebyscore K int1 int2//返回score在int1至int2中间的值，可以加withscoreszrevrangebyscore K int1 int2//逆序返回score在int1至int2中间的值，可以加with...zincrby K int V//给K中V的score增加intzrem K V//删除指定值zcount K int1 int2//统计集合中在int1-int2中的元素个数zrank K V//返回该值在集合中的排名，从0开始</code></pre><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>配置文件：redis.conf</p><blockquote><p>vi &#x2F;etc&#x2F;redis.conf</p></blockquote><pre><code class="redis">bind 127.0.0.1#限制仅本地连接protected-mode yes#仅本地访问，改为no即可允许非本地访问port:6379#端口tcp-backlog 511#目前已经完成三次握手以及正在三次握手的队列timeout0#超时时限，设为0则永不超时tcp-keepalive 300#心跳监测连接，每隔300s检查一次daemonize yes#允许后台启动pidfile...#保存进程号的位子loglevel notice#log保护级别：debug&gt;verbose&gt;notice&gt;warninglogfile &quot;&quot;#日志输出路径，默认为空database 16#redis默认16个数据库，用户默认使用0号库#密码requirepass与客户端LIMITSmaxmemory 10000#最大内存maxmemory-sample 5#样本数量maxclients 10000#最大连接数#持久化设置</code></pre><h3 id="发布与订阅："><a href="#发布与订阅：" class="headerlink" title="发布与订阅："></a>发布与订阅：</h3><pre><code class="redis"># /usr/local/bin/redis-cliSUBSCRIBE channel1#订阅channel1频道publicsh  channels hello#使channel1发布消息“hello”</code></pre><p>一种消息的沟通模式：<strong>频道收到消息后，所有订阅的对象都会收到对应消息</strong></p><h3 id="3种新数据类型："><a href="#3种新数据类型：" class="headerlink" title="3种新数据类型："></a>3种新数据类型：</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps:"></a>Bitmaps:</h4><p>BitMaps本身就是字符串Key-Value，但是可以对字符串进行位运算，可以把Bitmaps想象为一个以位为单位的数组，数组只能存储0和1，数组下标在BotMaps中被成为偏移量，最左边为0.</p><h5 id="常用命令：-2"><a href="#常用命令：-2" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">setbit K int1 int2#对K中int1号位子上改为int2（0/1）getbit K int#获取K中偏移量int中的值bitcount K#统计K中被设为1的数量bitcount K int1 int2 #统计K中int1到int2之间1的数量bitop and K1 K2#对K1，K2中为1的偏移量取与集，返回统计值bitop or K1 K2#对K1，K2中为1的偏移量取并集，...bitop not K1 K2#对K1，K2中为1的偏移量取差集，...bitop xor K1 K2#对K1，K2中为1的偏移量取异或，...</code></pre><p>![image-20220817090407369](.&#x2F;Redis 6&#x2F;image-20220817090407369.png)</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog:"></a>HyperLogLog:</h4><p>HyperLogLog只会根据输入元素计算*<strong>基数</strong>，不会存储输入元素本身</p><p><strong>基数</strong>：集合中不重复元素的总值被称为基数，如{1，6，3，4，3，9}，不重复元素为1，3，4，6，9 基数为5</p><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">pfadd K V1 V2#添加一个或多个元素pfcount K#统计基数pfmerge K1 K2 K3#将K2,K3中的值全部合并至K1</code></pre><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial:"></a>Geospatial:</h4><p>GEO:Geographic地理位置信息的缩写，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等操作</p><p>有效范围：经度：-180——180；纬度：-85——85</p><h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">geoadd K int1 int2 V  #设置K中的V：经度为int1，纬度为int2geopos K V#获取K中V的经纬度geodist K V1 V2m#获取V1到V2的直线距离，以米做单位（km千米，mi英里,ft英尺）georadius K int1 int2 int3 km#对K中处于经度int1纬度int2方圆int3km内的信息返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法题</title>
      <link href="/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点："><a href="#1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点：" class="headerlink" title="1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点："></a>1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点：</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ol><li>遍历整个二叉树，将所有节点的父节点以&lt;Node，Node&gt;形式存入hashmap中</li><li>创建HashSet，从node1开始依据HashMap依次将自己的父节点存入HashSet中</li><li>从node2开始溯洄父节点，一旦存在HashSet中就停止，此时就是首个公共祖先节点</li></ol><pre><code class="java">//主函数public static Node finFather(Node head, Node node1, Node2) &#123;    HashMap&lt;Node,Node&gt; hashmap = new HashMap&lt;&gt;();    hashmap.put(head,head);     process(head,hashmap);    HashSet&lt;Node&gt; set1 = new HashSet&lt;&gt;();        Node o1 = node1;    //循环至头节点停下    while(o1 != hashmap.get(o1))&#123;        set1.add(o1);        o1 = hashmap.get(o1);    &#125;    //将头节点添加    set1.add(head);        Node o2 = node2;    while(set1.get(o2)==null)&#123;        o2 = hashmap.get(o2);    &#125;    return o2;&#125;//存储父节点函数public static void process(Node head, HashMap&lt;Node.Node&gt; hashmap) &#123;    if(hashmap == null) return;    hashmap.put(head.left,head);    hashmap.put(head.right,head);    process(head.left,hashmap);    process(head.right,hashmap);&#125;</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>分析node1与node2可能的关系：</p><ol><li>node1是node2的祖先 &#x2F; node2是node1的祖先：返回node1 &#x2F; node2</li><li>node1与node2彼此不互为公共祖先，返回向上汇聚的祖先节点</li></ol><pre><code class="java">public static Node findFather(Node head, Node node1, Node node2) &#123;    if(head == null || head == node1 || head == node2) &#123;        return head;    &#125;    Node left = findFather(head.left, node1, node2);    Node right = findFather(head.right, node1, node2);    if(left != null &amp;&amp; right != null) &#123;        return head;    &#125;    return left != null ? left : right;&#125;</code></pre><h3 id="2-二叉树找到一个节点的后继节点："><a href="#2-二叉树找到一个节点的后继节点：" class="headerlink" title="2.二叉树找到一个节点的后继节点："></a>2.二叉树找到一个节点的后继节点：</h3><pre><code class="java">public class Node &#123;    public Node left;    public Node right;    public Node parent;//指向父节点    public int value;        public Node(int val) &#123;        this.value = val;    &#125;&#125;</code></pre><p><strong>后继节点</strong>：中序遍历二叉树后，每个节点的下一个节点是此节点的后继节点</p><p>（中序遍历打印每一位节点，相邻的后一个打印的节点是前一位的后继节点，相邻的前一节点是后一节点的前驱节点）</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><p>中序遍历生成列表，依次查询列表找到后继节点</p><h5 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h5><p>分析后继节点的可能情况：</p><ol><li>当前节点存在右树：后继节点是右树的最左节点</li><li>当前节点没有右树：判断是否为父节点的左孩子：是，父节点为后继；不是，继续看父节点（没有右数说明已经是某左子树最后一个节点）</li><li>前两者无法找到后继节点：后继节点为空，这个节点是二叉树中序遍历的最后一个节点</li></ol><pre><code class="java">//主程序public static Node getNextNode(Node node) &#123;    if(node == null) return node;    if(node.right != null) &#123;//情况1        return getLeftMost(node);    &#125;else &#123;        Node parent = node.parent;        while(parent != null &amp;&amp; parent.left != node) &#123;//情况2和3            node = parent;            parent = node.parent;        &#125;        return parent;    &#125;&#125;//走左子树public static Node getLeftMost(Node node) &#123;    if(node == null) &#123;        return node;    &#125;    while(node.left != null) &#123;        node = node.left;    &#125;    return node;&#125;</code></pre><h3 id="3-二叉树序列化与反序列化"><a href="#3-二叉树序列化与反序列化" class="headerlink" title="3.二叉树序列化与反序列化"></a>3.二叉树序列化与反序列化</h3><p>内存 → 字符串 ：序列化</p><p>字符串 → 内存：反序列化</p><h5 id="先序序列化："><a href="#先序序列化：" class="headerlink" title="先序序列化："></a>先序序列化：</h5><pre><code class="java">public static String serialTree(Node head) &#123;    if(head == null) return &quot;#_&quot;;    String res = head.value + &quot;_&quot;;    res += serialTree(head.left);    res += serialTree(head.right);    return res;&#125;</code></pre><h5 id="先序反序列化："><a href="#先序反序列化：" class="headerlink" title="先序反序列化："></a>先序反序列化：</h5><pre><code class="java">//排序public static Node reconSerialTree(String str) &#123;    String[] values = str.split(&quot;_&quot;);    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    for(int i = 0; i != values.length; i++) &#123;        queue.add(values[i]);    &#125;    return reconOrder(queue);&#125;//组成树public static Node reconOrder(Queue&lt;String&gt; queue) &#123;    String value = queue.poll();    if(value.equals(&quot;#&quot;))&#123;        return null;    &#125;    Node head = new Node(Integer.valueOf(value));    head.left = reconOrder(queue);    head.right = reconOrder(queue);    return head;&#125;</code></pre><h5 id="中序，后序同理"><a href="#中序，后序同理" class="headerlink" title="中序，后序同理"></a>中序，后序同理</h5>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉数："><a href="#二叉数：" class="headerlink" title="二叉数："></a>二叉数：</h1><ul><li><p>二叉树递归遍历</p></li><li><p>二叉树非递归遍历</p></li><li><p>宽度优先遍历</p></li><li><p>搜索二叉树</p></li><li><p>完全二叉树</p></li><li><p>满二叉树</p></li><li><p>平衡二叉树</p><hr></li></ul><pre><code class="java">// 二叉树节点class Node&lt;V&gt; &#123;    V value;    Node left;    Node right;&#125;</code></pre><p>头节点：也叫根节点，二叉树最顶端的节点（无无父结点）</p><p>叶节点：左右子节点都为null</p><p>子树：以任意一节点为根，其衍生下可以直接相连或经过节点相连的全部节点组成的树</p><h3 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h3><h4 id="使用递归方式实现："><a href="#使用递归方式实现：" class="headerlink" title="使用递归方式实现："></a>使用递归方式实现：</h4><pre><code class="java">// 二叉树每个节点遍历时都有三次访问public static void f(Node head) &#123;    //1:start    if (head == null) &#123;        return null;    &#125;    ...    // 1:end    f(head.left);    // 2:start    ...    // 2:end    f(head.right);    // 3:start    ...    // 3:end&#125;</code></pre><p>*<strong>先序，中序，后序遍历即是在第一次，第二次，第三次访问节点时做反应</strong></p><p><img src="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220812185607833.jpg" alt="image-20220812185607833"></p><h5 id="遍历打印（每次访问打印一次value）："><a href="#遍历打印（每次访问打印一次value）：" class="headerlink" title="遍历打印（每次访问打印一次value）："></a>遍历打印（每次访问打印一次value）：</h5><p>1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1</p><h5 id="先序访问顺序（对每颗子树-头左右）："><a href="#先序访问顺序（对每颗子树-头左右）：" class="headerlink" title="先序访问顺序（对每颗子树 头左右）："></a>先序访问顺序（对每颗子树 头左右）：</h5><p>1 2 4 5 3 6 7</p><h5 id="中序访问顺序（对每颗子树-左头右）："><a href="#中序访问顺序（对每颗子树-左头右）：" class="headerlink" title="中序访问顺序（对每颗子树 左头右）："></a>中序访问顺序（对每颗子树 左头右）：</h5><p>4 2 5 1 6 3 7</p><h5 id="后序访问顺序（对每颗子树-左右头）："><a href="#后序访问顺序（对每颗子树-左右头）：" class="headerlink" title="后序访问顺序（对每颗子树 左右头）："></a>后序访问顺序（对每颗子树 左右头）：</h5><p>4 5 2 6 7 3 1</p><hr><h3 id="使用非递归方式实现二叉树："><a href="#使用非递归方式实现二叉树：" class="headerlink" title="使用非递归方式实现二叉树："></a>使用非递归方式实现二叉树：</h3><h5 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h5><ol><li>创建一个栈（Stack）对象，将头节点压入栈列</li><li>弹出栈顶节点 Car</li><li>打印处理 Car</li><li>先压入右节点，再压入左节点（有就压）</li><li>返回第二步，直至栈空</li></ol><pre><code class="java">//代码实现public static void preOrder(Node head) &#123;    if(head != null)&#123;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();        stack.push(head);        while(!stack.isEmpty()) &#123;            head = stack.pop();            System.out.println(head.value());            if(head.right != null) &#123;                stack.push(head.right);            &#125;            if(head.left != null) &#123;                stack.push(head.left);                    &#125;        &#125;    &#125;&#125;</code></pre><h5 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h5><ol><li>创建一个栈，将数的最左边界依次压入</li><li>弹出打印栈顶元素，若栈顶存在右子树，将右子树的最左边界依次压入</li><li>循环2，直至栈空</li></ol><pre><code class="java">public static void (Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();        while(!stack.isEmpty() || head != null) &#123;            if(head != null) &#123;                stack.push(head);                head = head.left;            &#125;else &#123;            head = stack.pop();            System.out.println(head.value());               head = head.right;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h5><ol><li>创建两个栈（存储栈和收集栈）</li><li>弹出存储栈头节点，压入收集栈</li><li>将2中弹出的节点，以先压左节点再压右节点的顺序压入存储栈</li><li>返回2，直到存储栈为空</li><li>依次打印收集栈顺序</li></ol><pre><code class="java">public static void posOrder(Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; st1 = new Stack&lt;&gt;();        Stacj&lt;Node&gt; st2 = new Stack&lt;&gt;();        st1.push(head);        while(!st1.isEmpty())&#123;            head = st1.pop();            st2.push(head);            if(head.left != null)&#123;                st1.push(head.left);            &#125;            if(head.right != null) &#123;                st1.push(head.right);            &#125;        &#125;        while(!st2.isEmpty())&#123;            System.out.println(st2.pop().value);        &#125;    &#125;&#125;</code></pre><hr><h3 id="实现二叉树的宽度优先遍历："><a href="#实现二叉树的宽度优先遍历：" class="headerlink" title="实现二叉树的宽度优先遍历："></a>实现二叉树的宽度优先遍历：</h3><h5 id="使用队列："><a href="#使用队列：" class="headerlink" title="使用队列："></a>使用队列：</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>弹出打印队列首个对象，将其左子树先放入队列，再放其右子树（如果有）</li><li>循环2，直到队列为空</li></ol><pre><code class="java">public static void widthOrder(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        System.out.println(head.value);        if(head.left != null) &#123;            queue.add(head.left);        &#125;        if(head.right != null) &#123;            queue.add(head.right);        &#125;    &#125;&#125;</code></pre><h5 id="算法题：求一个二叉树的最大宽度？"><a href="#算法题：求一个二叉树的最大宽度？" class="headerlink" title="算法题：求一个二叉树的最大宽度？"></a>算法题：求一个二叉树的最大宽度？</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>创建一个hashMap对象，用于记录节点与当前所在深度，将&lt;head, 1&gt;记录</li><li>创建初始深度（int）设为1，初始节点数（int）设为0，初始最大值（int）设为Integer.MIN_VALUE;</li><li>弹出队列首个对象，并根据HashMap判断该节点是否是当前深度的节点，是：节点数++，否：最大值&#x3D;max（max，节点数），深度++，节点数设为1</li><li>将其左子树先放入队列，hashMap放入&lt;head.left，深度+1&gt;；再放其右子树，hashMap放入&lt;head.right，深度+1&gt;（如果有）</li><li>循环2-5，直到队列为空</li><li>调用Max函数计算最后一行节点个数和最大节点的比较</li></ol><pre><code class="java">public static void getMaxWidth(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    HashMap&lt;Node,Integer&gt; levelMap = new HashMap&lt;&gt;();    levelMap.put(head,1);    int curlevel = 1;//当前层数    int curNodeNum = 0;//当前节点数    int max = Integer.MIN_VALUE;//最大节点值    while(!queue.isEmpty()) &#123;        head = queue.poll();        int levelNode = levelMap.get(head);        if(levelNode == curlevel) &#123;//判断是否变层            cerNodeNum ++;//未变层，节点数++        &#125;else &#123;            max = Math.max(max, curNodeNum);//下一层，结算上一层的max，重置当前节点数            curLevel ++;            curNodeNum = 1;        &#125;        if(head.left != null) &#123;            queue.add(head.left);            levelMap.put(head.left,curlevel+1)//记录左子树以及其对应层，用于后续判断        &#125;        if(head.right != null) &#123;            queue.add(head.right);            levelMap.put(head.right,curlevel+1)//记录右子树以及其对应层，用于后续判断        &#125;    &#125;    max = Math(max, curNodeNum);&#125;</code></pre><h5 id="不使用哈希表完成上述题目："><a href="#不使用哈希表完成上述题目：" class="headerlink" title="*不使用哈希表完成上述题目："></a>*不使用哈希表完成上述题目：</h5><p>使用两个Node变量替代哈希表（当前层最后的节点，下一层最后的节点）</p><p>将head赋予当前层最后节点，在每次新添左右节点时，分别更新下一层最后节点为左右节点</p><p>每次队列弹出都检查是否是当前层最后节点，是：更新最大值，拷贝下一层最后节点至当前层最后节点，层数++；否：节点数++</p><h3 id="二叉树深度优先遍历：先序遍历"><a href="#二叉树深度优先遍历：先序遍历" class="headerlink" title="二叉树深度优先遍历：先序遍历"></a>二叉树深度优先遍历：先序遍历</h3><hr><h3 id="搜索二叉树："><a href="#搜索二叉树：" class="headerlink" title="搜索二叉树："></a>搜索二叉树：</h3><p>对于每一个子树，都满足其左树值比根节点值小，右树值比根节点大（一般不存在重复值）</p><h5 id="如何判断是否是搜索二叉树：中序遍历为升序"><a href="#如何判断是否是搜索二叉树：中序遍历为升序" class="headerlink" title="如何判断是否是搜索二叉树：中序遍历为升序"></a>如何判断是否是搜索二叉树：中序遍历为升序</h5><pre><code class="java">public static int prevalue = Integer.MIN_VALUE;public static boolean isBSt(Node head) &#123;    if(head == null) return true;    boolean isLeftBst = isBST(head.left);//左子树是否为搜索二叉树    if(!isLeftBst) return false;    if(head.value &lt;= preValue) &#123;//升序判断，动态检查        return false;    &#125;else &#123;        preValue = head.value;    &#125;    return isBST(head.right);//左子树是搜索二叉树，右子树是否为搜索二叉树&#125;</code></pre><p>非遍历判断同理</p><h5 id="总结返回信息："><a href="#总结返回信息：" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左子树：1.左树应是搜索二叉树2.获取左数的最大值（用于与根比较）</p><p>对于右子树：1.右树应是搜索二叉树2.获取右数的最小值（用于与根比较）</p><p>统一左右子树返回信息：是否是搜索二叉树，最小值，最大值</p><h5 id="判断是否为搜索二叉树："><a href="#判断是否为搜索二叉树：" class="headerlink" title="判断是否为搜索二叉树："></a>判断是否为搜索二叉树：</h5><pre><code class="java">public static boolean checkBST(Node head) &#123;    return process(head).isBST;&#125;//返回类型public static class ReturnType &#123;    public boolean isBST;    public int min;    public int max;        public ReturnData(boolean isb, int min, int max)&#123;        this.isBST = isb;        this.min = min;        this.max = max;    &#125;&#125;public static ReturnType process(Node x) &#123;    if(x == null) return null;    ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);    //获得整个子树的最大最小值    int min = x.value;    int max = x.value;    if(leftData != null) &#123;        min = Math.min(min,leftData.min);        max = Math.max(max,leftData.max);    &#125;    if(rightData != null) &#123;        min = Math.min(min,rightData.min);        max = Math.max(max,rightData.max);    &#125;           boolean isBST = true;    if(leftData != null &amp;&amp; (!leftData.isBST || leftData.max &gt;= x.value) &#123;        isBST = false;    &#125;    if(rightData != null &amp;&amp; (!rightData.isBST || x.value &gt;= rightData.min) &#123;        isBST = false;    &#125;       return new ReturnType(isBST,min,max);&#125;</code></pre><h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p>所有节点依次按从左往右依次放入的二叉树属于完全二叉树</p><ol><li>任意一节点有右孩子无左孩子 → 不是完全二叉树</li><li><strong>宽度优先遍历</strong>且在<strong>不违反1</strong>前提下，出现首个左右孩子不双全时，之后的节点都应该是叶子节点</li></ol><pre><code class="java">public static boolean isCBT(Node head) &#123;    if(head == null) return true;    //是否遇到过左右孩子不双全的判断    boolean leaf = false;    Node l = null;    Node r = null;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        l = head.left;        r = head.right;        if((leaf &amp;&amp; (l!=null || r!=null))//条件2          ||           (l == null &amp;&amp; r == null)//条件1          )&#123;            return false;        &#125;        if(l != null) &#123;            queue.add(l);        &#125;        if(r != null) &#123;            queue.add(r);        &#125;        if(l == null || r == null) &#123;            //leaf 为不可逆改变            leaf = true;        &#125;       &#125;    return true;&#125;</code></pre><h3 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h3><p>子节点要么都有，要么都没有，不存在只存在一边节点的二叉树</p><h5 id="判断是否为满二叉树："><a href="#判断是否为满二叉树：" class="headerlink" title="判断是否为满二叉树："></a>判断是否为满二叉树：</h5><pre><code class="java">public static boolean isFBT(Node head) &#123;    if(head == null) &#123;        return true;    &#125;    info data = process(head);    return data.nodes == ((1&lt;&lt;data.height) - 1);&#125;//返回信息public static class Info &#123;    public int height;//高度    public int nodes;//节点数        public Info(int hei, int nod) &#123;        this.height = hei;        this.nodes = nod;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static Info process(Node x) &#123;    if(x == null) &#123;        return new Info(0, 0);    &#125;        Info leftData = process(x.left);    Info rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    int nodes = leftData.nodes + rightData.nodes + 1;        return new Info(height, nodes);&#125;</code></pre><h3 id="平衡二叉树："><a href="#平衡二叉树：" class="headerlink" title="平衡二叉树："></a>平衡二叉树：</h3><p>对于任意一颗子树，其左树高度和右树高度差不少过1</p><ol><li>节点左树是平衡二叉树</li><li>节点右树是平衡二叉树</li><li>|节点左树高度 - 节点右数高度| &lt;&#x3D; 1</li></ol><p>以上条件对每个节点都成立，这个树就是平衡二叉树，否则不是</p><h5 id="总结返回信息：-1"><a href="#总结返回信息：-1" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左树，我们希望知道：1.左树是否是平衡二叉树2.左树高度</p><p>对于右数，我们希望知道：1.右树是否是平衡二叉树2.右数高度</p><p>左右树需要的信息一致；</p><h5 id="判断是否为平衡二叉树："><a href="#判断是否为平衡二叉树：" class="headerlink" title="判断是否为平衡二叉树："></a>判断是否为平衡二叉树：</h5><pre><code class="java">//返回值的变动，调用其他方法返回public static boolean isBT(Node head) &#123;    return process(head).isBalanced;&#125;//返回信息public static class ReturnType &#123;    public boolean isBalanced;//是否是平衡二叉树    public int height;//高度        public ReturnType(boolean isB, int hei) &#123;        this.isBalanced = isB;        this.height = hei;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static ReturnType process(Node x) &#123;    if(x == null) &#123;        return new ReturnType(true, 0);    &#125;        ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    boolean isBalance = leftData.isBalanced &amp;&amp; rightData.isBalanced                        &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; 2;        return new ReturnType(isBalance, height);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h1><ul><li>类，超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装器与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射</li><li>继承的设计技巧</li></ul><h3 id="类，超类和子类："><a href="#类，超类和子类：" class="headerlink" title="类，超类和子类："></a>类，超类和子类：</h3><h5 id="使用关键字：extends-表示继承"><a href="#使用关键字：extends-表示继承" class="headerlink" title="使用关键字：extends 表示继承"></a>使用关键字：extends 表示继承</h5><pre><code class="java">public class A extends B &#123;    ...&#125;</code></pre><p>超类 &#x3D; 基类 &#x3D; 父类子类 &#x3D; 孩子类</p><h5 id="使用父类的方法：-super"><a href="#使用父类的方法：-super" class="headerlink" title="使用父类的方法： super"></a>使用父类的方法： super</h5><pre><code class="java">super.fun();//使用父类的fun方法super();//使用父类的构造器方法</code></pre><h5 id="多态：可将子类对象赋予给超类变量"><a href="#多态：可将子类对象赋予给超类变量" class="headerlink" title="多态：可将子类对象赋予给超类变量"></a>多态：可将子类对象赋予给超类变量</h5><pre><code class="java">Employee e;//Manager extends Employeee = new Employee();//OKe = new Manager();      //ok</code></pre><p>强制类型转换：A a &#x3D; (A) b;后续使用可能会报错</p><p>在超类强转为子类前可以使用：instanceof 监测是否能强转</p><pre><code class="java">if(b instanceof a)&#123;//如果b能强转为a，就可以将b转为a给予其他变量使用    c = (a)b;&#125;</code></pre><h5 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h5><p>使用abstract关键字的方法不需要具体实现</p><p>含有抽象方法的对象必须为抽象对象，抽象对象不可以被实例化</p><h3 id="Object：所有子类的超类"><a href="#Object：所有子类的超类" class="headerlink" title="Object：所有子类的超类"></a>Object：所有子类的超类</h3><h5 id="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"><a href="#equals方法：监测对象是否相等，比较对象的各个属性而非具体地址" class="headerlink" title="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"></a>equals方法：监测对象是否相等，比较对象的各个属性而非具体地址</h5><h5 id="hashCode方法：散列码，由对象导出的整型数"><a href="#hashCode方法：散列码，由对象导出的整型数" class="headerlink" title="hashCode方法：散列码，由对象导出的整型数"></a>hashCode方法：散列码，由对象导出的整型数</h5><p>每个对象的散列码基本不相同，可以用作区分不同对象的标识</p><h5 id="toString方法：返回字符串类型对象信息"><a href="#toString方法：返回字符串类型对象信息" class="headerlink" title="toString方法：返回字符串类型对象信息"></a>toString方法：返回字符串类型对象信息</h5><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><h5 id="ArrayList：自定义类型数组"><a href="#ArrayList：自定义类型数组" class="headerlink" title="ArrayList：自定义类型数组"></a>ArrayList：自定义类型数组</h5><pre><code class="java">ArrayList&lt;ClassName&gt; a = new ArrayLisrt&lt;&gt;();//ArrayList数组中全是ClassName类型对象var b = new ArrayList&lt;ClassName&gt;();//效果同上，java 10以后可以使用var避免重复书写类名</code></pre><p>使用trimToSIze()方法裁剪数组多余部分</p><h5 id="数组列表访问对象："><a href="#数组列表访问对象：" class="headerlink" title="数组列表访问对象："></a>数组列表访问对象：</h5><pre><code class="java">var A = new ArrayList&lt;ClassB&gt;();A.set(i,Obj);//使用set方法赋值，第几位，赋什么A.get(i);//获得第几位的信息A.size();//获取列表数量，不可以用length</code></pre><h3 id="对象包装器和自动包装"><a href="#对象包装器和自动包装" class="headerlink" title="对象包装器和自动包装"></a>对象包装器和自动包装</h3><p>有时会需要将int这样的基本类转换为对象，我们称这样的类为包装器：<br><strong>int - Integetlong - Longfloat - Floatdouble - Doubleshort - Shortchar -  Characterboolean - Boolean</strong></p><p>前六个类派生于公类Number</p><p>包装器类是不可变的，一旦构造便不允许更改其包装在其中的值，同时包装器也是final，不可以派生子类</p><pre><code class="java">ArrayList&lt;int&gt; ... //是错误的ArrayList&lt;Integer&gt; ... //是正确的</code></pre><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>在类后加上… 即可</p><pre><code class="java">public static double max(double... values)&#123;    double larger = Double.NEGATIVE_INFINITY    for(double v : values) if (v&gt;larger) larger = v;    return larger;&#125;double a = max(3.1, 40.2, -5);</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code class="java">public enum Size &#123; SMALL, MEDIUM, LAGER, EXTRA_LARGE &#125;;//枚举的各个方法static Enum valueOf(Class enumClass, String name)//返回给定类中有指定名字的枚举常量String toString()//返回枚举常量名int ordinal()//返回枚举常量在enum声明中的位子，从0开始记数int compareTo(E other)//如果枚举常量在other之前，返回负整数；如果other==this,返回0；否则返回正整数。枚举常量次序在enum声明中给出</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序被成为反射</p><h5 id="Class类："><a href="#Class类：" class="headerlink" title="Class类："></a>Class类：</h5><pre><code class="java">Employee A;Class cl = a.getClass();//保存一个Class类型实例，可以使用对应方法，如getName()String name = cl.getName();//name = &quot;Employee&quot;String ckassName = &quot;java.util.Random&quot;;Class cl = Class.forName(className);//效果同上Class c1 = Employee.class;//效果同上</code></pre><h5 id="异常：非检查型异常（unchecked），检查型异常（checked）"><a href="#异常：非检查型异常（unchecked），检查型异常（checked）" class="headerlink" title="异常：非检查型异常（unchecked），检查型异常（checked）"></a>异常：非检查型异常（unchecked），检查型异常（checked）</h5><p>异常可以通过在类名后添加 throws … 对应语句</p><h5 id="资源-："><a href="#资源-：" class="headerlink" title="资源 ："></a>资源 ：</h5><pre><code class="java">Class cl = ResourceTest.class;URL url = cl.getResource(&quot;b.gif&quot;);...//多种方法</code></pre><h5 id="检查类的结构：FIeld，Method，Constructor"><a href="#检查类的结构：FIeld，Method，Constructor" class="headerlink" title="检查类的结构：FIeld，Method，Constructor"></a>检查类的结构：FIeld，Method，Constructor</h5><p>java.lang.reflect 中的三个方法：FIeld，Method，Constructor 分别用于返回 字段，方法 和 构造器 的名称</p><p>其中：getDeclareFields，getDeclareMethods，getDeclareConstructors 返回声明中的全部字段，方法，构造器的数组</p><p>通过setAccessible方法可以覆盖Java的访问控制，避免私有属性调用报错</p><h5 id="newInstance方法："><a href="#newInstance方法：" class="headerlink" title="newInstance方法："></a>newInstance方法：</h5><p>提供Array的元素类型，提供数组长度即可生成对应数组</p><h5 id="invoke方法："><a href="#invoke方法：" class="headerlink" title="invoke方法："></a>invoke方法：</h5><p>允许调用Method中的方法</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口，lambda表达式与内部类"><a href="#接口，lambda表达式与内部类" class="headerlink" title="接口，lambda表达式与内部类"></a>接口，lambda表达式与内部类</h1><ul><li>接口</li><li>lambda表达式</li><li>内部类</li><li>服务加载器 (null)</li><li>代理</li></ul><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>使用关键字： interface (定义接口)， implements (实现接口)</p><p>接口中的方法自动为public，写接口时不需要赋予public权限词</p><h5 id="实现接口需要实现其全部方法"><a href="#实现接口需要实现其全部方法" class="headerlink" title="实现接口需要实现其全部方法"></a>实现接口需要实现其全部方法</h5><pre><code class="java">interface A;class B implements A;A a = new A();//错误A b;b = new B();//正确,可以声明接口变量，实例化为实现接口的对象</code></pre><h5 id="java是单继承，每个类只能有一个超类，但能实现很多接口"><a href="#java是单继承，每个类只能有一个超类，但能实现很多接口" class="headerlink" title="java是单继承，每个类只能有一个超类，但能实现很多接口"></a>java是单继承，每个类只能有一个超类，但能实现很多接口</h5><p>*使用 static ，private 关键词创造静态私有方法</p><p>使用 default 关键字创造默认方法，可以直接在接口中提供默认实现</p><pre><code class="java">public interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123; return 0; &#125;&#125;</code></pre><h5 id="默认方法冲突："><a href="#默认方法冲突：" class="headerlink" title="默认方法冲突："></a>默认方法冲突：</h5><ol><li>超类优先：如果超类提供了一个具体方法，同名且有相同参数的默认方法会被忽略</li><li>接口冲突：两个接口提供了同名同参的方法时，必须覆盖这个方法依解决问题（声明实现其中一个）</li></ol><h3 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="*lambda表达式："></a>*lambda表达式：</h3><p>目的： 方便的传递代码块</p><pre><code class="java">// 有参数lambda表达式(String first, String second) -&gt;&#123;    if(first.length() &lt; second.length()) return -1;    else if(first.length() &gt; second.length) return 1;    else return 0;&#125;// 无参数lambda表达式() -&gt;&#123;    for(int i=0; i&lt;100; i++)        System.out.println(i);&#125;//方法引用 (::)...//构造器引用 (new)</code></pre><h5 id="Comparing比较器"><a href="#Comparing比较器" class="headerlink" title="Comparing比较器"></a>Comparing比较器</h5><h3 id="内部类："><a href="#内部类：" class="headerlink" title="*内部类："></a>*内部类：</h3><p>内部类是定义在另一个类中的类，可以简洁的回调：</p><ol><li>内部类对同一个包中的其他类隐藏</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原有的私有数据</li></ol><h5 id="外围类引用：OuterClass-this"><a href="#外围类引用：OuterClass-this" class="headerlink" title="外围类引用：OuterClass.this"></a>外围类引用：OuterClass.this</h5><h5 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h5><p>不仅在类中，同时在局部（方法）中定义类，被称为局部内部类</p><h5 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h5><p>直接new对象并给定义（属性方法）不用设类名</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><p>将内部类声明为static就不会产生引用</p><h3 id="服务加载器："><a href="#服务加载器：" class="headerlink" title="服务加载器："></a>服务加载器：</h3><p>null</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理类包含以下方法：</p><ul><li>指定接口所需要的全部方法</li><li>Object类中的全部方法，如toString，equals等</li></ul><p>创建代理对象需要使用 Proxy 类的newProxyInstance方法，对应的三个参数为：</p><ul><li>一个类加载器 （class loader）</li><li>一个Class对象数组</li><li>一个调用处理器</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与类</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="对象与类："><a href="#对象与类：" class="headerlink" title="对象与类："></a>对象与类：</h1><ul><li>面向对象程序设计概述</li><li>适用预定义类</li><li>用户自定义方法</li><li>静态字段与静态方法</li><li>方法参数</li><li>对象构造</li><li>包</li><li>JAR文件</li><li>文档注释</li><li>类设计技巧</li></ul><h3 id="面向对象程序设计概述-OOP"><a href="#面向对象程序设计概述-OOP" class="headerlink" title="面向对象程序设计概述(OOP)"></a>面向对象程序设计概述(OOP)</h3><h5 id="类：存储数据字段和方法的摸具"><a href="#类：存储数据字段和方法的摸具" class="headerlink" title="类：存储数据字段和方法的摸具"></a>类：存储数据字段和方法的摸具</h5><h5 id="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"><a href="#封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法" class="headerlink" title="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"></a>封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法</h5><h5 id="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"><a href="#对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）" class="headerlink" title="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"></a>对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）</h5><h5 id="识别类：Item，Order等为人熟悉的人为设计类"><a href="#识别类：Item，Order等为人熟悉的人为设计类" class="headerlink" title="识别类：Item，Order等为人熟悉的人为设计类"></a>识别类：Item，Order等为人熟悉的人为设计类</h5><h5 id="类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a"><a href="#类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a" class="headerlink" title="类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)"></a>类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)</h5><h3 id="使用预定义类："><a href="#使用预定义类：" class="headerlink" title="使用预定义类："></a>使用预定义类：</h3><p>使用构造器（constructor 构造函数）在目标类前加上 new 操作符</p><p>表示时间点的Date类</p><p>*表示日历的LocalDate类</p><h3 id="用户自定义类与自定义方法："><a href="#用户自定义类与自定义方法：" class="headerlink" title="用户自定义类与自定义方法："></a>用户自定义类与自定义方法：</h3><p>使用class关键字自定义类</p><p>“javac className*.java”与”javac classNameTest.java”都可以视为编译className类</p><h5 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h5><ul><li>构造器需要与类名同名</li><li>每个类可以有一个以上的构造器（0，1，2…个不同参数）</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作符一起调用</li></ul><p>var声明局部变量：仅能用于方法中，参数与字段仍需要声明</p><h5 id="实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"><a href="#实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改" class="headerlink" title="实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"></a>实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改</h5><h3 id="静态字段与静态方法："><a href="#静态字段与静态方法：" class="headerlink" title="静态字段与静态方法："></a>静态字段与静态方法：</h3><p>静态常量：static final</p><p>静态方法：static</p><p>工厂方法：使用静态方法构造对象</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>形参与实参</p><h3 id="对象构造："><a href="#对象构造：" class="headerlink" title="对象构造："></a>对象构造：</h3><h5 id="重载：多个方法具有相同的函数名，不同的参数"><a href="#重载：多个方法具有相同的函数名，不同的参数" class="headerlink" title="重载：多个方法具有相同的函数名，不同的参数"></a>重载：多个方法具有相同的函数名，不同的参数</h5><h5 id="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）"><a href="#默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）" class="headerlink" title="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）"></a>默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）</h5><h5 id="调用其他构造器：this-…"><a href="#调用其他构造器：this-…" class="headerlink" title="调用其他构造器：this(…)"></a>调用其他构造器：this(…)</h5><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><h5 id="英特网域名的作用之一就是保证-包名的唯一性"><a href="#英特网域名的作用之一就是保证-包名的唯一性" class="headerlink" title="英特网域名的作用之一就是保证 包名的唯一性"></a>英特网域名的作用之一就是保证 包名的唯一性</h5><h5 id="引入类的方法："><a href="#引入类的方法：" class="headerlink" title="引入类的方法："></a>引入类的方法：</h5><ol><li>直接使用 包名.类名</li><li>提前使用import声明引入包类</li></ol><p>包访问权限（public-全部，private-本类，protected-本包与子类，默认-本包）</p><h5 id="包-类路径：设置类路径-classpath（命令行指令）"><a href="#包-类路径：设置类路径-classpath（命令行指令）" class="headerlink" title="包.类路径：设置类路径 -classpath（命令行指令）"></a>包.类路径：设置类路径 -classpath（命令行指令）</h5><h3 id="JAR文件（java归档文件）："><a href="#JAR文件（java归档文件）：" class="headerlink" title="JAR文件（java归档文件）："></a>JAR文件（java归档文件）：</h3><p>jar文件是一种zip压缩文件</p><p>*目前常使用maven等协助打包</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>注释要写全，写细</p><h3 id="类设计技巧："><a href="#类设计技巧：" class="headerlink" title="类设计技巧："></a>类设计技巧：</h3><ol><li>保证数据私有</li><li>对数据进行初始化</li><li>不要在类中使用过多的基本类型</li><li>不是所有字段都需要单独的字段访问器和字段更改器</li><li>分解有过多指责的类</li><li>类名与方法名要能体现他们的职责</li><li>优先使用不可变的类</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计结构</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序设计结构"><a href="#Java程序设计结构" class="headerlink" title="Java程序设计结构"></a>Java程序设计结构</h1><ul><li>数据类型</li><li>变量与常量</li><li>运算符</li><li>字符串</li><li>输入输出</li><li>控制流</li><li>大数</li><li>数组</li></ul><h4 id="保留字与关键字："><a href="#保留字与关键字：" class="headerlink" title="保留字与关键字："></a>保留字与关键字：</h4><p>关键字：目前已经有特殊作用的单词字符，例如static，class等</p><p>保留字：包括关键字，同时还有部分目前未被使用，但未来可能会被使用的单词字符</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>八种基本类型，包括</p><ul><li><p>四种整型：int（四字节，正负21e），short（二字节，正负三万二），</p><p>​long（八字节，正负900ee），byte（一字节，-128—127）</p></li><li><p>两种浮点型：float（四字节），double（八字节）</p></li><li><p>一种字符型：char（二字节），用于表示Unicode编码的代码单元</p></li><li><p>一种用于表真值：boolean</p></li></ul><p>浮点数遵循IEEE 754规范：</p><p>NAN为非数字，例如0&#x2F;0会得到Double.NAN；</p><p>无穷大（正负）是特殊浮点Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY</p><h3 id="变量与常量："><a href="#变量与常量：" class="headerlink" title="变量与常量："></a>变量与常量：</h3><h5 id="变量：需要显式初始化变量"><a href="#变量：需要显式初始化变量" class="headerlink" title="变量：需要显式初始化变量"></a>变量：需要显式初始化变量</h5><pre><code class="java">boolean flag = false;</code></pre><h5 id="常量：使用关键字-static-final-设置常量，"><a href="#常量：使用关键字-static-final-设置常量，" class="headerlink" title="常量：使用关键字 static final 设置常量，"></a>常量：使用关键字 static final 设置常量，</h5><pre><code class="java">public static final int age = 18;</code></pre><h5 id="枚举类型：在有限集合内取值可以自定义枚举类型"><a href="#枚举类型：在有限集合内取值可以自定义枚举类型" class="headerlink" title="枚举类型：在有限集合内取值可以自定义枚举类型"></a>枚举类型：在有限集合内取值可以自定义枚举类型</h5><pre><code class="java">enum Size &#123; SMALL，MEDIUM，LARGE，EXTRA_LARGE &#125;;Size a = SIze.SMALL;</code></pre><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><h5 id="算数运算符（加减乘除余）：-x2F"><a href="#算数运算符（加减乘除余）：-x2F" class="headerlink" title="算数运算符（加减乘除余）：+ - * &#x2F; %"></a>算数运算符（加减乘除余）：+ - * &#x2F; %</h5><p>int类型会向下取整</p><h5 id="数学函数："><a href="#数学函数：" class="headerlink" title="数学函数："></a>数学函数：</h5><p>Math.sqrt（int a）：对a求平方根</p><p>Math.abs（int a） ：对a取绝对值</p><p>Math.round（double a）：对a四舍五入转为整型int</p><h5 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h5><p><img src="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/changeSize.jpg" alt="changeSize"></p><p>实线为无信息丢失的转换，虚线为存在精度丢失的转换</p><h5 id="关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D"><a href="#关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D" class="headerlink" title="关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;"></a>关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;</h5><h5 id="位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt"><a href="#位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt" class="headerlink" title="位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;"></a>位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;</h5><h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><h5 id="子串：（subString方法）"><a href="#子串：（subString方法）" class="headerlink" title="子串：（subString方法）"></a>子串：（subString方法）</h5><pre><code class="java">String str = &quot;Hello&quot;;String s = str.subString(0,3);//s = &quot;Hel&quot;,即0到2</code></pre><h5 id="相等：-equals方法"><a href="#相等：-equals方法" class="headerlink" title="相等：(equals方法)"></a>相等：(equals方法)</h5><pre><code class="java">if(str.equals(s))&#123;    return false;&#125;</code></pre><h5 id="空串与Null串："><a href="#空串与Null串：" class="headerlink" title="空串与Null串："></a>空串与Null串：</h5><pre><code class="java">if(str.length() == 0)//判断是否为空串：“”if(str == null)//判断是否为null串</code></pre><h5 id="构建字符串：（Stringbuilder类）"><a href="#构建字符串：（Stringbuilder类）" class="headerlink" title="构建字符串：（Stringbuilder类）"></a>构建字符串：（Stringbuilder类）</h5><pre><code class="java">//节省空间和时间的字节构建类型，直接append添加,toString成符StringBuilder bs = new StringBuilder();bs.append(&quot;a&quot;);bs.append(&quot;b&quot;);String s = bs.toString();</code></pre><h3 id="输入和输出："><a href="#输入和输出：" class="headerlink" title="输入和输出："></a>输入和输出：</h3><h5 id="Util-Scanner类："><a href="#Util-Scanner类：" class="headerlink" title="Util.Scanner类："></a>Util.Scanner类：</h5><pre><code class="java">Scanner in = new Scanner(System.in);String name = in.nextLine();int age = in.nextInt();</code></pre><h5 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h5><pre><code class="java">double x = 10000 / 3.0;System.out.printf(&quot;%8.2f&quot;,x);//返回八个字符，小数点算一个，且返回小数点后两位，不够八位在前补充空格                                //x = 3333.33      </code></pre><h5 id="转换符："><a href="#转换符：" class="headerlink" title="转换符："></a>转换符：</h5><p>d：十进制x：十六进制o：八进制f：定点浮点数e：指数浮点数    ….</p><h3 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h3><h5 id="块作用域：-…"><a href="#块作用域：-…" class="headerlink" title="块作用域：{…}"></a>块作用域：{…}</h5><p>块内变量不会带到块外使用，块外已定义变量不允许块内重复定义</p><h5 id="判断：if，if-else，if-else-if-else"><a href="#判断：if，if-else，if-else-if-else" class="headerlink" title="判断：if，if-else，if-else if-else"></a>判断：if，if-else，if-else if-else</h5><h5 id="循环：for，-while，-do-while"><a href="#循环：for，-while，-do-while" class="headerlink" title="循环：for， while， do-while"></a>循环：for， while， do-while</h5><h5 id="多重选择：switch-case-default"><a href="#多重选择：switch-case-default" class="headerlink" title="多重选择：switch-case-default"></a>多重选择：switch-case-default</h5><h5 id="跳出：return，break，continue"><a href="#跳出：return，break，continue" class="headerlink" title="跳出：return，break，continue"></a>跳出：return，break，continue</h5><h3 id="大数："><a href="#大数：" class="headerlink" title="大数："></a>大数：</h3><p>java.Math包下的：BigInteger和Bigdecimal（比int和double都更加精确）</p><pre><code class="java">BigDecimal a = new BigDecimal(&quot;0.1&quot;);//String转Big,精确BigDecimal a = new BigDecimal(0.1);//Double转Big,不精确，可能变成0.0999999998之类的</code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h5 id="声明与初始化："><a href="#声明与初始化：" class="headerlink" title="声明与初始化："></a>声明与初始化：</h5><pre><code class="java">int[] a;//声明int[] b = new int[100];//初始化a = &#123;1,2,3,4,5&#125;//赋值</code></pre><h5 id="循环：for，for-each"><a href="#循环：for，for-each" class="headerlink" title="循环：for，for-each"></a>循环：for，for-each</h5><h5 id="数组拷贝：Arrays-copyOf-：生成新数组的深拷贝"><a href="#数组拷贝：Arrays-copyOf-：生成新数组的深拷贝" class="headerlink" title="数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝"></a>数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝</h5><pre><code class="java">int[] c = Arrays.copyOf(a,a.length);//第一个参数为拷贝对象，第二个参数为创建数组c的长度</code></pre><h5 id="数组排序：Arrays-sort-：快速排序"><a href="#数组排序：Arrays-sort-：快速排序" class="headerlink" title="数组排序：Arrays.sort()：快速排序"></a>数组排序：Arrays.sort()：快速排序</h5>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
