<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux目录文件和基本指令</title>
      <link href="/2023/02/01/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/02/01/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录文件和基本指令"><a href="#Linux目录文件和基本指令" class="headerlink" title="Linux目录文件和基本指令"></a>Linux目录文件和基本指令</h1><ul><li>Linux目录文件夹</li><li>基本指令</li></ul><h3 id="Linux目录文件夹"><a href="#Linux目录文件夹" class="headerlink" title="Linux目录文件夹"></a>Linux目录文件夹</h3><table><thead><tr><th align="center">目录地址</th><th align="center">目录内容</th></tr></thead><tbody><tr><td align="center"><strong>&#x2F;bin</strong></td><td align="center">存放常用指令</td></tr><tr><td align="center"><strong>&#x2F;home</strong></td><td align="center">存放用户信息</td></tr><tr><td align="center"><strong>&#x2F;root</strong></td><td align="center">超级管理员目录（文件管理）</td></tr><tr><td align="center"><strong>&#x2F;etc</strong></td><td align="center">存放系统所需的配置文件和子目录</td></tr><tr><td align="center"><strong>&#x2F;usr</strong></td><td align="center">存放系统所需要的配置文件，类似windows下的programfile文件夹</td></tr><tr><td align="center"><strong>&#x2F;boot</strong></td><td align="center">存放Linux启动的核心文件，包括一些连接文件和镜像文件</td></tr><tr><td align="center"><strong>&#x2F;mnt</strong></td><td align="center">用于让用户临时挂载别的文件</td></tr><tr><td align="center"><strong>&#x2F;media</strong></td><td align="center">Linux自动识别设备：U盘，光驱等</td></tr><tr><td align="center"><strong>&#x2F;usr&#x2F;local</strong></td><td align="center">另一个主机歪歪安装软件的目录，以编译源码的方式安装</td></tr><tr><td align="center">&#x2F;sbin</td><td align="center">存放管理员（Super user）使用的管理系统管理程序&#x2F;指令</td></tr><tr><td align="center">&#x2F;lib</td><td align="center">类似DLL文件，存放基本动态连接共享库</td></tr><tr><td align="center">&#x2F;lost+found</td><td align="center">一般是空文件且不可见，当系统非法关机后存放信息</td></tr><tr><td align="center">&#x2F;proc</td><td align="center">虚拟目录【不可动】存放系统内存映射</td></tr><tr><td align="center">&#x2F;srv</td><td align="center">存放服务启动后要提取的数据</td></tr><tr><td align="center">&#x2F;sys</td><td align="center">安装了Linux2.6 内核的新文件系统</td></tr><tr><td align="center">&#x2F;tmp</td><td align="center">存放临时文件</td></tr><tr><td align="center">&#x2F;dev</td><td align="center">类似windows 设备管理器</td></tr><tr><td align="center">&#x2F;opt</td><td align="center">给主机额外安装软件所摆放的目录</td></tr><tr><td align="center">&#x2F;var</td><td align="center">存放正在扩充的文件&#x2F;经常修改的文件</td></tr></tbody></table><h3 id="基本指令："><a href="#基本指令：" class="headerlink" title="基本指令："></a>基本指令：</h3><p>正常模式：在目录页使用 <strong>vim 文件地址</strong> 进入正常模式，仅查看文件，按下[ i ] [ I ] [ a ] [ A ] [ o ] [ O ] [ r ] [ R ]，会进入插入模式 </p><p>插入模式：[ esc ]推出至正常模式，[ esc ] + [ : ] 进入命令模式</p><p>命令模式：[ : ] +  wq  写入并退出  ，[ : ] + [ q ] 退出不写入  ，[ : ] +  q!  强制退出  </p><p>拷贝当前行：  yy拷贝以下n行：【数字n】yy粘贴：p</p><p>删除当前行： dd删除以下n行： 【数字n】dd</p><p>查找： &#x2F;关键字 + [ Enter ]查找的下一个：[ n ]</p><p>显示行号： [ : ] + set nu不显示行号： [ : ] + setnonu</p><p>撤销： [ u ] 跳转至文尾： [ G ] 跳转至文首： [ gg ]</p><p>跳转行：  [ 数字 ] + [ shift ] + [ g ]</p><p>关机： shutdown -h now一分钟后关机：shutdown -h 1重启：shutdown -r now</p><p>超级登录：su - [ 用户名 ]注销：logout退出超级模式： exit</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6常见问题</title>
      <link href="/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片学习内容整理至b站 <a href="https://space.bilibili.com/526653251">IT老哥</a> 的视频 <a href="https://www.bilibili.com/video/BV1sR4y1c7Ni?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">《会了这些面试题后，可以挑战一下字节了》</a></p></blockquote><ul><li>单线程的Redis为什么快</li><li>五种基本数据类型底层采用什么数据结构</li><li>缓存雪崩，缓存穿透，缓存击穿，附加</li><li>Redis的过期淘汰机制</li><li>redis与memcached的区别</li><li>redis线程模型</li><li>哨兵Sentinel</li><li>如何实现redis事务</li></ul><h2 id="单线程的Redis为什么快？"><a href="#单线程的Redis为什么快？" class="headerlink" title="单线程的Redis为什么快？"></a>单线程的Redis为什么快？</h2><p>Redis有多快？官方给出的读写速度是10w&#x2F;s，在单线程的前提下跑出这个好成绩，原因有以下几点：</p><ul><li><strong>Redis是完全基于内存</strong>的，因此读写效率高，同时Redis的持久化操作是通过fork子进程和Linux系统的页面缓存技术完成，并不会影响Redis</li><li><strong>单线程操作</strong>：单线程避免了频繁上下文切换导致的性能开销</li><li>合理高效的<strong>数据结构</strong></li><li>采用了<strong>非阻塞的IO多路复用机制</strong>：多路I&#x2F;O复用模型是利用select，poll，epoll可以同时监察多个流的IO事件的能力，在空闲时阻塞当前线程，当有一个或多个流有IO事件时，就从阻塞中唤醒，程序再依次轮询所有的流，并且只依次顺序处理就绪的流，这种做法避免了大量无用操作</li></ul><h2 id="五种基本数据类型底层采用什么数据结构"><a href="#五种基本数据类型底层采用什么数据结构" class="headerlink" title="五种基本数据类型底层采用什么数据结构"></a>五种基本数据类型底层采用什么数据结构</h2><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>存储数字时：int存储长度大于39字节字符：raw存储长度小于39字节字符：embstr</p><p>raw与embstr都是由SDS动态字符串构成的。唯一区别是raw分配存储时，redisobject 和 sds 各分配一块，而 embstr 是 redisobject 在一块内存中</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：双向链表</p><h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：哈希表</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>列表所有对象都是整数，且元素数量小于512：inset否则：哈希表</p><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset:"></a>Zset:</h4><p>列表所有对象长度均小于64字节，且元素数量小于128：ziplist否则：跳表</p><h2 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h2><p>在高并发下，大量缓存key在同一时间集体失效，大量请求直接落在数据库上，导致数据库宕机</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><ul><li>随机设置key失效时间，避免大量key集体失效</li></ul><pre><code class="redis">setRedis(Key, value, time+Math.random()*10000);</code></pre><ul><li>如果是集群部署，可以将热点数据均匀分布在不同的Redis库中避免key全部失效</li><li>跑定时任务，在缓存失效前刷新新缓存</li><li>不设置过期时间（不推荐）</li></ul><h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>redis缓存没有数据库中没有相关数据（如用户查询携带id&#x3D;-1的相关数据并不断发起请求），redis中没有数据，无法进行阻拦，请求直接穿透到数据库，导致数据库压力过大宕机</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>对不存在的数据将其缓存到redis中，设置key，value值为null（不论是数据未null还是系统bug），设置一个短期过期时间，避免影响用户正常使用</li><li>拉黑用户IP</li><li>对参数进行校验，不合法参数进行拦截</li><li>布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap (位图) 中，一个一定不存在的数据会被这个bitmap拦截掉，减少对底层存储系统的查询压力</li></ul><h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>某一个热点key，在不停的扛着高并发，当这个热点key在失效的一瞬间，持续的高并发访问就击破缓存直接访问数据库，导致数据库宕机</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>设置热点数据“永不过期”</li><li>加上互斥锁：对于多个线程同时去查询数据库的热点数据，我们可以在第一个查询数据上的请求使用互斥锁锁住它</li></ul><p>其他线程需要使用就得等待，第一个线程查询到了数据，将数据放置redis中缓存起来，后面的进程就可以直接使用缓存数据</p><h2 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h2><p>提前避免以上三问题：将redis，mysql等搭建成高可用集群，放置单点</p><p>出现错误如何修补    ：服务中进行限流 + 降级，放置mysql被打崩溃</p><p>实在严重到宕机补救：Redis持久化 RDB + AOF，宕机重启，自动从磁盘加载数据，快速回复缓存数据</p><h2 id="Redis的过期淘汰机制："><a href="#Redis的过期淘汰机制：" class="headerlink" title="Redis的过期淘汰机制："></a>Redis的过期淘汰机制：</h2><p>Redis中数据过期策略采用定期删除 + 惰性删除策略</p><h4 id="1-定期删除，惰性删除策略是什么："><a href="#1-定期删除，惰性删除策略是什么：" class="headerlink" title="1.定期删除，惰性删除策略是什么："></a>1.定期删除，惰性删除策略是什么：</h4><ul><li>定期删除：Redis启用一个定时器定时监听所有key，判定key是否过期，过期就删除。尽管可以保证所有的过期key都会被删除，但是十分浪费cpu资源，且对于以及过期但是定时器还没启动的key，它任然可以使用。</li><li>惰性删除：在获得key时，先判断key是否以及过期过期就删除，缺点：如果这个key一直没被使用，那么它一直在内存，即便已经过期，这会浪费大量空间。</li></ul><h4 id="2-定期删除-惰性删除是如何工作的："><a href="#2-定期删除-惰性删除是如何工作的：" class="headerlink" title="2.定期删除 + 惰性删除是如何工作的："></a>2.定期删除 + 惰性删除是如何工作的：</h4><p>每次随机抽取一部分key进行检查，减少CPU资源的损耗，惰性删除策略互补了未检查到的key，基本上满足了所有要求</p><h4 id="3-补充的内存淘汰机制："><a href="#3-补充的内存淘汰机制：" class="headerlink" title="3.补充的内存淘汰机制："></a>3.补充的内存淘汰机制：</h4><ul><li><p>volatile - lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile - ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile - random：从已设置过期时间的数据集（server.db[i].expires）中挑选任意数据淘汰</p></li><li><p>allkeys - lru：当内存不足以容纳新写入的数据时，在键空间内，移除最近最少使用的key<strong>（这个最常用）</strong></p></li><li><p>allkeys - random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-eviction：禁止驱逐数据，永不过期，也就是当内存不足以写入新数据时，写入操作会报错<strong>（默认）</strong></p></li><li><p>volatile - lfu：4.0后加入，从已设过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p></li><li><p>allkeys - lfu：4.0后加入，当内存不足以写入新数据时，在键空间中，移除最不经常使用的key</p></li></ul><h2 id="Redis与memcached的区别："><a href="#Redis与memcached的区别：" class="headerlink" title="Redis与memcached的区别："></a>Redis与memcached的区别：</h2><p>存储方式上：memcached会将全部数据存入内存中，如果发生断电则会挂掉，数据不可以超过内存大小；redis有部分存在硬盘中，能保证数据的持久性</p><p>数据支持类型：memcached支持的数据类型相对简单；redis有复杂的数据类型</p><p>使用的底层模型不同：它们之间的底层实现，客户端之间通讯的应用协议不一样，redis自己构建了vm机制，因为一般的系统调用系统函数会浪费一定时间去移动和请求。value值大小不同，redis最大可到1gb；memcached只有1mb</p><h2 id="Redis线程模型："><a href="#Redis线程模型：" class="headerlink" title="Redis线程模型："></a>Redis线程模型：</h2><p>redis内部使用文件处理器 file event handler，这个文件事件处理器是单线程的，所以redis才叫单线程处理器模型。它采用IO多路复用机制监听多个socket，根据socket上事件处理器进行处理</p><p>文件事件处理器的结构包括4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）</li></ul><p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应事件处理器进行处理。</p><h2 id="哨兵Sentinel："><a href="#哨兵Sentinel：" class="headerlink" title="哨兵Sentinel："></a>哨兵Sentinel：</h2><p>哨兵是Redis高可用的解决方案，可以运行多个Sentinel组成一个哨兵分布式系统</p><p>哨兵主要解决的问题：故障转移，如果主节点挂掉，就进行主从切换，让从节点升级为主节点，继续对外提供服务</p><p>使用流言协议（gossip protocols）来接收主机是否下线；并使用投票协议（agreeement protocols）来决定是否执行自动故障转移；以及选择哪个服务器作为新的主服务器</p><h4 id="哨兵职责如下："><a href="#哨兵职责如下：" class="headerlink" title="哨兵职责如下："></a>哨兵职责如下：</h4><ul><li><p>监控：Sentinel会不断定期检查主服务器和从服务器是否运作正常</p></li><li><p>提醒：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或其他应用程序发送通知</p></li><li><p>自动故障迁移：当一个主服务器不能正常工作时，Sentinel会开启一次自动故障迁移操作，将失效服务器的其中一个从服务器升级为新的主服务器，并让失效服务器的其他服务器改为复制新的主服务器，当客户端连接失败主服务器时，集群也会向客户端返回新服务器地址，使得集群可以使用新主服务器替代失效服务器</p></li><li><p>统一配置管理：连接者询问Sentinel取得主从的地址</p></li></ul><h2 id="如何实现redis事务："><a href="#如何实现redis事务：" class="headerlink" title="如何实现redis事务："></a>如何实现redis事务：</h2><p>redis通过MULTI，EXEC，WATCH等命令来实现事务（transaction）功能，事务提供了一种将多个命令请求打包，然后一次性，按顺序的执行多个命令的机制，且在事务执行期间，服务器不会中断事务而改去执行其他客户端的请求，只有到这多个命令执行完毕后，才会接收其他命令</p><p>Redis事务也具有：原子性，一致性，隔离性；在特定情况下具有持久性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql备份</title>
      <link href="/2022/09/07/Mysql%E5%A4%87%E4%BB%BD/"/>
      <url>/2022/09/07/Mysql%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><ul><li>数据库备份语句与恢复语句</li><li>注意事项</li><li>示例展示</li><li>遇到的问题</li></ul><h3 id="数据库备份语句与恢复语句"><a href="#数据库备份语句与恢复语句" class="headerlink" title="数据库备份语句与恢复语句"></a>数据库备份语句与恢复语句</h3><pre><code class="mysql">-- 数据库备份mysqldump -u [username] -p [database_name] &gt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要备份的数据库名</p><p>[base_path]：存储文件的地点、</p><pre><code class="mysql">-- 数据库恢复mysql -u [username] -p [database_name] &lt; [base_path].sql</code></pre><p>[username]：为数据库登录用户名</p><p>[database_name]：你要恢复的数据库名</p><p>[base_path]：存储文件的地点</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>备份是mysqldump，恢复是mysql</li><li>输入命令后，系统会要求你填写登录密码，如果在 -p 后填入密码会报错</li><li>最后的参数是路径+文件名+.sql后缀，记得查看是否有权限在目标地址写文件</li></ol><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><img src="/2022/09/07/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113332873.png" alt="image-20230227113332873"></p><p>没有报错信息就是最好的信息！</p><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li>输入：mysqldump -u root -p 02-index &gt;  C:\Users\13620\Desktop\02-index.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1045: Access denied for user ‘ODBC‘@’localhost’ (using password: YES) when trying to connect</strong></p><p>问题：没有对应地点的写入权限</p><p>解决：更改写如位置为D:\02-index.sql （有权限的地方都可以）</p><ol start="2"><li>输入：mysqldump -u root -p docker&gt;  C:\Users\13620\Desktop\docket.sql 后显示：</li></ol><p><strong>mysqldump: Got error: 1049: Unknown database ‘docker’ when selecting the database</strong></p><p><img src="/2022/09/07/Mysql%E5%A4%87%E4%BB%BD/Typora_word\后端知识\Mysql备份\image-20230227113618736.png" alt="image-20230227113618736"></p><p>问题：数据库表输入错误</p><p>解决：改对表名</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 单例模式</title>
      <link href="/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-单例模式"><a href="#设计模式-——-单例模式" class="headerlink" title="设计模式 —— 单例模式"></a>设计模式 —— 单例模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>实现</li><li>优缺点</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>单例模式是 <strong>创建型</strong> 设计模式的一种。让一个类只存在一个实例，也就是不允许其他人直接调用类，而是通过方法。</p><p>定义：确保一个类最多只有一个实例，并提供一个全局访问点</p><p>适用场景：例如平时的word文档，同时将一个文件打开两份进行修改会使得其中一份修改无效，所以不可以将一份文件打开为两份，在已经点开文件的同时在点击文件只会跳转到已打开的文件中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre><code class="java">// 需要单例的类有两种实现方法：预加载和懒加载// 预加载public class PreloadSingleton&#123;    public static PreloadSingleton instance = new PreloadSingleton();    // 提前将对象实例化，不允许其他类实例该对象    private PreloadSingleton()&#123;&#125;;        public static PreloadSingleton getInstance()&#123;        return instance;    &#125;&#125;//懒加载public class Singleton &#123;    private static Singleton instance = null;        private Singleton()&#123;&#125;;        // 不在一开始加载对象，减少系统开销，在第一次被调用时创建    public static Singlrton getInstance()&#123;        if(instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>预加载：只有return语句，可以保证线程安全，但是预加载会造成一定的内存浪费</p><p>懒加载：不浪费内存，便无法保证线程安全（if内存执行代码时非原子性的）且new Singleton()也无法保证执行的顺序性（初始化内存空间→初始化对象→设置对象指向内存地址）</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 适配器模式</title>
      <link href="/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-适配器模式"><a href="#设计模式-——-适配器模式" class="headerlink" title="设计模式 —— 适配器模式"></a>设计模式 —— 适配器模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>UML</li><li>实现</li><li>优缺点</li></ul><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>适配器模式是 <strong>结构型</strong> 设计模式的一种。类似于设计一个中间接口，使得两边可以适配使用</p><p>定义：将一个接口转化为客户端所期待的接口，从而使两个接口不兼容的类可以在一起工作</p><p>适用场景：存在现成的类可以使用，但是我们的系统不兼容它提供的接口，且我们无法对其进行修改；多个团队独立开发系统的各个部分，但是先无法确定接口</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML:"></a>UML:</h3><p><img src="/2022/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/blog\source_posts\设计模式_适配器模式\image-20230227173420612.png" alt="image-20230227173420612"></p><ul><li>Target：客户端使用的目标接口<ul><li>operation方法：客户端使用的方法</li></ul></li><li>Adaptee：不兼容的类<ul><li>operation方法：类方法</li></ul></li><li>Adapter：适配器类<ul><li>debug方法：自己设定的，使用于接口转换的方法</li></ul></li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>实现背景：想要调出某学校某宿舍的全部学生信息，但是学校管理系统大更新了依次，现在无法调用以前的查询接口。</p><ol><li>确定目标接口</li></ol><pre><code class="java">// 旧查询接口,输入宿舍楼，宿舍编号返回信息（简单处理就不返回详细信息了）public interface SelectStu&#123;    void selectMessage(int HouseNum,int Num);&#125;</code></pre><ol start="2"><li>第二，三方接口实现</li></ol><pre><code class="java">// 输入宿舍楼名称，宿舍号返回信息public interface NowSelectSys&#123;    void fun(int HouseNum,String HouseName);&#125;// 实现类public class NowSelectSysImpl implements NowSelectSys&#123;    public void fun(int HouseNum,String HouseName)&#123;        System.out.println(&quot;返回了&quot;+HouseNum+HouseName+&quot;宿舍的信息&quot;);    &#125;&#125;</code></pre><ol start="3"><li>构建适配器</li></ol><pre><code class="java">public class SelectAdapter implements SelectStu &#123;    private NowSelectSys nowSelectSys;     // 数字的获取可以是其他程序或者一些方法，目的在将String变为int符合接口    private int HouseNum = 107;        public SelectAdapter(NowSelectSys nowSelectSys)&#123;        this.nowSelectSys = nowSelectSys;    &#125;        public void selectMessage(String HouseName,int HouseNum)&#123;        nowSelectSys.fun(HouseNum,HouseName);    &#125;&#125;</code></pre><ol start="4"><li>客户端调用接口</li></ol><pre><code class="java">SelectAdapterpublic class AdapterClient&#123;    public void SelectStudent()&#123;        SelectStu selectStu = new SelectAdapter(new NowSelectSysImpl);        selectStu.selectMessage(&quot;会泽大楼&quot;，&quot;一楼七号&quot;)    &#125;&#125;</code></pre><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>优点：增强了程序的可扩展性，减少对接口的修改</p><p>缺点：需要多管理一层Adapter</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 -- 责任链模式</title>
      <link href="/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-——-责任链模式"><a href="#设计模式-——-责任链模式" class="headerlink" title="设计模式 —— 责任链模式"></a>设计模式 —— 责任链模式</h1><p><strong>目录</strong></p><ul><li>概述</li><li>UML</li><li>实现</li><li>优缺点</li></ul><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>责任链模式是 <strong>行为型</strong> 设计模式的一种。如其名一般，责任链模式使每个处理器依次连接在一起成为一条链，用户的请求任务顺着这条链传递，直到符合条件的处理器将其处理返回。</p><p>定义：避免请求者和发送者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止</p><p>适用场景：当同一种请求可能被不同对象处理时，使用责任链让请求传递，到达对应对象处理返回</p><h3 id="UML："><a href="#UML：" class="headerlink" title="UML："></a>UML：</h3><p><img src="/2022/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/blog\source_posts\设计模式_责任链模式\image-20230227162446360.png" alt="image-20230227162446360"></p><ul><li>Handler：处理器接口<ul><li>setNextHandler方法：允许设置责任链的下一位，参数为下一位，无返回</li><li>handler方法：处理方法，责任链上的处理器都要符合处理方法（同一参数和返回，防止错误）</li></ul></li><li>ConcreateHandler：处理器，实现处理器接口，有多少个处理器定义多少个类<ul><li>nextHandler方法：设置下一位处理器</li><li>handler方法：处理请求</li></ul></li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>实现背景：员工A希望更新个人项目设备，向公司提出报销请求，数额为15w。每位领导权力不一样，能批付的金额也不一致，假设员工A的项目组长最大能批1w，部门经理批5w，总裁批20w。员工A会和项目组长沟通，但是15w金额超过项目组长的最大批付额，所以项目组长找到部门经理，有因为15w大于5W，部门经理找到总裁，总裁批准了，当然，如果大于20w就返回请求失败。</p><ol><li><strong>设计Handler接口（处理器接口）</strong></li></ol><pre><code class="java">public interface UseHandler &#123;    void setNextHandler(UseHandler nexthandler);    boolean handle(int amount);&#125;</code></pre><p>此处设计依据实际需要开发，返回boolean是因为我只需要直到amount值够不够就好</p><ol start="2"><li><strong>设计各处理器</strong></li></ol><pre><code class="java">// 项目组长public class GroupLeader implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 10_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;项目组长批准&quot;);            return true;        &#125;        System.out.println(&quot;超过我的限额，请求项目经理批准&quot;);        return nextHandler.handler(amount);    &#125;&#125;// 项目经理public class Manager implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 50_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;项目经理批准&quot;);            return true;        &#125;        System.out.println(&quot;超过我的限额，请求更高级批准&quot;);        return nextHandler.handler(amount);    &#125;&#125;// 总裁public class Leader implements UseHandler &#123;    private UseHandler nextHandler;    private int maxMoney = 200_000;        public void setNextHandler(UseHandler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;        public boolean handler(int amount)&#123;        if(amount &lt; maxMoney)&#123;            System.out.println(&quot;总裁批准&quot;);            return true;        &#125;        System.out.println(&quot;太贵了&quot;);        return false;    &#125;&#125;</code></pre><ol start="3"><li><strong>客户端连接各处理器，处理请求</strong></li></ol><pre><code class="java">public class processor &#123;    public void Use()&#123;        GroupLeader groupleader = new GroupLeader();        Manager manager = new Manager();        Leader leader = new Leader();                leader.setNextHandler(manager);        manager.setNextHander(groupleader);                System.out.println(&quot;我这有20w需要报销&quot;);        if(groupleader.handler(150_000))&#123;            System.out.println(&quot;谢谢领导&quot;);        &#125;else&#123;            System.out.println(&quot;无法报销，我知道了&quot;);        &#125;    &#125;&#125;</code></pre><p><strong>输出：</strong></p><p>我这有20w需要报销</p><p>超过我的限额，请求项目经理批准</p><p>超过我的限额，请求更高级批准</p><p>总裁批准</p><p>谢谢领导</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>优点：命令发出者和执行者解耦，单条命令可以让多个处理器处理，针对不同问题能区别处理</p><p>缺点：需要管理的类增多了，如果处理不合理可能形成环导致请求无法完成</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql连接本地数据库的问题</title>
      <link href="/2022/09/05/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/05/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql连接本地数据库时报网络问题"><a href="#MySql连接本地数据库时报网络问题" class="headerlink" title="MySql连接本地数据库时报网络问题"></a>MySql连接本地数据库时报网络问题</h1><p>今早起床学习大佬面经时，发现自己数据库都登不上去了<img src="/2022/09/05/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\63aae1ca1cac76b665567fb840a6da6.png" alt="63aae1ca1cac76b665567fb840a6da6"></p><p>不论是命令行还是Navicat登录都是报以上错误，可我这是个本地的数据库，不应该存在网络错误呀。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>经过大佬的指点，重启服务中的Mysql，数据库的访问就正常了<img src="/2022/09/05/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\image-20221130103336695.png" alt="image-20221130103336695"></p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>尽管问题很快被解决，但是我依然想不通为什么会报这种错误，认识到自己的不足，也就有了下面的学习，鉴于以往没有过这种错误，无从下手，我决定先翻译这段报错：</p><p><strong>‘‘读取初始通信数据包时失去与MySQL服务器的连接，系统错误: 0”</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http状态码</title>
      <link href="/2022/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2022/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>HTTP（超文本传输协议）常见状态码有以下几种：</p><ul><li>1XX （信息类状态码）：请求已经收到，进行后续处理</li><li>2XX （成功状态码）<ul><li>200 成功：请求已经被成功实现</li><li>201 Created：请求已经被实现，且现有一个新的资源已经依据请求的需要而建立</li><li>204 No Content：服务器成功处理了请求，但是没有返回任何实体内容</li></ul></li><li>3XX （重定向状态码）：需要镜像附加操作以完成请求<ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客户端发送了一个带条件的请求，服务器允许请求访问资源，但是请求的条件不满足</li></ul></li><li>4XX （客户端错误状态码）：请求包含错误语法或不能被执行<ul><li>400 Bad Request：请求报文存在错误语法</li><li>401 Unauthorized：表示发送的请求需要通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在</li></ul></li><li>5XX （服务器错误状态码）：服务器处理请求的过程中发生了错误<ul><li>500 Internal Server Error：服务器遇到了一个未曾预料到的状况，导致无法完成请求的处理</li><li>502 Bad Gateway：充当网关的服务器，从远处服务器收到了一个无效请求</li><li>503 Service Unavaliable：服务器暂时处于超负荷或停机状态，无法处理请求</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap常见问题</title>
      <link href="/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Hashmap是否线程安全？为什么？"><a href="#Hashmap是否线程安全？为什么？" class="headerlink" title="Hashmap是否线程安全？为什么？"></a>Hashmap是否线程安全？为什么？</h3><p>不安全，JDK7存在死循环和数据丢失问题。</p><p><strong>数据丢失</strong>：</p><ol><li><strong>并发赋值被覆盖</strong>：在createEntry方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖</li><li><strong>已遍历区间新增元素丢失</strong>：当某个线程在transfer方法迁移时，其他线程新增的元素可能以及落在已经遍历过的哈希槽上。遍历完成后，table数组引用指向了newTable，新增元素丢失</li><li><strong>新表被覆盖</strong>：如果resize完成，执行了table &#x3D; newTable，则后续元素就可以在新表上进行插入。但如果多线程同时resize，每个线程都会new一个数组，这是线程内的局部对象，线程之间不可见。迁移后resize的线程会赋值给table线程共享变量，可能会覆盖其他线程操作，在新表中插入的对象都会被丢弃。</li></ol><p><strong>死循环</strong>：</p><p>扩容时resize调用transfer使用头插法迁移元素，虽然newTable是局部变量，但原先的table中Entry链表是共享的，问题根源是Entry的next指针并发修改，某线程还没有将table设为newTable时用完了CPU时间片，导致数据丢失或死循环。</p><p>JDK8在resize方法中完成了扩容，并改为尾插法，不会产生死循环，但并发下仍可能丢失数据。可用ConcurrentHashMap 或 Collections.synchronizedMap包装成同步集合。</p><h3 id="JDK7与JDK8的hashmap有什么区别："><a href="#JDK7与JDK8的hashmap有什么区别：" class="headerlink" title="JDK7与JDK8的hashmap有什么区别："></a>JDK7与JDK8的hashmap有什么区别：</h3><p>JDK7是数组 + 链表，JDK8是数组 + 链表&#x2F;红黑树</p><ol><li><strong>链表插入方式不同</strong>：1.7之前，链表元素插入采用头插法，每当有新节点进入时，会插入在链表头部，由于不用遍历链表，这种插入方式效率高；1.8以后当节点插入时，因为需要判断元素个数而遍历链表（是否达到转为树的阈值），所以顺带改为尾插，即插到链表尾部，这解决了多线程下可能引发的死锁问题，因为头插法的链表在扩容移动时，会被逆序，即后插入的先处理，如果这时候有另一线程进行get操作，就可能引发死锁</li><li><strong>插入时机不同</strong>：1.7之前是扩容后再插入新的数据，并且不会先计算值的哈希值，最后单独计算；1.8之后是先插入再扩容，插入值和大家一起计算新的哈希值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get使用</title>
      <link href="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/"/>
      <url>/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/</url>
      
        <content type="html"><![CDATA[<p>原链接：<a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">视频同步笔记：狂神聊Git (qq.com)</a></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>在开发过程中用于管理我们的文件，目录或工程等内容的修改历史，方便查看历史记录，备份以便回复以前的版本的软件工程技术</p><ul><li>实现跨域多人协同开发</li><li>追踪和记载一个或多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量‘</li><li>并行开发，提高工作效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说；一种管理多人协同开发项目的技术</p><blockquote><p>常见版本控制工具：</p><p>GitSVNCVSVSSTFS</p></blockquote><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><blockquote><p>安装：</p></blockquote><p>进入官网，下载git（windows 64-bit.exe）&#x2F;  使用镜像下载 , 无脑下一步（<a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a>）</p><p>注：环境变量只是为了全局使用而已，不是必需品</p><blockquote><p>卸载：</p></blockquote><p>环境变量中删除Git , 再去卸载中心卸载程序</p><blockquote><p>使用：</p></blockquote><p>安装成功后，右键任意文件夹都会出现Git Bash（Unix与Linux风格命令行）和Git CMD（Windows风格命令行）</p><h3 id="Linux简单口令"><a href="#Linux简单口令" class="headerlink" title="Linux简单口令"></a>Linux简单口令</h3><pre><code class="Linux">cd改变目录cd..退回到上一级目录,直接cd进入默认目录pwd显示当前所在路径ls(||)ls和ls||都是列出当前目录中的所有文件,只不过后者列出的内容更为详细touch新建一个文件夹,如：touch index.js就会在当前目录下新建一个index.js文件rm删除一个文件,rm index.js就会删除index.js文件mkdir新建一个目录,就是新建一个文件夹rm -r 删除一个文件夹,rm -r src就是删除src文件夹mv移动文件,如mv index.html src 那么index.html就是移动的文件，src为目标文件夹（两者在同一目录下）reset重新初始化终端/清屏clear清理屏幕history查看历史命令exit退出#注释</code></pre><h5 id="Git配置：-所有的配置文件，其实都保存在本地"><a href="#Git配置：-所有的配置文件，其实都保存在本地" class="headerlink" title="Git配置：(所有的配置文件，其实都保存在本地)"></a>Git配置：(所有的配置文件，其实都保存在本地)</h5><h6 id="查看配置：git-config-l"><a href="#查看配置：git-config-l" class="headerlink" title="查看配置：git config -l"></a>查看配置：git config -l</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231706647.png" alt="image-20220603231706647"></p><h6 id="查看系统配置：git-config-–system-–list"><a href="#查看系统配置：git-config-–system-–list" class="headerlink" title="查看系统配置：git config –system –list"></a>查看系统配置：git config –system –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231858917.png" alt="image-20220603231858917"></p><h6 id="查看全局配置：git-config-–global-–list"><a href="#查看全局配置：git-config-–global-–list" class="headerlink" title="查看全局配置：git config –global –list"></a>查看全局配置：git config –global –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231922188.png" alt="image-20220603231922188"></p><pre><code class="linux">git config --global user.name &quot;设置名字&quot;git config --global user.email 邮箱地址</code></pre><h4 id="Git相关配置文件："><a href="#Git相关配置文件：" class="headerlink" title="Git相关配置文件："></a>Git相关配置文件：</h4><p>1)，Git&#x2F;etc&#x2F;gitconfig：Git安装目录下的gitconfig–system系统配置</p><p>2)，C:&#x2F;User&#x2F;Administrator（当前用户）&#x2F;.gitconfig：只适用于当前登录用户的配置–global全局配置</p><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）,暂存区（Stage&#x2F;Index）,资源库（Repository&#x2F;Git Directory）加上远程Git仓库（Remote Directory）</p><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604102832395.png" alt="image-20220604102832395"></p><ul><li>Workspace：工作区，就是平时存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放改动，实际上只是一个文件，保存了即将提交到文件列表的信息</li><li>Repository：仓库区（本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器（一般用github或者gitee）</li></ul><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604103432739.png" alt="image-20220604103432739"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>在工作目录添加,修改文件;</li><li>将需要的进行版本管理的文件放入暂存仓库</li><li>将暂存区文件提交到git仓库</li></ol><p>所以,git管理的文件有三种状态:已修改（modified），已暂存（staged），已提交（committed）</p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h3 id="仓库搭建"><a href="#仓库搭建" class="headerlink" title="仓库搭建"></a>仓库搭建</h3><p>创建本地仓库方法有两种：创建全新的仓库，克隆远程仓库</p><h5 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h5><pre><code class="git"># 在当前目录下新建一个Git代码库$ git init</code></pre><p>执行后在项目文件夹会多出一个.git的隐藏目录，关于版本等信息都在目录中</p><h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><pre><code class="git"># 克隆一个项目和它的全部代码历史（版本信息）$ git clone [url]</code></pre><p>前往gitee &#x2F; github上测试；</p><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<strong>git add</strong> 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用    <strong>git rm</strong>移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<strong>git checkout</strong> 则丢弃修改过, 返回到unmodify状态, 这个<strong>git checkout</strong>即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行<strong>git commit</strong>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行<strong>git reset HEAD filename</strong>取消暂存, 文件状态为Modified</li></ul><pre><code class="git"># 查看全部文件状态git status# 查看指定文件状态git status [filename]# 添加全部文件到暂存区git add .# 将暂存区内容提交至本地 -m为提交时编写备注git commit -m&quot;消息内容&quot;</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在项目文件夹中，并非所有数据都要我们上传和提交，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore“文件，此文件有以下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><pre><code class="git"># 为注解*.txt# 忽略所有.txt结尾的文件，上传的总文件中不会包含这些文件!lib.txt    # 但是lib.txt文件除外/temp# 仅忽略build/目录下的所有文件build/# 忽略bulid/目录下的所有文件doc/*.txt# 忽略doc/notes.txt等文件,单不包括doc/server/arch.txt</code></pre><h3 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h3><pre><code class=".gitignore">*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### IntelliJ IDEA ###*.iml*.ipr*.iws.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml*</code></pre><h1 id="使用码云（Gitee）"><a href="#使用码云（Gitee）" class="headerlink" title="使用码云（Gitee）"></a>使用码云（Gitee）</h1><p>设置本机SSH公钥，实现免密码登录！</p><pre><code class="git"># 进入C:/user/Administraror/.ssh 目录# (右键进入git命令行)生产公钥ssh-keygen</code></pre><p>将生产的id_rsa.pub文件中的信息复制，在码云<strong>安全设置</strong>的<strong>SSH公钥</strong>中粘贴即可</p><p>接下来就是创建仓库去使用了！</p><h1 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h1><p>1.新建项目，绑定git</p><ul><li>直接将远程的git文件拷贝到项目中（在别处get clone [url]，将产生的文件夹剪切）</li></ul><p>2.修改文件，提交文件</p><ul><li>左下角有<strong>Version Control</strong>显示版本信息，右上角有快捷图标</li></ul><h1 id="Git分支说明"><a href="#Git分支说明" class="headerlink" title="Git分支说明"></a>Git分支说明</h1><p>git分支中常见指令：</p><pre><code class="git"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支吧git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h1 id="Git后续操作"><a href="#Git后续操作" class="headerlink" title="Git后续操作"></a>Git后续操作</h1><blockquote><p>gitee官网中有命令大全和操作指南</p></blockquote><blockquote><p>团队很重要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层原理</title>
      <link href="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇知识梳理参考了B站up : <a href="https://space.bilibili.com/439213321">黑马程序员上海中心</a> 的视频 : <a href="https://www.bilibili.com/video/BV1FE411t7M7?share_source=copy_web&vd_source=9b42e96f6cc201a1ee177f1b86bb0b77">HashMap集合介绍+面试题讲解</a></p></blockquote><h1 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h1><ul><li>hashMap集合介绍</li><li>HashMap集合底层数据结构</li><li>hashMap继承关系</li><li>hashMap集合类成员</li><li>如何设计多个非重复的键值对要存储HashMap的初始化</li></ul><h3 id="HashMap集合介绍"><a href="#HashMap集合介绍" class="headerlink" title="HashMap集合介绍"></a>HashMap集合介绍</h3><p><img src="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20220814101149681.png" alt="image-20220814101149681"></p><p><img src="https://img-blog.csdnimg.cn/20200628084624157.png#pic_center" alt="HashMap"></p>]]></content>
      
      
      <categories>
          
          <category> 代码底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http分析</title>
      <link href="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/252370220">图灵诸葛官方号</a>) 课程 <a href="https://www.bilibili.com/video/BV1V54y1y7c4?spm_id_from=333.337.search-card.all.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">程序员入门必备教程—HTTP协议详解</a>)</p></blockquote><ul><li>HTTP分层请求</li><li>HTTP协议</li><li>HTTP请求过程</li><li>TCP协议</li><li>HTTPS协议</li></ul><h1 id="Http分层"><a href="#Http分层" class="headerlink" title="Http分层:"></a>Http分层:</h1><p>网络需要完成的任务：防止数据丢包，避免数据重复，数据完整性校验，数字转模拟信号，…，信号衰减</p><p>为了完成不同层面的各个任务，简化网络的复杂度，网络通信被分解为多层次结构，每一层都紧挨着上层或下层进行交互，这样在修改甚至替换某一层的软件时，只需要层与层之间的接口保持不变，就不会影响其他层。</p><ul><li>OSI七层网络模型</li><li>TCP&#x2F;IP协议簇</li></ul><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819105355252.png" alt="image-20220819105355252"></p><h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><p>超文本传输协议（HyperText Transfer Protocol , HTTP）</p><p>一种无状态，以请求、应答方式运行的协议。它使用可扩展语义和子描述消息格式，与基于网络的草文本消息系统可以灵活互动</p><h5 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h5><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）:描述请求或响应的基本信息</li><li>头部字段集合（header）:使用key-value形式更详细的说明报文</li><li>空行</li><li>消息正文（entity）:实际传输的数据，不一定是文本，可以是图片，视频等二进制数据</li></ul><h5 id="请求行报文格式："><a href="#请求行报文格式：" class="headerlink" title="请求行报文格式："></a>请求行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110831735.png" alt="image-20220819110831735"></p><ul><li>请求方法（METHOD）：如 GET &#x2F; HEAD &#x2F; PUT &#x2F; POST，表示对资源的操作</li><li>请求目标 ：通常是一个URL，标记了请求方法要操作的资源</li><li>版本号：表示报文使用的HTTP协议版本</li></ul><h5 id="响应行报文格式："><a href="#响应行报文格式：" class="headerlink" title="响应行报文格式："></a>响应行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110855815.png" alt="image-20220819110855815"></p><ul><li>版本号 ：表示报文使用的HTTP协议版本</li><li>状态码（STATUS CODE）: 一个三位数，用代码的形式表示处理结果，比如200是成功，403是客户端访问被拒，500是服务器错误</li><li>原因（READON）：作为数字状态码补充，是更加详细的解释文字，协助理解原因</li></ul><h5 id="HTTP头字段："><a href="#HTTP头字段：" class="headerlink" title="HTTP头字段："></a>HTTP头字段：</h5><p>头部字段是key-value形式，key和value间使用 “  ：”做分隔，比如前后端分离时常遇到的要与后端协商传输数据类型 “ <strong>Content-type:application&#x2F;json</strong> ” ，最后用CRLF换行表示字段结束，HTTP头字段的使用比较灵活，不仅可以用Host,Connection等已有头字段，也可以任意添加自定义头，这就给HTTP协议带来了无限扩展可能。 </p><p><strong>注意事项</strong></p><ul><li>字段名称不区分大小写，但不允许出现空格和下划线“_”,可以使用连字符“-”，字段后必须紧跟“:”，中间不许有空格，但“:”后允许多个空格</li><li>字段顺序没有意义，任意排列不影响语序</li><li>字段原则上不允许重复，除非字段本身允许：Set-Cookie</li></ul><h5 id="常用头字段："><a href="#常用头字段：" class="headerlink" title="常用头字段："></a>常用头字段：</h5><p>HTTP协议有很多头字段，基本可以分为四大类：</p><ul><li>请求字段：请求头中的头字段：如Host，Referer</li><li>响应字段：响应头中的头字段：如Server，Date</li><li>通用字段：在响应头和请求头都可以出现的：Content-type，Connection</li></ul><h1 id="HTTP请求过程："><a href="#HTTP请求过程：" class="headerlink" title="HTTP请求过程："></a>HTTP请求过程：</h1><p>当用户在浏览器中输入网址后，网络协议都做了哪些工作？</p><ol><li>首先依据浏览器应用程序，解析出URL中的域名</li><li>依据域名获得的ip地址，首先从浏览器缓存中查看，没有就去本机域名解析文件hosts中查看，LDNS，Rootserver，国际定级域名服务商层层解析，直至找到</li><li>拿到ip地址后，浏览器发起对服务器的三次握手</li><li>握手建立连接后，开始组装http请求，发送报文</li><li>服务器收到请求报文后，开始请求报文解析，生成响应数据，发送响应数据</li><li>浏览器收到响应后，开始渲染页面</li></ol><blockquote><p> chrome:&#x2F;&#x2F;net-internals&#x2F;#events             查看浏览器缓存ip地址</p></blockquote><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819120503128.png" alt="image-20220819120503128"></p><h1 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h1><p>TCP协议是面向连接的，可靠的，基于字节流的传输层协议</p><h4 id="TCP属性："><a href="#TCP属性：" class="headerlink" title="TCP属性："></a>TCP属性：</h4><ul><li>基于连接：数据传输之间需要建立连接</li><li>全双工：双向传输</li><li>字节流：不限制数据大小，打包成为报文段，保证有序接收，重复报文自动丢弃</li><li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性</li><li>拥塞控制：防止网络出现恶性拥塞</li></ul><h4 id="TCP报文："><a href="#TCP报文：" class="headerlink" title="TCP报文："></a>TCP报文：</h4><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821101526541.png" alt="image-20220821101526541"></p><p>Source port：源端口Dest port：目的端口</p><p>Seq：请求数   ACK：应答数</p><p>Header length：首部长度Unused：保留字段</p><p>Receive window：当前可接收值 Urgent data：紧急报文指针</p><p>Options：可选参数   Data：数据</p><h4 id="TCP连接管理："><a href="#TCP连接管理：" class="headerlink" title="TCP连接管理："></a>TCP连接管理：</h4><p>TCP连接：四元组【源地址，源端口，目的地址，目的端口】</p><p>确认连接：三次握手</p><p>​a.同步通信双方的初始序列号（ISN）</p><p>​b.协商TCP通信参数（MSS，窗口信息，指定校验和算法）</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102017022.png" alt="image-20220821102017022"></p><p>内核操作：</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102108877.png" alt="image-20220821102108877"></p><p>关闭连接：四次挥手</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102157493.png" alt="image-20220821102157493"></p><h4 id="字节流协议："><a href="#字节流协议：" class="headerlink" title="字节流协议："></a>字节流协议：</h4><p>MSS：Max Segment Size：默认536byte实际数据</p><p>TCP会依据Seq报文序列号进行排序，使得文件被划分为小信息发送时不会乱序</p><h4 id="可靠性-x2F-重传机制："><a href="#可靠性-x2F-重传机制：" class="headerlink" title="可靠性&#x2F;重传机制："></a>可靠性&#x2F;重传机制：</h4><h5 id="1-ack丢失："><a href="#1-ack丢失：" class="headerlink" title="1.ack丢失："></a>1.ack丢失：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102424659.png" alt="image-20220821102424659"></p><h5 id="2-请求报文丢失"><a href="#2-请求报文丢失" class="headerlink" title="2.请求报文丢失"></a>2.请求报文丢失</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102536666.png" alt="image-20220821102536666"></p><h5 id="3-滑动窗口协议："><a href="#3-滑动窗口协议：" class="headerlink" title="3.滑动窗口协议："></a>3.滑动窗口协议：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102644054.png" alt="image-20220821102644054"></p><p>每次发送一组报文，并确定最后的报文是否收到回信，如果收到，表示报文全部被接收，直接跳至下一组，不必有重复</p><p>如果没有收到最后的报文，则往前推，直至从收到回信的部分（如图，3，5没有回信只收到12的回信，则12确认发送成功，不论4是否成功，3，4，5都和后面数据一起发送）</p><h1 id="HTTPS协议："><a href="#HTTPS协议：" class="headerlink" title="HTTPS协议："></a>HTTPS协议：</h1><p>HTTP具有”明文“特点，整个传输过程完全透明，任何人都可以在链路中截获、修改和伪造，数据具有不可信性</p><p>使用HTTPS，所有HTTP请求都会在请求和响应之前进行加密</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821103501204.png" alt="image-20220821103501204"></p><h3 id="SSL-x2F-TSL："><a href="#SSL-x2F-TSL：" class="headerlink" title="SSL&#x2F;TSL："></a>SSL&#x2F;TSL：</h3><p>SSL即安全套接层，由网景公司于1994年发明，IETF在1999年将其改名为TLS传输层安全，三个主流版本为2006的1.1，2008的1.2，2018的1.3，每个版本都紧跟密码学的发展和互联网现状，持续强化安全和性能，已经成为信息安全领域的权威标准</p><h3 id="摘要算法："><a href="#摘要算法：" class="headerlink" title="摘要算法："></a>摘要算法：</h3><p>将任意长度的数据”压缩“为固定长度，且独一无二的”摘要“字符，可以将其与明文一起发送，接收端解压字符后可以对比查看明文是否被篡改</p><p>如：md5</p><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><h5 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h5><p>编码使用相同的密钥进行加密解密（AES，RC4,ChaCha20）</p><h5 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h5><p>有两个密钥，一个”公钥“，一个”私钥“。前者可以给任何人使用，随意分发。后者需要保密，网站秘密保存</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/blog\source_posts\剖析Http请求\image-20220821104242155.png" alt="image-20220821104242155"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6补充</title>
      <link href="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>事物，锁机制</li><li>事物冲突问题</li><li>redis事物三特性</li><li>持久化框架</li><li>Redis主从复制</li><li>Redis集群</li><li>Redis应用问题解决</li></ul><h3 id="事物，锁机制："><a href="#事物，锁机制：" class="headerlink" title="事物，锁机制："></a>事物，锁机制：</h3><p>Redis事物：一个单独的隔离操作；事物中所有命令都会序列化，按顺序执行。事物执行过程中不会被其他客户端发送过来的命令请求打断</p><p>Redis事物主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p><h4 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi | Exec | discard"></a>Multi | Exec | discard</h4><p>输入Multi开启事务，此时被成为组队阶段，<strong>输入的命令不会马上执行</strong>，而是<strong>依次进入命令队列</strong>，直到输入Exec后，将命令队列中命令依次执行，组队过程中可以通过discard来放弃组队</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817101242222.png" alt="image-20220817101242222"></p><h4 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h4><ol><li>组队时命令发生错误，事物无法执行Exec后的命令语句，<strong>一个都不执行</strong></li><li>组队时无误，执行时出现部分错误，<strong>错误的不执行，其他的执行</strong></li></ol><h4 id="为什么需要做成事物："><a href="#为什么需要做成事物：" class="headerlink" title="为什么需要做成事物："></a>为什么需要做成事物：</h4><p>同一份数据被多处调用时，可能会使得值变得不合理，例如多人登录同一台TB账户购买东西，余额同时读取后再依次修改是不合理的</p><h3 id="事务冲突问题："><a href="#事务冲突问题：" class="headerlink" title="事务冲突问题："></a>事务冲突问题：</h3><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h4><p>每次拿数据时都认为别人会修改，所以每次拿取数据时就上锁，其他人拿数据时就会black（阻塞）直至开锁，<strong>牺牲性能换效果</strong></p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p><strong>添加版本信息</strong>，仅在修改信息时匹配版本是否一致，一致则成功修改，否则更新数据再执行</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817103825221.png" alt="image-20220817103825221"></p><h4 id="WATCH-K"><a href="#WATCH-K" class="headerlink" title="WATCH  K:"></a>WATCH  K:</h4><p>在执行multi之前，<strong>先执行watch k监视一个或多个key值</strong>，如果在事物执行之前这个key被改动，那么事务将会被打断</p><h3 id="Redis事务的三特性："><a href="#Redis事务的三特性：" class="headerlink" title="Redis事务的三特性："></a>Redis事务的三特性：</h3><ul><li>单独的隔离操作：事务中所有命令都会序列化，按顺序执行。事务在执行过程中不会被其他客户端发送的命令请求打断</li><li>没有隔离级别概念：队列中的命令没有提交之前都不会实际执行，因为事务提交前任何指令都不会执行</li><li>不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6基础</title>
      <link href="/2022/08/15/Redis_6/"/>
      <url>/2022/08/15/Redis_6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>NoSQl概述</li><li>行式&#x2F;列式数据库（大数据时代）</li><li>key键操作</li><li>5种基本数据类型</li><li>配置文件</li><li>发布与订阅</li><li>3种新数据类型</li></ul><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p><strong>基于K-V的高性能NoSQl数据库，提供了各种数据结构存储，具有高性能的多线功能</strong>，支持String（字符串） , list（链表） , set （集合）, zset（sorted set：有序集合） 和 hash（哈希类型）</p><p>Redis支持各种方式的<strong>排序</strong>，为了保证效率，<strong>数据都是存储在缓存中的</strong>，但Redis会<strong>周期性</strong>把更新的数据写入磁盘，在此基础上<strong>实现了master-slave（主从）同步</strong></p><p>Redis是 <strong>单线程 + 多路复用IO</strong> 技术；使用 <strong>6379端口</strong></p><h3 id="NoSql-数据库"><a href="#NoSql-数据库" class="headerlink" title="NoSql 数据库"></a>NoSql 数据库</h3><p>NoSQL （Not Only SQL）：意为“不仅仅是SQL”，泛指<strong>非关系型数据库</strong></p><p>NoSQL 不依赖业务逻辑存储方式，而是以简单的<strong>key-value</strong>模式存储，因此增加了数据库的扩展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><p>适用场景：</p><ul><li>对数据高并发读写</li><li>海量数据的读写</li><li>对数据高可扩展性</li></ul><p>不适用场景</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储</li></ul><p><strong>总之：用不着sql和用了sql也不行的情况，考虑Nosql</strong></p><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><p><img src="/2022/08/15/Redis_6/image-20220816091921656.png" alt="image-20220816091921656"></p><h3 id="列式数据库："><a href="#列式数据库：" class="headerlink" title="列式数据库："></a>列式数据库：</h3><p><img src="/2022/08/15/Redis_6/image-20220816092128015.png" alt="image-20220816092128015"></p><h3 id="Key键操作"><a href="#Key键操作" class="headerlink" title="Key键操作"></a>Key键操作</h3><pre><code class="redis">keys *//查看全部keyexists K//查找key是否存在，返回1：存在；返回0：不存在type K//查看key是什么类型del K//删除对应K-V,返回1：成功unlink K//非阻塞删除对应K-Vexpire K int//为给定的K设置过期时间ttl K//查看还有多久数据过期（取不到）返回-1:永不过期,返回-2：已经过期select int//切换库dbsize//查看当前数据库的key数量flushdb//清空当前库flushall//通杀全部库</code></pre><h3 id="5种基本数据类型："><a href="#5种基本数据类型：" class="headerlink" title="5种基本数据类型："></a>5种基本数据类型：</h3><ul><li>String（字符串）</li><li>List（链表）</li><li>Set（集合）</li><li>Hash（哈希）</li><li>Zset（有序集合）</li></ul><h4 id="String（字符串）："><a href="#String（字符串）：" class="headerlink" title="String（字符串）："></a>String（字符串）：</h4><p>string是 <strong>二进制安全</strong> 的,意味着Redis的string可以包含任何数据，包括jpg图片或者序列化对象。</p><p>string是Redis中最基本的数据类型，一个·Redis中的value最多可以是 <strong>512M</strong></p><p>string底层数据结构就是<strong>简单的动态字符串</strong>，结构上类似Java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配</p><p>在字符串长度小于1M时，扩容为每次扩大一倍，大于1M时，每次扩容1M</p><p><strong>常见命令</strong></p><pre><code class="redis">set K V//设置键值对/覆盖已有的K-V键值对get K//取出K对应的Vappend K V//在原有K对应的V`后添加Vstrlen K//获取K对应V的长度setnx K V//设置键值对，如果已有K，返回0：设置失败，否则返回1：设置成功mset K1 V1 K2 V2..//设置一个或多个键值对mget K1 k2..//取出一个或多个V值getrange K int1 int2//获取K对应V的int1-int2部分内容：从0开始setrange K int V//将K对应V的int之后部分添加V再接原字符setex K int V//设置K-V同时设置过期时间getset K V //获取旧值，同时将新值写入// 原子操作*incr K//将K对应V值+1；如果V不是数字类型返回0，否则返回+1后的值decr K//将K对应V值-1；...否则返回-1的值incrby K int//将K对应V值+int;...decrby K int//...-int...msetnx K1 V1 K2 V2//同时设置多个K-V,当且仅当key都不存在</code></pre><h6 id="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"><a href="#原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）" class="headerlink" title="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"></a>原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）</h6><p>注：java中的i++并非是原子操作</p><p>![image-20220816101653161](.&#x2F;Redis 6&#x2F;image-20220816101653161.png)</p><h4 id="List（链表）："><a href="#List（链表）：" class="headerlink" title="List（链表）："></a>List（链表）：</h4><p><strong>单键多值</strong> ，即一个K对应多个V。底层实现是 <strong>双向链表</strong> ，数据结构为 <strong>快速链表</strong>（quickList）即在列表元素较少时使用的结构式ziplist（压缩列表），它将所有元素挨在一起存储，分配一块连续的内存。当数据量较大时才会改为quicklist</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><pre><code class="redis">lpush K V1 V2...//从左边(头节点)加入一个或多个值rpush K V1 V2... //从右边(尾节点)加入一个或多个值lrange K int1 int2  //从左边取出int1-int2的数据(顺序)：0是第一个，-1是最后一个lpop K //从左边吐出一个值,值在键在，值光键亡rpop K //从右边吐出一个值,...rpoplpush K1 K2//从K1右边取出值加到K2左边lindex K int //按照索引下标获得元素llen K//获得列表长度linsert K before V1 V2 //在V1前添加一个V2linsert K after V1 V2 //在V1后添加一个V2lrem K int V//从左边删除int个Vlset K int V//将列表K下标为int的值替换为V</code></pre><h4 id="Set（集合）："><a href="#Set（集合）：" class="headerlink" title="Set（集合）："></a>Set（集合）：</h4><p>set可以 <strong>自动排重</strong> ，且提供了<strong>判断某个成员是否在一个set集合</strong>的接口。</p><p>Redis的set是String类型的<strong>无序集合</strong>，底层是一个<strong>value为null的hash表</strong>，所以添加，删除，查找复杂度都是O(1)</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">sadd K V1 V2...//将一个或多个members元素添加至key中，已存在的会被忽略smembers K//取出该集合的所有值sismember K V//判断K集合中是否右V值，有返回1，否则返回0scard K//返回集合元素个数srem K V1 V2//删除集合中的一个或多个元素spop K//随机从集合中取出一个值，值完键亡srandmemberK int//随机取出int个值，不会在集合中删除smove K1 K2 V1 V2...//将K1中元素V1，v2..移动到K2中，返回移动元素个数sinter K1 K2//返回两个集合的交集元素sunion K1 K2//返回两个集合的并集元素sdiff K1 K2//返回两个集合的差集元素（在K1而不在K2）</code></pre><h4 id="Hash（哈希）："><a href="#Hash（哈希）：" class="headerlink" title="Hash（哈希）："></a>Hash（哈希）：</h4><p>Redis Hash是一个<strong>键值对集合</strong>，其value对应一个<strong>String类型的field</strong>和value映射表，适合用于存储对象，类似Java中的Map&lt;String, Object&gt;</p><p>![image-20220816150802600](.&#x2F;Redis 6&#x2F;image-20220816150802600.png)</p><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">hset K field value//在K中添加一个field-value对hget K field//返回K中field对应的值hmset K f1 v1 f2 v2//在K中批量设置field-value对hexists K field//查看中是否存在fieldhkeys K//列出K集合中全部的fieldhvals K//列出K集合中全部的valuehincrby K field int //给K中的field对应value值hsetnx K field value//为K添加field-value对，如果field原本存在则不会添加</code></pre><h4 id="Zset（有序集合）："><a href="#Zset（有序集合）：" class="headerlink" title="Zset（有序集合）："></a>Zset（有序集合）：</h4><p>Zset与set相同，是 <strong>没有重复元素</strong> 的字符串集合。不同之处是Zset每个成员都关联了一个<strong>评分（score）</strong>,score用于按照从低到高的方式对集合成员进行排序。</p><p><strong>集合成员是唯一的，但评分可以重复</strong></p><h5 id="常用命令：-1"><a href="#常用命令：-1" class="headerlink" title="常用命令："></a><strong>常用命令：</strong></h5><pre><code class="redis">zadd K score1 v1 s2 v2//添加一个或多个评分-值zrange K int1 int2 //返回排序从int1到int2的值zrange K int1 int2 withscores //返回排序从int1到int2的值，同时返回评分zrangebyscore K int1 int2//返回score在int1至int2中间的值，可以加withscoreszrevrangebyscore K int1 int2//逆序返回score在int1至int2中间的值，可以加with...zincrby K int V//给K中V的score增加intzrem K V//删除指定值zcount K int1 int2//统计集合中在int1-int2中的元素个数zrank K V//返回该值在集合中的排名，从0开始</code></pre><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>配置文件：redis.conf</p><blockquote><p>vi &#x2F;etc&#x2F;redis.conf</p></blockquote><pre><code class="redis">bind 127.0.0.1#限制仅本地连接protected-mode yes#仅本地访问，改为no即可允许非本地访问port:6379#端口tcp-backlog 511#目前已经完成三次握手以及正在三次握手的队列timeout0#超时时限，设为0则永不超时tcp-keepalive 300#心跳监测连接，每隔300s检查一次daemonize yes#允许后台启动pidfile...#保存进程号的位子loglevel notice#log保护级别：debug&gt;verbose&gt;notice&gt;warninglogfile &quot;&quot;#日志输出路径，默认为空database 16#redis默认16个数据库，用户默认使用0号库#密码requirepass与客户端LIMITSmaxmemory 10000#最大内存maxmemory-sample 5#样本数量maxclients 10000#最大连接数#持久化设置</code></pre><h3 id="发布与订阅："><a href="#发布与订阅：" class="headerlink" title="发布与订阅："></a>发布与订阅：</h3><pre><code class="redis"># /usr/local/bin/redis-cliSUBSCRIBE channel1#订阅channel1频道publicsh  channels hello#使channel1发布消息“hello”</code></pre><p>一种消息的沟通模式：<strong>频道收到消息后，所有订阅的对象都会收到对应消息</strong></p><h3 id="3种新数据类型："><a href="#3种新数据类型：" class="headerlink" title="3种新数据类型："></a>3种新数据类型：</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps:"></a>Bitmaps:</h4><p>BitMaps本身就是字符串Key-Value，但是可以对字符串进行位运算，可以把Bitmaps想象为一个以位为单位的数组，数组只能存储0和1，数组下标在BotMaps中被成为偏移量，最左边为0.</p><h5 id="常用命令：-2"><a href="#常用命令：-2" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">setbit K int1 int2#对K中int1号位子上改为int2（0/1）getbit K int#获取K中偏移量int中的值bitcount K#统计K中被设为1的数量bitcount K int1 int2 #统计K中int1到int2之间1的数量bitop and K1 K2#对K1，K2中为1的偏移量取与集，返回统计值bitop or K1 K2#对K1，K2中为1的偏移量取并集，...bitop not K1 K2#对K1，K2中为1的偏移量取差集，...bitop xor K1 K2#对K1，K2中为1的偏移量取异或，...</code></pre><p>![image-20220817090407369](.&#x2F;Redis 6&#x2F;image-20220817090407369.png)</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog:"></a>HyperLogLog:</h4><p>HyperLogLog只会根据输入元素计算*<strong>基数</strong>，不会存储输入元素本身</p><p><strong>基数</strong>：集合中不重复元素的总值被称为基数，如{1，6，3，4，3，9}，不重复元素为1，3，4，6，9 基数为5</p><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">pfadd K V1 V2#添加一个或多个元素pfcount K#统计基数pfmerge K1 K2 K3#将K2,K3中的值全部合并至K1</code></pre><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial:"></a>Geospatial:</h4><p>GEO:Geographic地理位置信息的缩写，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等操作</p><p>有效范围：经度：-180——180；纬度：-85——85</p><h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">geoadd K int1 int2 V  #设置K中的V：经度为int1，纬度为int2geopos K V#获取K中V的经纬度geodist K V1 V2m#获取V1到V2的直线距离，以米做单位（km千米，mi英里,ft英尺）georadius K int1 int2 int3 km#对K中处于经度int1纬度int2方圆int3km内的信息返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法题</title>
      <link href="/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点："><a href="#1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点：" class="headerlink" title="1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点："></a>1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点：</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ol><li>遍历整个二叉树，将所有节点的父节点以&lt;Node，Node&gt;形式存入hashmap中</li><li>创建HashSet，从node1开始依据HashMap依次将自己的父节点存入HashSet中</li><li>从node2开始溯洄父节点，一旦存在HashSet中就停止，此时就是首个公共祖先节点</li></ol><pre><code class="java">//主函数public static Node finFather(Node head, Node node1, Node2) &#123;    HashMap&lt;Node,Node&gt; hashmap = new HashMap&lt;&gt;();    hashmap.put(head,head);     process(head,hashmap);    HashSet&lt;Node&gt; set1 = new HashSet&lt;&gt;();        Node o1 = node1;    //循环至头节点停下    while(o1 != hashmap.get(o1))&#123;        set1.add(o1);        o1 = hashmap.get(o1);    &#125;    //将头节点添加    set1.add(head);        Node o2 = node2;    while(set1.get(o2)==null)&#123;        o2 = hashmap.get(o2);    &#125;    return o2;&#125;//存储父节点函数public static void process(Node head, HashMap&lt;Node.Node&gt; hashmap) &#123;    if(hashmap == null) return;    hashmap.put(head.left,head);    hashmap.put(head.right,head);    process(head.left,hashmap);    process(head.right,hashmap);&#125;</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>分析node1与node2可能的关系：</p><ol><li>node1是node2的祖先 &#x2F; node2是node1的祖先：返回node1 &#x2F; node2</li><li>node1与node2彼此不互为公共祖先，返回向上汇聚的祖先节点</li></ol><pre><code class="java">public static Node findFather(Node head, Node node1, Node node2) &#123;    if(head == null || head == node1 || head == node2) &#123;        return head;    &#125;    Node left = findFather(head.left, node1, node2);    Node right = findFather(head.right, node1, node2);    if(left != null &amp;&amp; right != null) &#123;        return head;    &#125;    return left != null ? left : right;&#125;</code></pre><h3 id="2-二叉树找到一个节点的后继节点："><a href="#2-二叉树找到一个节点的后继节点：" class="headerlink" title="2.二叉树找到一个节点的后继节点："></a>2.二叉树找到一个节点的后继节点：</h3><pre><code class="java">public class Node &#123;    public Node left;    public Node right;    public Node parent;//指向父节点    public int value;        public Node(int val) &#123;        this.value = val;    &#125;&#125;</code></pre><p><strong>后继节点</strong>：中序遍历二叉树后，每个节点的下一个节点是此节点的后继节点</p><p>（中序遍历打印每一位节点，相邻的后一个打印的节点是前一位的后继节点，相邻的前一节点是后一节点的前驱节点）</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><p>中序遍历生成列表，依次查询列表找到后继节点</p><h5 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h5><p>分析后继节点的可能情况：</p><ol><li>当前节点存在右树：后继节点是右树的最左节点</li><li>当前节点没有右树：判断是否为父节点的左孩子：是，父节点为后继；不是，继续看父节点（没有右数说明已经是某左子树最后一个节点）</li><li>前两者无法找到后继节点：后继节点为空，这个节点是二叉树中序遍历的最后一个节点</li></ol><pre><code class="java">//主程序public static Node getNextNode(Node node) &#123;    if(node == null) return node;    if(node.right != null) &#123;//情况1        return getLeftMost(node);    &#125;else &#123;        Node parent = node.parent;        while(parent != null &amp;&amp; parent.left != node) &#123;//情况2和3            node = parent;            parent = node.parent;        &#125;        return parent;    &#125;&#125;//走左子树public static Node getLeftMost(Node node) &#123;    if(node == null) &#123;        return node;    &#125;    while(node.left != null) &#123;        node = node.left;    &#125;    return node;&#125;</code></pre><h3 id="3-二叉树序列化与反序列化"><a href="#3-二叉树序列化与反序列化" class="headerlink" title="3.二叉树序列化与反序列化"></a>3.二叉树序列化与反序列化</h3><p>内存 → 字符串 ：序列化</p><p>字符串 → 内存：反序列化</p><h5 id="先序序列化："><a href="#先序序列化：" class="headerlink" title="先序序列化："></a>先序序列化：</h5><pre><code class="java">public static String serialTree(Node head) &#123;    if(head == null) return &quot;#_&quot;;    String res = head.value + &quot;_&quot;;    res += serialTree(head.left);    res += serialTree(head.right);    return res;&#125;</code></pre><h5 id="先序反序列化："><a href="#先序反序列化：" class="headerlink" title="先序反序列化："></a>先序反序列化：</h5><pre><code class="java">//排序public static Node reconSerialTree(String str) &#123;    String[] values = str.split(&quot;_&quot;);    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    for(int i = 0; i != values.length; i++) &#123;        queue.add(values[i]);    &#125;    return reconOrder(queue);&#125;//组成树public static Node reconOrder(Queue&lt;String&gt; queue) &#123;    String value = queue.poll();    if(value.equals(&quot;#&quot;))&#123;        return null;    &#125;    Node head = new Node(Integer.valueOf(value));    head.left = reconOrder(queue);    head.right = reconOrder(queue);    return head;&#125;</code></pre><h5 id="中序，后序同理"><a href="#中序，后序同理" class="headerlink" title="中序，后序同理"></a>中序，后序同理</h5>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉数："><a href="#二叉数：" class="headerlink" title="二叉数："></a>二叉数：</h1><ul><li><p>二叉树递归遍历</p></li><li><p>二叉树非递归遍历</p></li><li><p>宽度优先遍历</p></li><li><p>搜索二叉树</p></li><li><p>完全二叉树</p></li><li><p>满二叉树</p></li><li><p>平衡二叉树</p><hr></li></ul><pre><code class="java">// 二叉树节点class Node&lt;V&gt; &#123;    V value;    Node left;    Node right;&#125;</code></pre><p>头节点：也叫根节点，二叉树最顶端的节点（无无父结点）</p><p>叶节点：左右子节点都为null</p><p>子树：以任意一节点为根，其衍生下可以直接相连或经过节点相连的全部节点组成的树</p><h3 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h3><h4 id="使用递归方式实现："><a href="#使用递归方式实现：" class="headerlink" title="使用递归方式实现："></a>使用递归方式实现：</h4><pre><code class="java">// 二叉树每个节点遍历时都有三次访问public static void f(Node head) &#123;    //1:start    if (head == null) &#123;        return null;    &#125;    ...    // 1:end    f(head.left);    // 2:start    ...    // 2:end    f(head.right);    // 3:start    ...    // 3:end&#125;</code></pre><p>*<strong>先序，中序，后序遍历即是在第一次，第二次，第三次访问节点时做反应</strong></p><p><img src="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220812185607833.jpg" alt="image-20220812185607833"></p><h5 id="遍历打印（每次访问打印一次value）："><a href="#遍历打印（每次访问打印一次value）：" class="headerlink" title="遍历打印（每次访问打印一次value）："></a>遍历打印（每次访问打印一次value）：</h5><p>1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1</p><h5 id="先序访问顺序（对每颗子树-头左右）："><a href="#先序访问顺序（对每颗子树-头左右）：" class="headerlink" title="先序访问顺序（对每颗子树 头左右）："></a>先序访问顺序（对每颗子树 头左右）：</h5><p>1 2 4 5 3 6 7</p><h5 id="中序访问顺序（对每颗子树-左头右）："><a href="#中序访问顺序（对每颗子树-左头右）：" class="headerlink" title="中序访问顺序（对每颗子树 左头右）："></a>中序访问顺序（对每颗子树 左头右）：</h5><p>4 2 5 1 6 3 7</p><h5 id="后序访问顺序（对每颗子树-左右头）："><a href="#后序访问顺序（对每颗子树-左右头）：" class="headerlink" title="后序访问顺序（对每颗子树 左右头）："></a>后序访问顺序（对每颗子树 左右头）：</h5><p>4 5 2 6 7 3 1</p><hr><h3 id="使用非递归方式实现二叉树："><a href="#使用非递归方式实现二叉树：" class="headerlink" title="使用非递归方式实现二叉树："></a>使用非递归方式实现二叉树：</h3><h5 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h5><ol><li>创建一个栈（Stack）对象，将头节点压入栈列</li><li>弹出栈顶节点 Car</li><li>打印处理 Car</li><li>先压入右节点，再压入左节点（有就压）</li><li>返回第二步，直至栈空</li></ol><pre><code class="java">//代码实现public static void preOrder(Node head) &#123;    if(head != null)&#123;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();        stack.push(head);        while(!stack.isEmpty()) &#123;            head = stack.pop();            System.out.println(head.value());            if(head.right != null) &#123;                stack.push(head.right);            &#125;            if(head.left != null) &#123;                stack.push(head.left);                    &#125;        &#125;    &#125;&#125;</code></pre><h5 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h5><ol><li>创建一个栈，将数的最左边界依次压入</li><li>弹出打印栈顶元素，若栈顶存在右子树，将右子树的最左边界依次压入</li><li>循环2，直至栈空</li></ol><pre><code class="java">public static void (Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();        while(!stack.isEmpty() || head != null) &#123;            if(head != null) &#123;                stack.push(head);                head = head.left;            &#125;else &#123;            head = stack.pop();            System.out.println(head.value());               head = head.right;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h5><ol><li>创建两个栈（存储栈和收集栈）</li><li>弹出存储栈头节点，压入收集栈</li><li>将2中弹出的节点，以先压左节点再压右节点的顺序压入存储栈</li><li>返回2，直到存储栈为空</li><li>依次打印收集栈顺序</li></ol><pre><code class="java">public static void posOrder(Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; st1 = new Stack&lt;&gt;();        Stacj&lt;Node&gt; st2 = new Stack&lt;&gt;();        st1.push(head);        while(!st1.isEmpty())&#123;            head = st1.pop();            st2.push(head);            if(head.left != null)&#123;                st1.push(head.left);            &#125;            if(head.right != null) &#123;                st1.push(head.right);            &#125;        &#125;        while(!st2.isEmpty())&#123;            System.out.println(st2.pop().value);        &#125;    &#125;&#125;</code></pre><hr><h3 id="实现二叉树的宽度优先遍历："><a href="#实现二叉树的宽度优先遍历：" class="headerlink" title="实现二叉树的宽度优先遍历："></a>实现二叉树的宽度优先遍历：</h3><h5 id="使用队列："><a href="#使用队列：" class="headerlink" title="使用队列："></a>使用队列：</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>弹出打印队列首个对象，将其左子树先放入队列，再放其右子树（如果有）</li><li>循环2，直到队列为空</li></ol><pre><code class="java">public static void widthOrder(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        System.out.println(head.value);        if(head.left != null) &#123;            queue.add(head.left);        &#125;        if(head.right != null) &#123;            queue.add(head.right);        &#125;    &#125;&#125;</code></pre><h5 id="算法题：求一个二叉树的最大宽度？"><a href="#算法题：求一个二叉树的最大宽度？" class="headerlink" title="算法题：求一个二叉树的最大宽度？"></a>算法题：求一个二叉树的最大宽度？</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>创建一个hashMap对象，用于记录节点与当前所在深度，将&lt;head, 1&gt;记录</li><li>创建初始深度（int）设为1，初始节点数（int）设为0，初始最大值（int）设为Integer.MIN_VALUE;</li><li>弹出队列首个对象，并根据HashMap判断该节点是否是当前深度的节点，是：节点数++，否：最大值&#x3D;max（max，节点数），深度++，节点数设为1</li><li>将其左子树先放入队列，hashMap放入&lt;head.left，深度+1&gt;；再放其右子树，hashMap放入&lt;head.right，深度+1&gt;（如果有）</li><li>循环2-5，直到队列为空</li><li>调用Max函数计算最后一行节点个数和最大节点的比较</li></ol><pre><code class="java">public static void getMaxWidth(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    HashMap&lt;Node,Integer&gt; levelMap = new HashMap&lt;&gt;();    levelMap.put(head,1);    int curlevel = 1;//当前层数    int curNodeNum = 0;//当前节点数    int max = Integer.MIN_VALUE;//最大节点值    while(!queue.isEmpty()) &#123;        head = queue.poll();        int levelNode = levelMap.get(head);        if(levelNode == curlevel) &#123;//判断是否变层            cerNodeNum ++;//未变层，节点数++        &#125;else &#123;            max = Math.max(max, curNodeNum);//下一层，结算上一层的max，重置当前节点数            curLevel ++;            curNodeNum = 1;        &#125;        if(head.left != null) &#123;            queue.add(head.left);            levelMap.put(head.left,curlevel+1)//记录左子树以及其对应层，用于后续判断        &#125;        if(head.right != null) &#123;            queue.add(head.right);            levelMap.put(head.right,curlevel+1)//记录右子树以及其对应层，用于后续判断        &#125;    &#125;    max = Math(max, curNodeNum);&#125;</code></pre><h5 id="不使用哈希表完成上述题目："><a href="#不使用哈希表完成上述题目：" class="headerlink" title="*不使用哈希表完成上述题目："></a>*不使用哈希表完成上述题目：</h5><p>使用两个Node变量替代哈希表（当前层最后的节点，下一层最后的节点）</p><p>将head赋予当前层最后节点，在每次新添左右节点时，分别更新下一层最后节点为左右节点</p><p>每次队列弹出都检查是否是当前层最后节点，是：更新最大值，拷贝下一层最后节点至当前层最后节点，层数++；否：节点数++</p><h3 id="二叉树深度优先遍历：先序遍历"><a href="#二叉树深度优先遍历：先序遍历" class="headerlink" title="二叉树深度优先遍历：先序遍历"></a>二叉树深度优先遍历：先序遍历</h3><hr><h3 id="搜索二叉树："><a href="#搜索二叉树：" class="headerlink" title="搜索二叉树："></a>搜索二叉树：</h3><p>对于每一个子树，都满足其左树值比根节点值小，右树值比根节点大（一般不存在重复值）</p><h5 id="如何判断是否是搜索二叉树：中序遍历为升序"><a href="#如何判断是否是搜索二叉树：中序遍历为升序" class="headerlink" title="如何判断是否是搜索二叉树：中序遍历为升序"></a>如何判断是否是搜索二叉树：中序遍历为升序</h5><pre><code class="java">public static int prevalue = Integer.MIN_VALUE;public static boolean isBSt(Node head) &#123;    if(head == null) return true;    boolean isLeftBst = isBST(head.left);//左子树是否为搜索二叉树    if(!isLeftBst) return false;    if(head.value &lt;= preValue) &#123;//升序判断，动态检查        return false;    &#125;else &#123;        preValue = head.value;    &#125;    return isBST(head.right);//左子树是搜索二叉树，右子树是否为搜索二叉树&#125;</code></pre><p>非遍历判断同理</p><h5 id="总结返回信息："><a href="#总结返回信息：" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左子树：1.左树应是搜索二叉树2.获取左数的最大值（用于与根比较）</p><p>对于右子树：1.右树应是搜索二叉树2.获取右数的最小值（用于与根比较）</p><p>统一左右子树返回信息：是否是搜索二叉树，最小值，最大值</p><h5 id="判断是否为搜索二叉树："><a href="#判断是否为搜索二叉树：" class="headerlink" title="判断是否为搜索二叉树："></a>判断是否为搜索二叉树：</h5><pre><code class="java">public static boolean checkBST(Node head) &#123;    return process(head).isBST;&#125;//返回类型public static class ReturnType &#123;    public boolean isBST;    public int min;    public int max;        public ReturnData(boolean isb, int min, int max)&#123;        this.isBST = isb;        this.min = min;        this.max = max;    &#125;&#125;public static ReturnType process(Node x) &#123;    if(x == null) return null;    ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);    //获得整个子树的最大最小值    int min = x.value;    int max = x.value;    if(leftData != null) &#123;        min = Math.min(min,leftData.min);        max = Math.max(max,leftData.max);    &#125;    if(rightData != null) &#123;        min = Math.min(min,rightData.min);        max = Math.max(max,rightData.max);    &#125;           boolean isBST = true;    if(leftData != null &amp;&amp; (!leftData.isBST || leftData.max &gt;= x.value) &#123;        isBST = false;    &#125;    if(rightData != null &amp;&amp; (!rightData.isBST || x.value &gt;= rightData.min) &#123;        isBST = false;    &#125;       return new ReturnType(isBST,min,max);&#125;</code></pre><h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p>所有节点依次按从左往右依次放入的二叉树属于完全二叉树</p><ol><li>任意一节点有右孩子无左孩子 → 不是完全二叉树</li><li><strong>宽度优先遍历</strong>且在<strong>不违反1</strong>前提下，出现首个左右孩子不双全时，之后的节点都应该是叶子节点</li></ol><pre><code class="java">public static boolean isCBT(Node head) &#123;    if(head == null) return true;    //是否遇到过左右孩子不双全的判断    boolean leaf = false;    Node l = null;    Node r = null;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        l = head.left;        r = head.right;        if((leaf &amp;&amp; (l!=null || r!=null))//条件2          ||           (l == null &amp;&amp; r == null)//条件1          )&#123;            return false;        &#125;        if(l != null) &#123;            queue.add(l);        &#125;        if(r != null) &#123;            queue.add(r);        &#125;        if(l == null || r == null) &#123;            //leaf 为不可逆改变            leaf = true;        &#125;       &#125;    return true;&#125;</code></pre><h3 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h3><p>子节点要么都有，要么都没有，不存在只存在一边节点的二叉树</p><h5 id="判断是否为满二叉树："><a href="#判断是否为满二叉树：" class="headerlink" title="判断是否为满二叉树："></a>判断是否为满二叉树：</h5><pre><code class="java">public static boolean isFBT(Node head) &#123;    if(head == null) &#123;        return true;    &#125;    info data = process(head);    return data.nodes == ((1&lt;&lt;data.height) - 1);&#125;//返回信息public static class Info &#123;    public int height;//高度    public int nodes;//节点数        public Info(int hei, int nod) &#123;        this.height = hei;        this.nodes = nod;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static Info process(Node x) &#123;    if(x == null) &#123;        return new Info(0, 0);    &#125;        Info leftData = process(x.left);    Info rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    int nodes = leftData.nodes + rightData.nodes + 1;        return new Info(height, nodes);&#125;</code></pre><h3 id="平衡二叉树："><a href="#平衡二叉树：" class="headerlink" title="平衡二叉树："></a>平衡二叉树：</h3><p>对于任意一颗子树，其左树高度和右树高度差不少过1</p><ol><li>节点左树是平衡二叉树</li><li>节点右树是平衡二叉树</li><li>|节点左树高度 - 节点右数高度| &lt;&#x3D; 1</li></ol><p>以上条件对每个节点都成立，这个树就是平衡二叉树，否则不是</p><h5 id="总结返回信息：-1"><a href="#总结返回信息：-1" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左树，我们希望知道：1.左树是否是平衡二叉树2.左树高度</p><p>对于右数，我们希望知道：1.右树是否是平衡二叉树2.右数高度</p><p>左右树需要的信息一致；</p><h5 id="判断是否为平衡二叉树："><a href="#判断是否为平衡二叉树：" class="headerlink" title="判断是否为平衡二叉树："></a>判断是否为平衡二叉树：</h5><pre><code class="java">//返回值的变动，调用其他方法返回public static boolean isBT(Node head) &#123;    return process(head).isBalanced;&#125;//返回信息public static class ReturnType &#123;    public boolean isBalanced;//是否是平衡二叉树    public int height;//高度        public ReturnType(boolean isB, int hei) &#123;        this.isBalanced = isB;        this.height = hei;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static ReturnType process(Node x) &#123;    if(x == null) &#123;        return new ReturnType(true, 0);    &#125;        ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    boolean isBalance = leftData.isBalanced &amp;&amp; rightData.isBalanced                        &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; 2;        return new ReturnType(isBalance, height);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h1><ul><li>类，超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装器与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射</li><li>继承的设计技巧</li></ul><h3 id="类，超类和子类："><a href="#类，超类和子类：" class="headerlink" title="类，超类和子类："></a>类，超类和子类：</h3><h5 id="使用关键字：extends-表示继承"><a href="#使用关键字：extends-表示继承" class="headerlink" title="使用关键字：extends 表示继承"></a>使用关键字：extends 表示继承</h5><pre><code class="java">public class A extends B &#123;    ...&#125;</code></pre><p>超类 &#x3D; 基类 &#x3D; 父类子类 &#x3D; 孩子类</p><h5 id="使用父类的方法：-super"><a href="#使用父类的方法：-super" class="headerlink" title="使用父类的方法： super"></a>使用父类的方法： super</h5><pre><code class="java">super.fun();//使用父类的fun方法super();//使用父类的构造器方法</code></pre><h5 id="多态：可将子类对象赋予给超类变量"><a href="#多态：可将子类对象赋予给超类变量" class="headerlink" title="多态：可将子类对象赋予给超类变量"></a>多态：可将子类对象赋予给超类变量</h5><pre><code class="java">Employee e;//Manager extends Employeee = new Employee();//OKe = new Manager();      //ok</code></pre><p>强制类型转换：A a &#x3D; (A) b;后续使用可能会报错</p><p>在超类强转为子类前可以使用：instanceof 监测是否能强转</p><pre><code class="java">if(b instanceof a)&#123;//如果b能强转为a，就可以将b转为a给予其他变量使用    c = (a)b;&#125;</code></pre><h5 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h5><p>使用abstract关键字的方法不需要具体实现</p><p>含有抽象方法的对象必须为抽象对象，抽象对象不可以被实例化</p><h3 id="Object：所有子类的超类"><a href="#Object：所有子类的超类" class="headerlink" title="Object：所有子类的超类"></a>Object：所有子类的超类</h3><h5 id="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"><a href="#equals方法：监测对象是否相等，比较对象的各个属性而非具体地址" class="headerlink" title="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"></a>equals方法：监测对象是否相等，比较对象的各个属性而非具体地址</h5><h5 id="hashCode方法：散列码，由对象导出的整型数"><a href="#hashCode方法：散列码，由对象导出的整型数" class="headerlink" title="hashCode方法：散列码，由对象导出的整型数"></a>hashCode方法：散列码，由对象导出的整型数</h5><p>每个对象的散列码基本不相同，可以用作区分不同对象的标识</p><h5 id="toString方法：返回字符串类型对象信息"><a href="#toString方法：返回字符串类型对象信息" class="headerlink" title="toString方法：返回字符串类型对象信息"></a>toString方法：返回字符串类型对象信息</h5><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><h5 id="ArrayList：自定义类型数组"><a href="#ArrayList：自定义类型数组" class="headerlink" title="ArrayList：自定义类型数组"></a>ArrayList：自定义类型数组</h5><pre><code class="java">ArrayList&lt;ClassName&gt; a = new ArrayLisrt&lt;&gt;();//ArrayList数组中全是ClassName类型对象var b = new ArrayList&lt;ClassName&gt;();//效果同上，java 10以后可以使用var避免重复书写类名</code></pre><p>使用trimToSIze()方法裁剪数组多余部分</p><h5 id="数组列表访问对象："><a href="#数组列表访问对象：" class="headerlink" title="数组列表访问对象："></a>数组列表访问对象：</h5><pre><code class="java">var A = new ArrayList&lt;ClassB&gt;();A.set(i,Obj);//使用set方法赋值，第几位，赋什么A.get(i);//获得第几位的信息A.size();//获取列表数量，不可以用length</code></pre><h3 id="对象包装器和自动包装"><a href="#对象包装器和自动包装" class="headerlink" title="对象包装器和自动包装"></a>对象包装器和自动包装</h3><p>有时会需要将int这样的基本类转换为对象，我们称这样的类为包装器：<br><strong>int - Integetlong - Longfloat - Floatdouble - Doubleshort - Shortchar -  Characterboolean - Boolean</strong></p><p>前六个类派生于公类Number</p><p>包装器类是不可变的，一旦构造便不允许更改其包装在其中的值，同时包装器也是final，不可以派生子类</p><pre><code class="java">ArrayList&lt;int&gt; ... //是错误的ArrayList&lt;Integer&gt; ... //是正确的</code></pre><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>在类后加上… 即可</p><pre><code class="java">public static double max(double... values)&#123;    double larger = Double.NEGATIVE_INFINITY    for(double v : values) if (v&gt;larger) larger = v;    return larger;&#125;double a = max(3.1, 40.2, -5);</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code class="java">public enum Size &#123; SMALL, MEDIUM, LAGER, EXTRA_LARGE &#125;;//枚举的各个方法static Enum valueOf(Class enumClass, String name)//返回给定类中有指定名字的枚举常量String toString()//返回枚举常量名int ordinal()//返回枚举常量在enum声明中的位子，从0开始记数int compareTo(E other)//如果枚举常量在other之前，返回负整数；如果other==this,返回0；否则返回正整数。枚举常量次序在enum声明中给出</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序被成为反射</p><h5 id="Class类："><a href="#Class类：" class="headerlink" title="Class类："></a>Class类：</h5><pre><code class="java">Employee A;Class cl = a.getClass();//保存一个Class类型实例，可以使用对应方法，如getName()String name = cl.getName();//name = &quot;Employee&quot;String ckassName = &quot;java.util.Random&quot;;Class cl = Class.forName(className);//效果同上Class c1 = Employee.class;//效果同上</code></pre><h5 id="异常：非检查型异常（unchecked），检查型异常（checked）"><a href="#异常：非检查型异常（unchecked），检查型异常（checked）" class="headerlink" title="异常：非检查型异常（unchecked），检查型异常（checked）"></a>异常：非检查型异常（unchecked），检查型异常（checked）</h5><p>异常可以通过在类名后添加 throws … 对应语句</p><h5 id="资源-："><a href="#资源-：" class="headerlink" title="资源 ："></a>资源 ：</h5><pre><code class="java">Class cl = ResourceTest.class;URL url = cl.getResource(&quot;b.gif&quot;);...//多种方法</code></pre><h5 id="检查类的结构：FIeld，Method，Constructor"><a href="#检查类的结构：FIeld，Method，Constructor" class="headerlink" title="检查类的结构：FIeld，Method，Constructor"></a>检查类的结构：FIeld，Method，Constructor</h5><p>java.lang.reflect 中的三个方法：FIeld，Method，Constructor 分别用于返回 字段，方法 和 构造器 的名称</p><p>其中：getDeclareFields，getDeclareMethods，getDeclareConstructors 返回声明中的全部字段，方法，构造器的数组</p><p>通过setAccessible方法可以覆盖Java的访问控制，避免私有属性调用报错</p><h5 id="newInstance方法："><a href="#newInstance方法：" class="headerlink" title="newInstance方法："></a>newInstance方法：</h5><p>提供Array的元素类型，提供数组长度即可生成对应数组</p><h5 id="invoke方法："><a href="#invoke方法：" class="headerlink" title="invoke方法："></a>invoke方法：</h5><p>允许调用Method中的方法</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口，lambda表达式与内部类"><a href="#接口，lambda表达式与内部类" class="headerlink" title="接口，lambda表达式与内部类"></a>接口，lambda表达式与内部类</h1><ul><li>接口</li><li>lambda表达式</li><li>内部类</li><li>服务加载器 (null)</li><li>代理</li></ul><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>使用关键字： interface (定义接口)， implements (实现接口)</p><p>接口中的方法自动为public，写接口时不需要赋予public权限词</p><h5 id="实现接口需要实现其全部方法"><a href="#实现接口需要实现其全部方法" class="headerlink" title="实现接口需要实现其全部方法"></a>实现接口需要实现其全部方法</h5><pre><code class="java">interface A;class B implements A;A a = new A();//错误A b;b = new B();//正确,可以声明接口变量，实例化为实现接口的对象</code></pre><h5 id="java是单继承，每个类只能有一个超类，但能实现很多接口"><a href="#java是单继承，每个类只能有一个超类，但能实现很多接口" class="headerlink" title="java是单继承，每个类只能有一个超类，但能实现很多接口"></a>java是单继承，每个类只能有一个超类，但能实现很多接口</h5><p>*使用 static ，private 关键词创造静态私有方法</p><p>使用 default 关键字创造默认方法，可以直接在接口中提供默认实现</p><pre><code class="java">public interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123; return 0; &#125;&#125;</code></pre><h5 id="默认方法冲突："><a href="#默认方法冲突：" class="headerlink" title="默认方法冲突："></a>默认方法冲突：</h5><ol><li>超类优先：如果超类提供了一个具体方法，同名且有相同参数的默认方法会被忽略</li><li>接口冲突：两个接口提供了同名同参的方法时，必须覆盖这个方法依解决问题（声明实现其中一个）</li></ol><h3 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="*lambda表达式："></a>*lambda表达式：</h3><p>目的： 方便的传递代码块</p><pre><code class="java">// 有参数lambda表达式(String first, String second) -&gt;&#123;    if(first.length() &lt; second.length()) return -1;    else if(first.length() &gt; second.length) return 1;    else return 0;&#125;// 无参数lambda表达式() -&gt;&#123;    for(int i=0; i&lt;100; i++)        System.out.println(i);&#125;//方法引用 (::)...//构造器引用 (new)</code></pre><h5 id="Comparing比较器"><a href="#Comparing比较器" class="headerlink" title="Comparing比较器"></a>Comparing比较器</h5><h3 id="内部类："><a href="#内部类：" class="headerlink" title="*内部类："></a>*内部类：</h3><p>内部类是定义在另一个类中的类，可以简洁的回调：</p><ol><li>内部类对同一个包中的其他类隐藏</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原有的私有数据</li></ol><h5 id="外围类引用：OuterClass-this"><a href="#外围类引用：OuterClass-this" class="headerlink" title="外围类引用：OuterClass.this"></a>外围类引用：OuterClass.this</h5><h5 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h5><p>不仅在类中，同时在局部（方法）中定义类，被称为局部内部类</p><h5 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h5><p>直接new对象并给定义（属性方法）不用设类名</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><p>将内部类声明为static就不会产生引用</p><h3 id="服务加载器："><a href="#服务加载器：" class="headerlink" title="服务加载器："></a>服务加载器：</h3><p>null</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理类包含以下方法：</p><ul><li>指定接口所需要的全部方法</li><li>Object类中的全部方法，如toString，equals等</li></ul><p>创建代理对象需要使用 Proxy 类的newProxyInstance方法，对应的三个参数为：</p><ul><li>一个类加载器 （class loader）</li><li>一个Class对象数组</li><li>一个调用处理器</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与类</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="对象与类："><a href="#对象与类：" class="headerlink" title="对象与类："></a>对象与类：</h1><ul><li>面向对象程序设计概述</li><li>适用预定义类</li><li>用户自定义方法</li><li>静态字段与静态方法</li><li>方法参数</li><li>对象构造</li><li>包</li><li>JAR文件</li><li>文档注释</li><li>类设计技巧</li></ul><h3 id="面向对象程序设计概述-OOP"><a href="#面向对象程序设计概述-OOP" class="headerlink" title="面向对象程序设计概述(OOP)"></a>面向对象程序设计概述(OOP)</h3><h5 id="类：存储数据字段和方法的摸具"><a href="#类：存储数据字段和方法的摸具" class="headerlink" title="类：存储数据字段和方法的摸具"></a>类：存储数据字段和方法的摸具</h5><h5 id="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"><a href="#封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法" class="headerlink" title="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"></a>封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法</h5><h5 id="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"><a href="#对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）" class="headerlink" title="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"></a>对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）</h5><h5 id="识别类：Item，Order等为人熟悉的人为设计类"><a href="#识别类：Item，Order等为人熟悉的人为设计类" class="headerlink" title="识别类：Item，Order等为人熟悉的人为设计类"></a>识别类：Item，Order等为人熟悉的人为设计类</h5><h5 id="类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a"><a href="#类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a" class="headerlink" title="类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)"></a>类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)</h5><h3 id="使用预定义类："><a href="#使用预定义类：" class="headerlink" title="使用预定义类："></a>使用预定义类：</h3><p>使用构造器（constructor 构造函数）在目标类前加上 new 操作符</p><p>表示时间点的Date类</p><p>*表示日历的LocalDate类</p><h3 id="用户自定义类与自定义方法："><a href="#用户自定义类与自定义方法：" class="headerlink" title="用户自定义类与自定义方法："></a>用户自定义类与自定义方法：</h3><p>使用class关键字自定义类</p><p>“javac className*.java”与”javac classNameTest.java”都可以视为编译className类</p><h5 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h5><ul><li>构造器需要与类名同名</li><li>每个类可以有一个以上的构造器（0，1，2…个不同参数）</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作符一起调用</li></ul><p>var声明局部变量：仅能用于方法中，参数与字段仍需要声明</p><h5 id="实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"><a href="#实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改" class="headerlink" title="实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"></a>实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改</h5><h3 id="静态字段与静态方法："><a href="#静态字段与静态方法：" class="headerlink" title="静态字段与静态方法："></a>静态字段与静态方法：</h3><p>静态常量：static final</p><p>静态方法：static</p><p>工厂方法：使用静态方法构造对象</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>形参与实参</p><h3 id="对象构造："><a href="#对象构造：" class="headerlink" title="对象构造："></a>对象构造：</h3><h5 id="重载：多个方法具有相同的函数名，不同的参数"><a href="#重载：多个方法具有相同的函数名，不同的参数" class="headerlink" title="重载：多个方法具有相同的函数名，不同的参数"></a>重载：多个方法具有相同的函数名，不同的参数</h5><h5 id="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）"><a href="#默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）" class="headerlink" title="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）"></a>默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）</h5><h5 id="调用其他构造器：this-…"><a href="#调用其他构造器：this-…" class="headerlink" title="调用其他构造器：this(…)"></a>调用其他构造器：this(…)</h5><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><h5 id="英特网域名的作用之一就是保证-包名的唯一性"><a href="#英特网域名的作用之一就是保证-包名的唯一性" class="headerlink" title="英特网域名的作用之一就是保证 包名的唯一性"></a>英特网域名的作用之一就是保证 包名的唯一性</h5><h5 id="引入类的方法："><a href="#引入类的方法：" class="headerlink" title="引入类的方法："></a>引入类的方法：</h5><ol><li>直接使用 包名.类名</li><li>提前使用import声明引入包类</li></ol><p>包访问权限（public-全部，private-本类，protected-本包与子类，默认-本包）</p><h5 id="包-类路径：设置类路径-classpath（命令行指令）"><a href="#包-类路径：设置类路径-classpath（命令行指令）" class="headerlink" title="包.类路径：设置类路径 -classpath（命令行指令）"></a>包.类路径：设置类路径 -classpath（命令行指令）</h5><h3 id="JAR文件（java归档文件）："><a href="#JAR文件（java归档文件）：" class="headerlink" title="JAR文件（java归档文件）："></a>JAR文件（java归档文件）：</h3><p>jar文件是一种zip压缩文件</p><p>*目前常使用maven等协助打包</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>注释要写全，写细</p><h3 id="类设计技巧："><a href="#类设计技巧：" class="headerlink" title="类设计技巧："></a>类设计技巧：</h3><ol><li>保证数据私有</li><li>对数据进行初始化</li><li>不要在类中使用过多的基本类型</li><li>不是所有字段都需要单独的字段访问器和字段更改器</li><li>分解有过多指责的类</li><li>类名与方法名要能体现他们的职责</li><li>优先使用不可变的类</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计结构</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序设计结构"><a href="#Java程序设计结构" class="headerlink" title="Java程序设计结构"></a>Java程序设计结构</h1><ul><li>数据类型</li><li>变量与常量</li><li>运算符</li><li>字符串</li><li>输入输出</li><li>控制流</li><li>大数</li><li>数组</li></ul><h4 id="保留字与关键字："><a href="#保留字与关键字：" class="headerlink" title="保留字与关键字："></a>保留字与关键字：</h4><p>关键字：目前已经有特殊作用的单词字符，例如static，class等</p><p>保留字：包括关键字，同时还有部分目前未被使用，但未来可能会被使用的单词字符</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>八种基本类型，包括</p><ul><li><p>四种整型：int（四字节，正负21e），short（二字节，正负三万二），</p><p>​long（八字节，正负900ee），byte（一字节，-128—127）</p></li><li><p>两种浮点型：float（四字节），double（八字节）</p></li><li><p>一种字符型：char（二字节），用于表示Unicode编码的代码单元</p></li><li><p>一种用于表真值：boolean</p></li></ul><p>浮点数遵循IEEE 754规范：</p><p>NAN为非数字，例如0&#x2F;0会得到Double.NAN；</p><p>无穷大（正负）是特殊浮点Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY</p><h3 id="变量与常量："><a href="#变量与常量：" class="headerlink" title="变量与常量："></a>变量与常量：</h3><h5 id="变量：需要显式初始化变量"><a href="#变量：需要显式初始化变量" class="headerlink" title="变量：需要显式初始化变量"></a>变量：需要显式初始化变量</h5><pre><code class="java">boolean flag = false;</code></pre><h5 id="常量：使用关键字-static-final-设置常量，"><a href="#常量：使用关键字-static-final-设置常量，" class="headerlink" title="常量：使用关键字 static final 设置常量，"></a>常量：使用关键字 static final 设置常量，</h5><pre><code class="java">public static final int age = 18;</code></pre><h5 id="枚举类型：在有限集合内取值可以自定义枚举类型"><a href="#枚举类型：在有限集合内取值可以自定义枚举类型" class="headerlink" title="枚举类型：在有限集合内取值可以自定义枚举类型"></a>枚举类型：在有限集合内取值可以自定义枚举类型</h5><pre><code class="java">enum Size &#123; SMALL，MEDIUM，LARGE，EXTRA_LARGE &#125;;Size a = SIze.SMALL;</code></pre><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><h5 id="算数运算符（加减乘除余）：-x2F"><a href="#算数运算符（加减乘除余）：-x2F" class="headerlink" title="算数运算符（加减乘除余）：+ - * &#x2F; %"></a>算数运算符（加减乘除余）：+ - * &#x2F; %</h5><p>int类型会向下取整</p><h5 id="数学函数："><a href="#数学函数：" class="headerlink" title="数学函数："></a>数学函数：</h5><p>Math.sqrt（int a）：对a求平方根</p><p>Math.abs（int a） ：对a取绝对值</p><p>Math.round（double a）：对a四舍五入转为整型int</p><h5 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h5><p><img src="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/changeSize.jpg" alt="changeSize"></p><p>实线为无信息丢失的转换，虚线为存在精度丢失的转换</p><h5 id="关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D"><a href="#关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D" class="headerlink" title="关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;"></a>关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;</h5><h5 id="位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt"><a href="#位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt" class="headerlink" title="位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;"></a>位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;</h5><h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><h5 id="子串：（subString方法）"><a href="#子串：（subString方法）" class="headerlink" title="子串：（subString方法）"></a>子串：（subString方法）</h5><pre><code class="java">String str = &quot;Hello&quot;;String s = str.subString(0,3);//s = &quot;Hel&quot;,即0到2</code></pre><h5 id="相等：-equals方法"><a href="#相等：-equals方法" class="headerlink" title="相等：(equals方法)"></a>相等：(equals方法)</h5><pre><code class="java">if(str.equals(s))&#123;    return false;&#125;</code></pre><h5 id="空串与Null串："><a href="#空串与Null串：" class="headerlink" title="空串与Null串："></a>空串与Null串：</h5><pre><code class="java">if(str.length() == 0)//判断是否为空串：“”if(str == null)//判断是否为null串</code></pre><h5 id="构建字符串：（Stringbuilder类）"><a href="#构建字符串：（Stringbuilder类）" class="headerlink" title="构建字符串：（Stringbuilder类）"></a>构建字符串：（Stringbuilder类）</h5><pre><code class="java">//节省空间和时间的字节构建类型，直接append添加,toString成符StringBuilder bs = new StringBuilder();bs.append(&quot;a&quot;);bs.append(&quot;b&quot;);String s = bs.toString();</code></pre><h3 id="输入和输出："><a href="#输入和输出：" class="headerlink" title="输入和输出："></a>输入和输出：</h3><h5 id="Util-Scanner类："><a href="#Util-Scanner类：" class="headerlink" title="Util.Scanner类："></a>Util.Scanner类：</h5><pre><code class="java">Scanner in = new Scanner(System.in);String name = in.nextLine();int age = in.nextInt();</code></pre><h5 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h5><pre><code class="java">double x = 10000 / 3.0;System.out.printf(&quot;%8.2f&quot;,x);//返回八个字符，小数点算一个，且返回小数点后两位，不够八位在前补充空格                                //x = 3333.33      </code></pre><h5 id="转换符："><a href="#转换符：" class="headerlink" title="转换符："></a>转换符：</h5><p>d：十进制x：十六进制o：八进制f：定点浮点数e：指数浮点数    ….</p><h3 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h3><h5 id="块作用域：-…"><a href="#块作用域：-…" class="headerlink" title="块作用域：{…}"></a>块作用域：{…}</h5><p>块内变量不会带到块外使用，块外已定义变量不允许块内重复定义</p><h5 id="判断：if，if-else，if-else-if-else"><a href="#判断：if，if-else，if-else-if-else" class="headerlink" title="判断：if，if-else，if-else if-else"></a>判断：if，if-else，if-else if-else</h5><h5 id="循环：for，-while，-do-while"><a href="#循环：for，-while，-do-while" class="headerlink" title="循环：for， while， do-while"></a>循环：for， while， do-while</h5><h5 id="多重选择：switch-case-default"><a href="#多重选择：switch-case-default" class="headerlink" title="多重选择：switch-case-default"></a>多重选择：switch-case-default</h5><h5 id="跳出：return，break，continue"><a href="#跳出：return，break，continue" class="headerlink" title="跳出：return，break，continue"></a>跳出：return，break，continue</h5><h3 id="大数："><a href="#大数：" class="headerlink" title="大数："></a>大数：</h3><p>java.Math包下的：BigInteger和Bigdecimal（比int和double都更加精确）</p><pre><code class="java">BigDecimal a = new BigDecimal(&quot;0.1&quot;);//String转Big,精确BigDecimal a = new BigDecimal(0.1);//Double转Big,不精确，可能变成0.0999999998之类的</code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h5 id="声明与初始化："><a href="#声明与初始化：" class="headerlink" title="声明与初始化："></a>声明与初始化：</h5><pre><code class="java">int[] a;//声明int[] b = new int[100];//初始化a = &#123;1,2,3,4,5&#125;//赋值</code></pre><h5 id="循环：for，for-each"><a href="#循环：for，for-each" class="headerlink" title="循环：for，for-each"></a>循环：for，for-each</h5><h5 id="数组拷贝：Arrays-copyOf-：生成新数组的深拷贝"><a href="#数组拷贝：Arrays-copyOf-：生成新数组的深拷贝" class="headerlink" title="数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝"></a>数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝</h5><pre><code class="java">int[] c = Arrays.copyOf(a,a.length);//第一个参数为拷贝对象，第二个参数为创建数组c的长度</code></pre><h5 id="数组排序：Arrays-sort-：快速排序"><a href="#数组排序：Arrays-sort-：快速排序" class="headerlink" title="数组排序：Arrays.sort()：快速排序"></a>数组排序：Arrays.sort()：快速排序</h5>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题2</title>
      <link href="/2022/03/09/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
      <url>/2022/03/09/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？"><a href="#MySQL-事务有哪些隔离级别、分别有什么特点，以及-MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？"></a>MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？</h2><p>MySQL事务有四种隔离级别：</p><ol><li><strong>读未提交</strong>（Read Uncommitted）：事务可以读取未提交的数据，可能会读到脏数据，导致幻读，不可重复读，脏读等问题</li><li><strong>读已提交</strong>（Read Committed）：只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复读，幻读问题</li><li><strong>可重复读</strong>（Repeatable Read）：保证同一事务中多次读取同一数据的结果是一致的，避免了脏读和不可重复读问题，但是可能会遇到幻读的问题</li><li><strong>序列化</strong>（Serializable）：最高的隔离级别，可以避免所有的并发问题，但是并发性非常低，开销很大</li></ol><p>MySQL的默认隔离级别是可重复读</p><p><strong>脏读</strong>指一个事务读到了另一个事务未提交的数据</p><p><strong>不可重复读</strong>指同一个事务多次读到同一数据的不同结果</p><p><strong>幻读</strong>指同一事物前后读取的数据集合不一致（按条件查询时找不到数据，插入时又已存在数据）</p><h2 id="讲一下-Redis-的单线程模型，IO-多路复用是什么？"><a href="#讲一下-Redis-的单线程模型，IO-多路复用是什么？" class="headerlink" title="讲一下 Redis 的单线程模型，IO 多路复用是什么？"></a>讲一下 Redis 的单线程模型，IO 多路复用是什么？</h2><p>Redis是一款基于内存的高性能键值存储系统，采用单线程模型设计。在Redis中，所有客户端的请求都是由一个单线程来处理的，这个单线程不断从客户端套接字中读取命令请求，并将命令请求放入一个请求队列中。接着，Redis的事件处理器会按照一定的规则选择一个请求进行处理，处理完之后将响应结果返回给客户端。</p><p>单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，简化了系统的设计和调试。此外，由于Redis的内存访问速度非常快，因此单线程处理请求也能够保证足够的性能</p><p>IO多路复用是指在同一个线程中同时监听多个文件描述符，一旦某个文件描述符就绪，就立刻处理对应事件。在Redis中，采用的是基于epoll的IO多路复用技术，可以实现高效的事件监听和响应</p><p>在Redis中，客户端的请求是由一个单线程来处理的，而IO操作却是通过epoll多路复用技术实现的。这种设计方式既能充分利用CPU的计算能力，又能够保证足够的IO处理能力，从而实现高效的键值存储服务</p><h2 id="什么是-BIO、NIO、AIO？"><a href="#什么是-BIO、NIO、AIO？" class="headerlink" title="什么是 BIO、NIO、AIO？"></a>什么是 BIO、NIO、AIO？</h2><p>BIO、NIO、AIO都是Java的IO模型</p><p>BIO（Blocking IO）：同步阻塞IO，是传统的IO模型，它在读写数据时会<strong>阻塞线程</strong>，知道数据读写完成，适用于并发不高的场景</p><p>NIO（Non-blocking IO）同步非阻塞IO，是Java的新IO模型，它在读写数据时不会阻塞线程，而是通过<strong>轮询</strong>的方式查询是否有数据可读写，适用于并发量较高的场景</p><p>AIO（Asynchronous IO）异步非阻塞IO，是JDK7开始引入的新IO模型，它读写方式与NIO相似，但在读写数据时，不<strong>需要自己动手轮询</strong>是否有数据可读写，而是交由系统完成，适用于高并发且处理较大数据量的场景。</p><p>总的来说，BIO的并发处理能力较差，NIO的并发处理能力较好，但使用起来较为复杂，AIO的并发处理能力最好，但也是最为复杂的一种IO模型。现在适合自己场景的IO模型时非常重要的。</p><h2 id="意向锁是什么？有什么作用？它是表级锁还是行级锁？"><a href="#意向锁是什么？有什么作用？它是表级锁还是行级锁？" class="headerlink" title="意向锁是什么？有什么作用？它是表级锁还是行级锁？"></a>意向锁是什么？有什么作用？它是表级锁还是行级锁？</h2><p>意向锁时一种MySQL数据库中的锁，用于表级协调多个行级锁的使用。在表级锁定一个表之前，MySQL需要先获得一个意向锁，以表明要获取的锁的类型（读锁或写锁），避免其他事务锁定一部分表时引发死锁。</p><p>意向锁是一种轻量级锁，他不会影响其他事务的读操作，只有在某个事务要对表进行写操作时才会加上意向锁，而其他事务在读取时只需要获取读锁，不需要等待意向锁的释放。</p><p>意向锁可以提高数据库并发性能，防止死锁的发生。它是表级锁，而不是行级锁。</p><h2 id="Spring、SpringMVC、SpringBoot-三者之间是什么关系？"><a href="#Spring、SpringMVC、SpringBoot-三者之间是什么关系？" class="headerlink" title="Spring、SpringMVC、SpringBoot 三者之间是什么关系？"></a>Spring、SpringMVC、SpringBoot 三者之间是什么关系？</h2><p>Spring，SpringMVC，SpringBoot是三个独立的框架，它们之间的关系是：</p><ol><li>Spring是一个Java轻量级应用框架，提供基于IoC和AOP的支持，用于构建企业级应用。Spring有多个模块，包括Spring Core，Spring Context，Spring JDBC，Spring Web等，每个模块提供了不同的功能。</li><li>SpringMVC 是 Spring框架的一部分，是基于MVC设计模式的web框架，用于构建web应用程序。它提供了控制器，数据绑定，异常处理等功能，使得开发Web应用变得更加简单。SpringMVC还支持RESTfuk架构。</li><li>SpringBoot是基于Spring框架的一个开发框架，用于快速构建独立的，生产级别的Spring应用程序。它通过自动配置和约定优于配置的方式，简化了Spring应用程序的配置和开发过程。SpringBoot集成了很多常用的第三方库和工具，例如SpringData，SpringSecurity，Thymeleaf，Logback等，可以极大的提高开发效率。</li></ol><p>因此，SpringBoot可以看作是在Spring的基础上，通过自动装配的约定优于配置的方式，提供了更加简单，快速的开发体验。而SpringMVC则是Spring框架中用于构建Web应用程序的模块</p><h2 id="Redis-基础类型中的-String-底层实现是什么？"><a href="#Redis-基础类型中的-String-底层实现是什么？" class="headerlink" title="Redis 基础类型中的 String 底层实现是什么？"></a>Redis 基础类型中的 String 底层实现是什么？</h2><p>Redis中的Spring类型底层实现是一个简单的动态字符串（SDS,Simple Dynamic String），也就是字符串动态增长实现的一种方式，SDS是Redis自己实现字符串库，相对于C语言原生的字符串，SDS在空间使用上更加灵活，而且支持O（1）复杂度的长度计算，避免了C语言字符串计算长度时的O（N）时空复杂度问题</p><p>SDS是一种动态字符串，它有如下特点：</p><ol><li>首先SDS对内存的分配和释放进行了封装，使得字符串的空间可以根据需要进行增长或缩短，避免了C语言字符串需要手动分配空间的问题</li><li>SDS除了记录字符串本身的长度外，还记录了分配给字符串的空间的长度，可以方便的计算出字符串是否需要扩容</li><li>SDS使用了惰性空间释放，不会再空间缩减时立刻释放空间，而是等到需要扩容时再重新分配内存</li><li>SDS提供了字符串的追加操作，可以在O（1）的时间内完成追加操作。</li></ol><p>在Redis中，String类型并不仅仅时字符串类型，它还支持一些其他操作，如递增&#x2F;递减操作，位运算，这些操作都是基于SDS底层实现的。</p><h2 id="有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？"><a href="#有哪些注解可以注入-Bean？-Autowired-和-Resource-的区别？" class="headerlink" title="有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？"></a>有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？</h2><p>在Spring框架中，常用的注入Bean的注解包括：</p><ol><li>@Autowired：自动注入，按照类型自动装配，如果有多个类型相同的Bean，则需要通过@Qualifier指定具体的Bean</li><li>@Resource：Java自带的注入方式，按照名称自动装配，默认是按照属性名称进行匹配，如果需要按照Bean的名称进行匹配，可以使用@Resource（name&#x3D;”beanName”）</li><li>@Inject：和@Autowired类似，也是按照类型进行自动装配，但是@Inject注解是JSR-330 提供的，而@Autowired 注解是 Spring 框架提供的</li><li>@Value：用于注入配置文件中的属性值，可以指定默认值</li><li>@Component：用于声明一个Bean，作用类似于XML中的&lt; bean &gt; 标签</li></ol><p>以上注解都可以用于注入Bean，不同注解之间的区别主要在于注入方式和实现方式不同。＠Autowired 和@Resource最常用，其中@Autowired按照类型自动装配更为常用，而@Resource按照名称自动装配则比较适合需要明确指定的Bean名称的情况</p><p>需要注意的是，注入Bean的时候最好使用接口类型作为注入对象，这样可以避免应为具体实现类变更导致注入失败的问题</p><h2 id="请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？"><a href="#请你介绍下-JVM-内存模型，分为哪些区域？各区域的作用是什么？" class="headerlink" title="请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？"></a>请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？</h2><p>JVM内存模型分为一下几个区域：</p><ol><li>程序计数器（Program Counter Register）：每个线程都有自己的程序技术器，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确位置</li><li>虚拟机栈（JVM Stack）：也称Java方法栈，用于存储方法执行时的局部变量表，操作数栈，动态链表，方法出口等信息.每个线程正在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈</li><li>本地方法栈（Native Method Stack）：于虚拟机栈类似，用于存储本地方法的执行信息</li><li>堆（Heap）：用于存储对象实例，时JVM中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的独享实例都有一个标记用于标记对象是否存活，垃圾回收器会周期性的回收那些没有被标记为存活的对象</li><li>方法区（Method Area）：用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。方法区也是被所有线程共享的</li><li>运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池</li></ol><p>其中，程序计数器，虚拟机栈，本地方法栈是线程私有，堆，方法区，运行时常量池是线程共享的</p><h2 id="Linux-中的硬链接和软连接是什么，二者有什么区别？"><a href="#Linux-中的硬链接和软连接是什么，二者有什么区别？" class="headerlink" title="Linux 中的硬链接和软连接是什么，二者有什么区别？"></a>Linux 中的硬链接和软连接是什么，二者有什么区别？</h2><p>在Linux 文件系统中，硬链接（hard link）和软连接（私有mbolic link）都是一种文件链接方式，可以用于将一个文件链接到另一个文件上。它们主要区别在创建方式，所占空间和使用限制等方面</p><p>硬链接是通过在文件系统中创建一个新的目录项（directory entry）指向同一文件inode的位置来实现。因为硬链接实际上是指向同一inode，所以如果源文件被删除，硬链接依然能够访问到源文件的内容。硬链接的使用范围比较受限，因为硬链接只能指向一个文件系统内的文件，不能跨文件系统创建</p><p>软链接是通过在文件系统中创建一个新的文件来实现，该文件中包含指向另一个文件的路径。软连接可以跨文件系统创建，并且可以指向任何类型的文件。但是，当源文件被删除时，软链接会失效</p><p>总的来说，硬链接要更加高效，因为它只是添加了一个新的目录项，所以对磁盘空间的消耗比软链接要小。但是，硬链接不能跨文件系统，所以在实际应用中需要根据具体的需求来选择使用哪种链接方式</p><h2 id="如何使用-Redis-实现一个排行榜？"><a href="#如何使用-Redis-实现一个排行榜？" class="headerlink" title="如何使用 Redis 实现一个排行榜？"></a>如何使用 Redis 实现一个排行榜？</h2><p>使用Redis 可以很方便的实现一个排行榜，以下是一种实现方式：</p><p>使用有序集合（Sorted Set）来存储排行榜数据，以用户得分作为分数（score），用户ID作为成为（member）</p><p>当用户得分改变时，使用Redis的ZADD命令将用户的分数更新到有序集合中</p><p>获取排行榜数据时，使用Redis的ZREVRANGE命令按分数排序获得有序集合中的成员</p><p>可以使用Redis的ZSCORE命令获取某个用户的分数，或使用ZREVRANK命令获取某个用户的排名。例如：</p><pre><code class="java">import redis.clients.jedis.Jedis;import java.util.Map;import java.util.Set;public class RedisRankingList &#123;    private final Jedis jedis;    public RedisRankingList() &#123;        // 连接 Redis        jedis = new Jedis(&quot;localhost&quot;);    &#125;    /**     * 添加用户分数     */     public void addUserScore(String userId, double score) &#123;        jedis.zadd(&quot;ranking&quot;, score, userId);    &#125;    /**     * 获取排行榜前 N 名用户信息     */    public void getTopN(int n) &#123;        // 获取排行榜前 N 名用户的 ID 和分数        Set&lt;Map.Entry&lt;String, Double&gt;&gt; rankingSet = jedis.zrevrangeWithScores(&quot;ranking&quot;, 0, n - 1);        // 遍历集合，输出用户信息        for (Map.Entry&lt;String, Double&gt; entry : rankingSet) &#123;            String userId = entry.getKey();            double score = entry.getValue();            System.out.println(&quot;userId: &quot; + userId + &quot;, score: &quot; + score);        &#125;    &#125;&#125;</code></pre><h2 id="什么是网关，网关有哪些作用？"><a href="#什么是网关，网关有哪些作用？" class="headerlink" title="什么是网关，网关有哪些作用？"></a>什么是网关，网关有哪些作用？</h2><p>网关（Gateway）是在计算机网络中用于连接两个独立的网络的设备，它能够在两个不同协议的网络之间传递数据。在互联网中，网关是一个可以连接不同协议的网络设备请求，比如说可以连接局域网和互联网，它可以把局域网和内部网络地址转换成互联网上的合法地址，从而使得局域网的主机可以与外界通信。</p><p>在计算机系统中，网关可以用于实现负载均衡，安全过滤，协议住那换等功能。具体来说，网关可以分为以下几种：</p><ol><li>应用网关：用于应用层协议的处理，如HTTP，SMTP等</li><li>数据库网关：用于数据库访问的控制和管理</li><li>通信网关：用于不同通信协议之间的数据交换，如TCP&#x2F;IP，UDP&#x2F;IP 等。</li><li>API网关：用于管理和转发API请求，实现API 的授权，限流，监控等功能</li></ol><p>总的来说，网关可以不同网络提供连接和通信的功能，同时也可以提供安全，性能，可靠性等方面的增强功能，是现代计算机不可或缺的一部分</p><h2 id="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"><a href="#线程的生命周期是什么，线程有几种状态，什么是上下文切换？" class="headerlink" title="线程的生命周期是什么，线程有几种状态，什么是上下文切换？"></a>线程的生命周期是什么，线程有几种状态，什么是上下文切换？</h2><p>线程的生命周期通常包括物种状态：新建（New），就绪（Runnable），运行（Running），阻塞（Blocked）和终止（Terminated）。其中：</p><ul><li>新建状态是指当前线程对象创建后，就进入了新建状态。此时它已经有了相应的内存空间和其他资源，但是还没有开始运行</li><li>就绪状态是指当前线程对象调用start()方法后，线程进入了就绪状态。此时它已经具备了运行的条件，只等CPU分配资源，让其开始执行</li><li>运行状态是指当线程对象获得CPU资源后，就开始执行run() 方法中的代码，线程处于运行状态</li><li>阻塞状态是指线程在特定情况下会被挂起，暂时停止执行。当线程处于阻塞状态时，它并不会占用CPU 资源</li><li>终止状态是指线程的run() 方法执行完毕或者因异常退出时，线程进入了终止状态。此时，线程不再占有CPU资源，也不再执行任何代码。</li></ul><p>在线程的生命周期中，线程状态的转换通常时由操作系统调度和控制的。当线程的状态发生变化时，需要进行上下文切换，即保存当前线程的状态和上下文信息，并恢复另一个线程的状态和上下文信息，使其能够继续执行。上下文切换会带来一定的开销，因此需要尽可能减少线程之间的切换次数。</p><h2 id="MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？"><a href="#MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？" class="headerlink" title="MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？"></a>MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</h2><p>MVCC 是指多版本并发控制（Multiversion Concurrency Control），是一种并发控制机制，常用于数据库，用于实现事务的并发控制。它允许在同一时间多个事务对同一个数据集合进行读取操作，同时防止数据不一致和其他并发问题。</p><p>InnoDB 是 MySQL 中最常用的存储引擎之一，它的MVCC 实现是通过在每行记录中添加两个隐藏的列，分别记录行的创建时间和过期时间，以此来判断事务对该行记录的可见性。当一个事务需要读取一行记录时，InnoDB首先读取这行记录的创建时间和过期时间，并根据这些信息判断该行记录是否可见。如果创建时间早于当前事务的开始时间，且过期时间晚于当前事务的开始时间，那么该行记录对当前事务可见。</p><p>在InnoDB 中，MVCC 主要是通过实现以下几个机制来实现的：</p><ol><li>事务版本号：每个事务都有一个唯一的版本号，用来标识该事务的创建时间。</li><li>读取视图：每个事务在开始的时候都会创建一个读取视图，记录该事务开始时间和其他信息。在事务执行期间，所有读取操作都要检查该视图，以确定读取哪些版本的数据</li><li>undo 日志：在事务执行期间，如果对数据进行修改，那么会先将原始数据复制一份到undo日志中。这样，在回滚操作时就可以使用undo 日志中的数据来还原原始数据。</li><li>快照读取：在某些情况下，事务需要读取一个数据的历史版本，而不是当前版本。这是可以使用快照读取来实现，即在读取事务开始时间和undo 日志来读取历史版本的数据。</li></ol><h2 id="Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？"><a href="#Redis-的持久化机制有哪些？说说各自的优缺点和应用场景？" class="headerlink" title="Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？"></a>Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？</h2><p>Redis 的持久化机制主要分为RDB 和AOF 两种</p><p>RDB 持久化机制</p><p>RDB 持久化机制是指将 Redis 在内存中的数据以快照的形式写入磁盘中，可以手动或自动执行快照操作，将数据集的状态保存到一个RDB文件中。RDB 机制的优点在于：</p><ul><li>RDB 机制适合在数据集比较大时进行备份操作，因为它可以生成一个非常紧凑，经过压缩的数据文件，对于备份，恢复，迁移数据都很方便</li><li>RDB机制在Redis 重启时比AOF 机制更快地将Redis 恢复到内存中。</li></ul><p>RDB 机制的缺点在于：</p><ul><li>RDB 机制可能会出现数据丢失，因为数据是周期性的进行备份，一旦Redis出现问题并且上一次备份之后还没有进行数据变更，那么这部分数据将会丢失</li><li>RDB 机制会造成一定的IO 压力，当数据集比较大时，进行备份操作可能会阻塞Redis服务进程</li></ul><p>AOF 持久化机制</p><p>AOF 持久化机制是指将Redis 在内存中的操作指令以追加的形式写入到磁盘中的AOF 文件，AOF 文件记录了 Redis 在内存中的操作过程，只要在Redis 重启后重新执行AOF 文件中的操作命令即可将数据恢复到内存中。AOF机制的优点在于：</p><ul><li>AOF机制比RDB 机制更加可靠，因为AOF 文件记录了Redis 执行的所有操作命令，可以确保数据不丢失。</li><li>AOF 机制在恢复大数据集时更加稳健，因为AOF文件记录了数据的操作过程，可以确保每一次操作都被正确执行</li></ul><p>AOF机制的缺点在于：</p><ul><li>AOF 机制生成的AOF 文件比RDB 文件更大，当数据集比较大时，AOF 文件会比RDB 文件占用更多的磁盘空间</li><li>AOF 机制对数据恢复的时间比RDB 机制更加耗时，因为要重新执行AOF文件中的全部命令</li></ul><p>综上所述，RDB适用于数据集较大，备份，恢复数据和迁移数据等场景，AOF适用于数据可靠性要求高，数据恢复稳健等场景。</p><h2 id="Nginx-是什么？它有哪些应用场景？"><a href="#Nginx-是什么？它有哪些应用场景？" class="headerlink" title="Nginx 是什么？它有哪些应用场景？"></a>Nginx 是什么？它有哪些应用场景？</h2><p>Nginx（发音为”engine-x”）是一个高性能的开源Web服务器和反向代理服务器，可以处理大量的并发连接和请求。它使用事件驱动的异步架构和多线程设计，可以高效的处理并发请求，同时也支持反向代理，负载均衡，动态HTTP缓存，SSL&#x2F;TLS终止，基于模块的扩展功能。</p><p>Nginx的应用场景每场广泛，以下是其中几个：</p><ol><li>Web服务器：Nginx 可以作为HTTP 服务器，处理并发的静态请求和动态请求，并且可以支持负载均衡和缓存，为网站提供高性能和高可用性</li><li>反向代理服务器：Nginx可以作为反向代理的服务器，接收客户端请求并且将其转发到后端服务器，同时也可以支持负载均衡和缓存。</li><li>邮件代理服务器：Nginx 可以作为邮件代理服务器，支持POP3，IMAP和SMTP协议，并且可以支持SSL&#x2F;TLS加密和反垃圾邮件功能</li><li>流媒体服务器：Nginx可以作为流媒体服务器，支持RTMP，HLS和DASH协议，可以用于实现直播，点播和视频-on-demand（VoD）等场景</li></ol><p>总之，Nginx具有高性能，可扩展性和可靠性等特点，被广泛应用于大型网站，互联网公司，云计算，视频流媒体，游戏等领域。</p><h2 id="Dubbo-是什么？是否了解过它的架构设计？"><a href="#Dubbo-是什么？是否了解过它的架构设计？" class="headerlink" title="Dubbo 是什么？是否了解过它的架构设计？"></a>Dubbo 是什么？是否了解过它的架构设计？</h2><p>Dubbo 是一个高性能，轻量级的开源Java RPC 框架，它提供了完整的RPC协议栈，包括服务发布，服务引用，负载均衡，容错，服务治理和服务监控等功能，同时提供了可扩展的RPC协议，数据模型，序列化和网络传输等组件，支持多语言和多协议</p><p>Dubbo 的架构设计主要包括服务提供者，服务消费者，注册中心和监控中心四个角色。其中，服务提供者提供服务的实现，并通过注册中心将自己注册到服务治理中心；服务消费者则通过注册中心发现可用的服务，并通过负载均衡策略选择一个服务提供者进行调用；注册中心主要负载服务的注册，发现和路由；监控中心则负责服务的统计和监控。</p><p>Dubbo的架构设计采用了分层架构，将不同的功能模块进行分离，以达到模块化和可扩展的目的。同时，Dubbo还提供了丰富的扩展点和插件机制，用户可以通过自定义扩展点和插件来满足不同的业务需求。</p><h2 id="synchronized-关键字是什么，有什么作用？"><a href="#synchronized-关键字是什么，有什么作用？" class="headerlink" title="synchronized 关键字是什么，有什么作用？"></a>synchronized 关键字是什么，有什么作用？</h2><p>synchronized 是 Java 中的一个关键字，用于实现线程同步。具体来说，</p><p>synchronized 用于修饰方法或代码块，使得同一时刻只能有一个线程访问被修饰的代码，其他线程需要等待当前线程执行完毕后才能访问。</p><p>synchronized 主要用于解决多线程并发访问共享资源时出现的线程安全问题。如果多个线程同时访问同一个共享资源，就会出现多个线程同时修改这个资源的情况，从而导致该数据不一致等问题。而使用 synchronized 可以保证同一时刻只有一个线程访问该资源，从而避免了线程安全问题</p><p>synchronized 的作用不仅限于线程同步，它还可以保证可见性和有序性，即保证在同一个锁上，一个线程修改了共享变量的值后，另一个线程能够立即看到修改后的值，并且在多个线程执行顺序上保持了一致性。</p><p>需要注意的是：使用synchronized 会带来一定的性能损失，因为每次进入同步块时都需要获得锁，这会增加线程的等待事件和上下文切换的开销。同时，如果同步块的代码执行时间很短，也会增加不必要的性能开销。因此，需要根据具体情况来判断是否需要使用synchronized 。</p><h2 id="如何设计一个点赞系统？"><a href="#如何设计一个点赞系统？" class="headerlink" title="如何设计一个点赞系统？"></a>如何设计一个点赞系统？</h2><p>设计一个点赞系统可以分为以下几个步骤：</p><ol><li>确定需求：需要明确点赞的对象是什么，是否需要计数等信息，同时需要考虑点赞的业务场景，如用户点赞，文章点赞等</li><li>数据库设计：需要设计点赞相关的数据表，可以包含点赞者ID，被点赞对象的ID，点赞时间等字段。</li><li>接口设计：需要设计点赞等相关的接口，包括点赞，取消点赞，查询点赞数等操作</li><li>业务逻辑实现：在接口中实现点赞相关的业务逻辑，包括判断点赞状态，更新点赞数，更新点赞状态等操作。</li><li>安全性考虑：需要考虑并发访问的情况，可以使用分布式锁来保证数据一致性和安全性</li><li>性能优化：如果点赞系统的访问量很高，可以使用缓存来提高性能，比如使用Redis 来缓存点赞等信息</li><li>监控和日志：需要对点赞系统进行监控和日志记录，以便即使发现和排查问题</li></ol><p>总之，设计一个点赞系统需要综合考虑需求，数据库设计，接口设计，业务逻辑实现，安全性，性能优化等方面，同时需要不断优化和完善。</p><h2 id="什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？"><a href="#什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？" class="headerlink" title="什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？"></a>什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？</h2><p>内部类是定义在另一个类中的类。Java 中内部类主要分为成员内部类，静态内部类，局部内部类和匿名内部类</p><ol><li>成员内部类：定义在另一个类的内部，并且与其他成员变量和方法平级，可以访问外部类的所有成员变量和方法。<strong>使用方法：Outer.Inner inner &#x3D; new Outer().new Inner().</strong></li><li>静态内部类：定义在另一个类的内部，但是要用static修饰。只能访问外部类的静态成员变量和方法：<strong>使用方法：Outer.Inner inner &#x3D; new Outer.Inner().</strong></li><li>局部内部类：定义在方法中，作用域仅限于方法内部。与局部变量类似，不能使用访问控制符修饰。<strong>使用方法：在方法中直接实例化</strong></li><li>匿名内部类：没有名字的内部类。<strong>使用方式：new接口或者抽象类(){} 或 new 父类() {}</strong></li></ol><p>内部类的优点：</p><ol><li>可以访问外部类的私有成员变量和方法</li><li>可以隐藏实现细节</li><li>便于编写和维护，提高代码的可读性和可维护性</li><li>内部类可以很好的解决Java中单继承的问题</li></ol><p>内部类的应用场景：</p><ol><li>需要访问外部类的私有成员变量和方法</li><li>需要定义一个回调函数或监听器</li><li>需要实现多重继承</li><li>需要对外部类进行扩展、</li></ol><h2 id="MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"><a href="#MySQL-覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。" class="headerlink" title="MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。"></a>MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。</h2><p>覆盖索引和联合索引是数据库中常见的两种索引类型</p><p>覆盖索引是指一个包含了所有查询需要的列的索引， 查询时可以直接从索引中渠道需要的数据，而不需要再回到表中查找，从而可以提高查询效率</p><p>联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描</p><p>最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了A，B，C三列，那么查询时只能使用A，AB 或ABC 进行匹配，而不是只是用 B 或 C 进行匹配。这是应为如果查询时使用的列不是最左前缀列，那么MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。</p><p>在实际的应用中，覆盖索引和联合索引可以结合使用，以提高查询效率。同时，使用最左前缀匹配原则可以让我们更加合理的设计索引，从而提高查询性能。</p><h2 id="Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？"><a href="#Spring-如何处理线程并发问题，ThreadLocal-你了解过吗？" class="headerlink" title="Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？"></a>Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？</h2><p>Spring 框架中处理线程并发问题的方式包括以下几种：</p><ol><li>同步关键字 synchronized：使用synchronized 关键字可以对共享资源进行加锁，从而保证多线程访问时的同步性。但是，synchronized 会对性能产生一定的影响，并且容易导致死锁等问题</li><li>Lock 接口：Lock 接口提供了比 synchronized 更加灵活的加锁方式，并且可以防止死锁问题发生。但是，Lock 接口使用相对复杂，需要手动进行加锁和解锁的操作</li><li>ThreadLocal类：ThreadLocal 类提供了线程本地变量的功能，可以让每个线程拥有自己的变量副本，从而避免了多个线程之间的共享问题。但是，ThreadLocal 类的使用需要注意内存泄漏问题</li></ol><p>关于ThreadLocal ，它是Java 中一个非常重要的类，用于实现线程本地存储，即让每个线程都拥有自己的变量副本，从而避免多个线程之间的共享问题。在Spring 框架中，ThreadLocal 类经常用于存储一些与当前线程有关的数据，例如请求上下文，用户信息等。通过将这些数据保存到ThreadLocal 对象中，可以方便的在整个应用程序中进行访问和传递，同时避免了多个线程之间的共享问题</p><p>ThreadLocal 类的使用需要注意内存泄漏问题，因为线程本地变量只有在对应的线程被回收时才会被回收，如果没有及时清理，就可能导致内存泄漏问题。因此，在使用ThreadLocal 类时，需要注意在不需要存储数据时及时调用remove() 方法清理ThreadLocal 对象中的数据</p><h2 id="什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？"><a href="#什么是-MySQL-执行计划？如何获取执行计划并对其进行分析？" class="headerlink" title="什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？"></a>什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？</h2><p>MySQL 执行计划是指MySQL 查询优化器生成的一份详细的查询执行计划，它展示了MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序，数据读取方式，使用的索引，使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。</p><p>要获取执行计划，可以在执行SQL 语句时在前面添加 explain 关键字，例如：</p><pre><code class="java">explain select * from table id = 1;</code></pre><p>这样，MySQL 会输出该查询语句的执行计划。执行计划中的各个字段含义如下：</p><ul><li>id：每个Select 子句或者是一个操作符或者是一个查询语句</li><li>select_type：查询类型，标识查询的类型（简单查询，联合查询，子查询等等）</li><li>table：查询设计的表</li><li>partitions：匹配的分区</li><li>type：访问类型，表示MySQL在表中找到所需行的方式</li><li>possible_keys：表示查询可能使用到的索引</li><li>key：实际使用到的索引</li><li>key_len：使用的索引长度</li><li>ref：列与索引的比较</li><li>rows：根据表统计信息及索引选用情况，大致估算出找到所需要的记录所需要读取的行数</li><li>filtered：返回结果的行数占总行数的比例</li><li>Extra：包含MySQL解决查询的详细信息</li></ul><p>分析执行计划时，需要注意以下几个方面：</p><ul><li>扫描行数：rows字段，表示查询所需扫描的行数，如果该值过大，说明查询效率不高，需要优化</li><li>使用索引：key字段，表示查询使用的索引，如果没有使用索引或者使用的不是最优索引，需要考虑优化</li><li>排序：Extra字段，如果查询需要使用filesort排序，说明查询效率不高，需要优化</li><li>嵌套循环：如果查询类型时 nested loop，说明查询中包含嵌套循环，也需要考虑优化</li></ul><p>通过分析执行计划，可以确定查询优化的方法和方向，提高查询效率</p><h2 id="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"><a href="#什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？" class="headerlink" title="什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？"></a>什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？请你举例说明哪些地方用到了单例模式？</h2><p>单例模式时一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式的目的是确保类的一个唯一实例，因此其他类可以轻松的从一个可知的地方访问它</p><p>单例模式的好处：</p><ol><li>节省系统资源：在系统中，如果有多个实例会造成资源浪费，而使用单例模式可以减少这种浪费</li><li>简化了对象访问，单例模式提供了一个全局访问的访问点，因此可以简化访问过程</li></ol><p>常用的单例模式实现方式有以下几种：</p><ol><li>饿汉式单例模式：在类加载时创建单例对象。缺点是不支持延迟加载。</li><li>懒汉式单例模式：在第一次使用时才创建单例对象。缺点是需要考虑线程安全问题</li><li>双重检查锁单例模式：在第一次使用时创建单例对象，并使用双重检查锁定来确保线程安全</li><li>枚举单例模式：在枚举类型中创建单例对象，可以防止反射和序列化攻击</li></ol><p>应用场景：</p><ol><li>数据库连接池：通过使用单例模式，可以确保系统中只有一个数据库连接池</li><li>日志记录器：可以使用单例模式记录系统日志，这样可以确保系统中只有一个日志记录器</li><li>配置文件管理器：可以使用单例模式来管理应用程序的配置文件，这样可以避免重复读取配置文件的开销</li><li>线程池：可以使用单例模式来确保系统中中只有一个线程池</li></ol><p>一个例子时Spring 框架中 ApplicationContext ，它是一个全局访问点，提供了一个管理Bean 的中央注册表。由于 Spring 中的 Bean 只需要创建一次，因此ApplicationContext 使用单例模式确保只有一个实例。</p><h2 id="什么是云原生？它有哪些优缺点？"><a href="#什么是云原生？它有哪些优缺点？" class="headerlink" title="什么是云原生？它有哪些优缺点？"></a>什么是云原生？它有哪些优缺点？</h2><p>云原生是一种开发和运行应用程序的方法，旨在利用云计算的弹性，可扩展性，可靠性和高可用性等优势。它通过将应用程序打包到容器中，使用容器编排工具进行管理，实现了应用程序在不同环境中的快速部署，弹性伸缩和高可用性</p><p>云原生的优点包括：</p><ol><li>灵活性和可扩展性：容器可以快速部署和扩展，以满足不同负载要求</li><li>高可用性：容器编排工具可以自动检测和恢复容器故障，提供高可用性</li><li>效率和成本优化：使用容器可以节省资源和成本，提高应用程序的运行效率</li><li>安全性：容器隔离应用程序的运行环境，减少了安全漏洞的风险</li></ol><p>云原生的缺点：</p><ol><li>学习曲线较陡峭：云原生技术较为复杂，需要学习一些新技术和工具</li><li>可能存在依赖问题：应用程序可能依赖于某些特定的云原生技术或工具，这可能导致一些限制或局限性。</li><li>管理和维护难度：容器编排工具可能需要额外的管理和维护，需要更多的操作和维护成本</li></ol><p>云原生的应用场景包括：</p><ol><li>微服务架构：云原生技术非常适合构建微服务框架，将应用程序拆分为小型，自治的服务</li><li>弹性伸缩：云原生技术可以根据应用程序的负载自动扩展或缩小容器数量，以适应不同负载要求</li><li>快速部署：使用云原生技术，可以快速的部署和更新应用程序，提高开发和部署效率</li><li>多云部署：云原生技术可以在多个云环境中运行，方便应用程序在不同云环境中的部署和迁移</li><li>数据分析和处理：云原生技术可以处理大规模的数据和分析任务，提高数据处理效率</li></ol><h2 id="TCP-和-UDP-协议有什么区别，分别适用于什么场景？"><a href="#TCP-和-UDP-协议有什么区别，分别适用于什么场景？" class="headerlink" title="TCP 和 UDP 协议有什么区别，分别适用于什么场景？"></a>TCP 和 UDP 协议有什么区别，分别适用于什么场景？</h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常用的传输层协议，它们有以下区别：</p><ol><li><strong>连接方面</strong>：TCP是面向连接的协议，而UDP是无连接协议。在TCP 中，发送方和接收方必须先建立连接，然后才能传输数据。UDP 则不需要建立连接，直接发送数据即可</li><li><strong>可靠性</strong>：TCP 保证数据传输的可靠性，通过序列号，确认应答和重传机制等方式来保证数据的完整性和正确性。UDP则不保证数据传输的可靠性，因为它不提供确认和重传机制</li><li><strong>传输速度</strong>：因为TCP 要保证数据传输的可靠性，所以在传输速度方面相对较慢。而UDP则不需要进行复杂的传输控制，因此传输速度更快</li><li><strong>传输内容</strong>：因为TCP 是一种面向字节流的协议，将数据看作是一连串的字节流，没有明确的边界消息。UDP 则是面向报文的协议，将数据看作是一系列的报文，每个报文是一个独立的单元，具有明确的消息边界</li></ol><p>基于以上特点，TCP 和 UDP 适用于不同场景。TCP 适用于对传输可靠性要求比较高的场景，例如网页浏览，文件传输，邮件等。而UDP则适用于对传输可靠性要求较低，传输速度要求较高的场景，例如在线游戏，视频直播等</p><h2 id="什么是分布式的-CAP-理论？"><a href="#什么是分布式的-CAP-理论？" class="headerlink" title="什么是分布式的 CAP 理论？"></a>什么是分布式的 CAP 理论？</h2><p>分布式的CAP 理论是指在分布式系统中，一致性（Consistency），可用性（Availability）和分区容错性（Parttion Tolerance）这三个指标无法同时满足的问题。具体来说：</p><ul><li><strong>一致性</strong>（Consistency）：指多个副本之间数据保持一致，即在一个副本上的写操作会立刻同步到其他所有副本，所有副本的数据都是最新的，保持强一致性</li><li><strong>可用性</strong>（Availability）：指系统在任何时候都能对外提供服务，即系统随时能够响应用户请求，不会因为节点故障或其他原因导致服务中断</li><li><strong>分区容错性</strong>（Partition Tolerance）：指系统在出现网络分区（节点之间失去联系）时，仍能够继续工作，保证数据的一致性和可用性</li></ul><p>CAP 理论指出，一个分布式系统只能同时满足其中的两个指标，无法同时满足三个。例如：当出现网络分区时，如果包保证一致性，就必须停止对外服务，从而失去可用性；如果要保证可用性，就必须放弃一致性，从而可能导致不同节点之间数据不一致。因此，在设计分布式系统时，需要根据具体的场景和需求来选择合适的权衡方案，比如选择CP（一致性和分区容错性）或者选择AP（可用性和分区容错性）</p><p>需要注意的是：CAP 理论知识一种理论框架，不能直接应用于实际的分布式系统设计。在实际应用中，还要考虑系统的具体业务需求，数据访问模式，节点规模和部署环境等因素，综合权衡之后再选择合适的分布式框架和技术方案。</p><h2 id="如何用-Redis-实现分布式-Session？"><a href="#如何用-Redis-实现分布式-Session？" class="headerlink" title="如何用 Redis 实现分布式 Session？"></a>如何用 Redis 实现分布式 Session？</h2><p>在分布式系统中，通常会将Session 存储在Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享Session数据。实现分布式Session 的方式有多种，其中一种常用的方式是使用Redis 的数据结构Hash 。具体的实现步骤如下：</p><ol><li>在用户登录成功后，将Session 数据存储在 Redis中</li><li>将Redis 的Session 数据 Key 设置为一个全局唯一的 ID，一般使用类似于“ session : token ”的格式，其中token是一个随机生成的字符串，用来表示这个Session 数据</li><li>在客户端返回响应的同时，将Session ID（即token）以Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个Cookie</li><li>在后续请求中，服务器会从客户端传递过来的Cookie 中获取 Session ID ，然后根据这个 ID 从 Redis 中获取对应的Session 数据。如果Redis 中没有找到对应的Session 数据，那么就表示这个请求无法通过认证</li><li>在用户退出登录或 Session 失效时，需要将Redis 中对应的Session 数据删除</li></ol><p>可以使用Redis 的EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的Session数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的Session ID等方式来提高安全性</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题1</title>
      <link href="/2022/03/01/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
      <url>/2022/03/01/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-和-JRE-和-JVM-分别是什么，有什么区别？"><a href="#JDK-和-JRE-和-JVM-分别是什么，有什么区别？" class="headerlink" title="JDK 和 JRE 和 JVM 分别是什么，有什么区别？"></a>JDK 和 JRE 和 JVM 分别是什么，有什么区别？</h2><p>1，**JDK (Java Development Kit)**：JDK是Java开发工具包，包含了编写，编译，调试和运行java程序所需要的所有工具和组件，比如编译器（javac），javaAPI，调用工具等。JDK是针对Java开发人员的，它包含JRE，还有一编译器和其他工具，可以用来编写和调试Java程序。</p><p>2，**JRE (Java Runtime Environment)**：JRE是java运行时环境，包括了Java虚拟机（JVM）和Java标准类库（JavaAPI）JRE是争对Java应用程序的，它提供了在计算机上运行的Java应用程序所需的最小环境。</p><p>3，**JVM (Java Virtual Machine)**：JVM是Java虚拟机，是Java程序运行的环境。JVM负责将java代码解释或编译为本地机器代码，并在运行时提供必要的环境支持，比如内存管理，垃圾回收，安全新等。JVM的主要作用时将Java代码转化为可以在计算机上运行的机器码，并负责程序的执行。</p><p>综上所述，JDK，JRE和JVM在区别上可以总结如下：</p><p><strong>JDK时Java开发工具包</strong>，包括了编译器，JavaAPI，调试工具等，用于Java开发应用程序</p><p><strong>JRE是Java运行时环境</strong>，包括了Java虚拟机和Java标准类库，用于在计算机上运行Java应用程序</p><p><strong>JVM是Java虚拟机</strong>，是Java程序运行的环境，负责将java代码转换为可以在计算机上运行的机器码，并提供必要的环境支持</p><h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>字节码是Java程序编译后的中间代码，是一种可移植的二进制代码，可以在任何支持Java虚拟机（JVM）的平台上运行。字节码通过Java源代码编译为字节码指令序列，使得Java程序可以跨平台运行，即使在不同的操作系统和硬件平台上也可以运行。</p><p>字节码采用中间代码的形式，相比于直接将程序编译为特定平台上的机器码，有以下几个好处</p><ol><li>可移植性：由于字节码是中间代码，所以可以在任何支持JVM的平台上运行，使得Java程序具有很好的可移植性。这也是Java跨平台的重要特征之一。</li><li>安全性：由于字节码需要在JVM中运行，所以可以对字节码进行安全检查，以确定程序不会对系统造成威胁。</li><li>性能：由于字节码是一种紧凑的二进制格式，相比于直接编译为机器码，可以更快速的加载和传输，同时也可以在运行时动态优化，提高程序的执行效率。</li><li>可读性：相比于直接编译为机器码，字节码具有更好的可读性，可以方便的进行反汇编和调试</li></ol><p>因此，采用字节码作为中间代码的最大好处是提高了Java程序的可移植性，安全性，性能和可读性。这也是Java跨平台和安全性的基础</p><h2 id="什么是数据库事务？讲一下事务的-ACID-特性？"><a href="#什么是数据库事务？讲一下事务的-ACID-特性？" class="headerlink" title="什么是数据库事务？讲一下事务的 ACID 特性？"></a>什么是数据库事务？讲一下事务的 ACID 特性？</h2><p>数据库事务是指数据库管理系统DBMS中的一个操作序列，这些操作必须作为一个不可分割的单元执行，要么全部执行成功，要么全部失败回滚。事务通常涉及到对数据库中的数据进行读写操作。</p><p>事务的ACID特性是指其四个关键特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）</p><ol><li>原子性：事务是一个原子操作，要么全部提交，要么全部回滚。当一个事务执行期间发生故障，操作系统便会自动将其回滚到事务执行之前的状态，保证数据的一致性。</li><li>一致性：事务执行结束后，数据必须保持一致的状态。在事务执行期间，数据库的数据可以处于中间状态，但是在事务完成时必须保持数据的一致性。</li><li>隔离性：数据库系统必须保证事务之间的相互隔离，不会相互干扰。隔离级别不同，会影响事务的并发性和一致性，比如出现脏读，不可重复读，幻读等。</li><li>持久性：一旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发生故障或者宕机，数据也能够保持不变。</li></ol><p>ACID特性是保证事务正确性和数据一致性的重要手段。在设计数据库应用程序时，应该根据具体的业务需求和数据库安全性要求，选择合适的隔离级别和事务提交策略，保证事务的可靠性和数据的一致性。</p><h2 id="Java-和-C-、Go-语言的区别，各自的优缺点？"><a href="#Java-和-C-、Go-语言的区别，各自的优缺点？" class="headerlink" title="Java 和 C++、Go 语言的区别，各自的优缺点？"></a>Java 和 C++、Go 语言的区别，各自的优缺点？</h2><p><strong>Java是一种面向对象的编程语言</strong>，醉蛛被设计用于开发嵌入式系统，现在广泛应用于企业应用，Web应用和移动应用开发等领域。Java优点包括：</p><ol><li>跨平台性强：Java虚拟机（JVM）可以在不同操作系统上运行java程序，使得开发者可以编写一次代码并在多个平台上运行</li><li>安全性高：Java有很多安全特征，例如自动内存管理，类的访问权限控制，异常处理等，可以有效避免一些常见安全漏洞</li><li>生态系统完备：Java的生态系统非常完善，有很多成熟的框架和工具可以帮助开发者快速构建复杂的应用</li></ol><p><strong>C++是一种系统级编程语言</strong>，最初设计用于操作系统和系统软件的开发，现在也广泛用于游戏，图形图像处理，嵌入式系统等领域。C++的优点包括：</p><ol><li>新能高：C++是一种编译型语言，可以生成高效的机器代码，所以在处理大量数据和对计算效率又要求的应用场合下具有优势</li><li>控制能力强：C++具有非常高的控制能力，可以直接操作计算机的硬件和内存等资源</li><li>应用领域广泛：C++适用于开发大型系统，高性能应用和底层软件，如操作系统，数据库，游戏引擎等</li></ol><p><strong>Go是一种开源的编程语言</strong>，由Google公司开发，被设计用于开发高并发，分布式系统。Go的优点包括：</p><ol><li>并发能力强：Go具有轻量级的线程（goroutine）基于消息传递的通道（channel），可以方便地实现并发编程</li><li>内存管理高效：Go的内存管理采用自动垃圾回收装置，使得开发者可以更加专注于业务逻辑</li><li>语言特性简单：Go的语法简单易懂，代码易于阅读和维护，同时提供了丰富的标准库和工具支持</li></ol><h2 id="什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？"><a href="#什么是-Redis？Redis-有哪些特点？Redis-有哪些常见的应用场景？" class="headerlink" title="什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？"></a>什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？</h2><p>Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，也被称为数据结构等服务。它支持多种类型的数据结构，如字符串，哈希，列表，集合，有序集合等，并提供了丰富的操作这些数据结构的命令。</p><p>Redis的特点包括：</p><ol><li>高性能：Redis使用内存来存储数据，并且数据存储在单一进程中，因此速度非常快</li><li>多样的数据类型：Redis支持多种数据结构，包括字符串，哈希，列表，集合，有序集合等。</li><li>持久化：Redis支持多种持久化方式，包括RDB快照和AOF日志</li><li>分布式：Redis支持分布式部署，可以将数据分布在多个节点上</li><li>简单易用：Redis提供了丰富的命令，使得操作数据非常方便</li></ol><p>Redis的常见应用场景包括：</p><ol><li>缓存：Redis可以作为缓存使用，加速数据读取和响应速度</li><li>消息队列：Redis提供了列表和发布&#x2F;订阅功能，可以用来实现消息队列</li><li>计算器：Redis的计算器功能非常高效，可以用来实现页面访问量，点击量等的·计数</li><li>排行榜：Redis的有序集合功能可以用来实现排行榜</li><li>分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问</li><li>实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析的速度</li></ol><p>总之，Redis具有高性能，多样的数据类型，分布式，简单易懂等特点，可以应用于各种场景，特别适合用于解决读写频繁的问题</p><h2 id="简述计算机网络七层模型和各自的作用？"><a href="#简述计算机网络七层模型和各自的作用？" class="headerlink" title="简述计算机网络七层模型和各自的作用？"></a>简述计算机网络七层模型和各自的作用？</h2><p>计算机网路七层模型是一个把网络通信协议分为七个层次的标准模型，其目的是为了让计算机网络的设计和管理更加灵活和模块化。这个模型被称为OSI模型（Open System Interconnection Model）,它由国际标准话组织（ISO）于1984年发布，是一个开放的标准模型。</p><p>每个层次都有自己独立功能和责任，这种分层的方式使得每个层次都可以独立工作，同时还能够很好地协调上下层之间的数据传输，而不需要依赖于其他层次的实现细节。以下是每个层的具体功能和责任：</p><ol><li>物理层：主要负责通过物理媒介传输比特流，如光纤，电缆，无线电波等。物理层规定了物理连接的规范，包括电缆类型，接口规范等</li><li>数据链路层：主要负责把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配，数据流量控制，错误校验等</li><li>网络层：主要负责数据在网络中的传输，包括路由选择，分组转发，数据报文的封装等。网络层还处理数据包的寻址和控制流量等</li><li>传输层：主要负责数据传输的可靠性和流量控制等，同时还包括分段，组装，连接建立和断开等功能。传输层最重要的两个协议是TCP和UDP</li><li>会话层：主要负责建立，管理和终止会话，提供会话控制和同步等服务。会话层层还负责处理多个应用程序之间的数据交换。</li><li>表示层：主要负责数据格式转换，加密解密，压缩解压等服务。表示层使得应用程序可以使用不同数格式和编码，同时还提供数据的安全性和完整的保护服务</li><li>应用层：主要提供各种服务和应用程序，如电子邮件，文件传输，远程登录，Web浏览等，应用层服务可以使用不同协议实现，如HTTP，SMTP，FTP，TELNET等</li></ol><p>现在较为常用的是TCP&#x2F;IP模型，它包含四层：应用层，传输层，网路层和数据链路层。</p><h2 id="JDK-动态代理和-CGLIB-动态代理的区别是什么？"><a href="#JDK-动态代理和-CGLIB-动态代理的区别是什么？" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理的区别是什么？"></a>JDK 动态代理和 CGLIB 动态代理的区别是什么？</h2><p>JDK动态代理和CGLIB动态代理都是Java中动态代理的两种实现方式，它们的区别主要在以下几个方面：</p><ol><li>实现方式：JDK动态代理是通过<strong>反射</strong>实现的，而CGBIL动态代理是通过<strong>继承目标类</strong>来实现的</li><li>目标类限制：JDK动态代理要求目标类必须<strong>实现接口</strong>，而CGBIL动态代理没有这个限制</li><li>性能：JDK动态代理相对于CGBIL动态代理来说，因为实现方式的不同，生成的代理效率会低一些</li><li>对象类型：JDK动态代理只能代理实现了接口的类，而CGBIL动态代理可以代理任何类</li><li>依赖库：JDK动态代理是Java自带的库，不需要额外的依赖，而CGBIL动态代理需要依赖cglib库</li></ol><p>在使用动态代理时，可以根据需要和具体场景选择合适的实现方式，JDK动态代理适用于接口代理的场景，而CGBIL动态代理适用于类代理场景</p><h2 id="MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用"><a href="#MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用" class="headerlink" title="MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用"></a>MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用</h2><p>MySQL是一款流行的关系型数据库，其日志是关键功能之一。MySQL包括三种类型的日志：binlog，redolog和undolog，它们分别有各自的作用和特点。</p><ol><li>binlog（Binary log）：MySQL种的二进制日志文件，用于记录MySQL服务器上所有的更新和修改操作。它可以记录所有的DDL（Data Definition Language）和DML（Data Modification Language）操作，包括对表结构的更改，数据的插入，修改，删除等等。binlog是在事务提交后生成的，因此可以用于恢复数据库。</li><li>redolog（Redo log）：用于恢复数据，保证数据的一致性和持久性。当MySQL发生修改时，redolog会将这些操作记录下来，并写入磁盘。这样，当MySQL发生宕机或崩溃时，通过redolog就可以回复数据。</li><li>undolog（Undo log）：用于回滚操作，当MySQL发生事务回滚时，undolog会记录这些操作并写入磁盘。这样，当MySQL需要回滚时，通过重放undolog就可以回滚事务。</li></ol><p>区别：</p><p>​binlog和redolog都是MySQL中的二进制日志，但是它们的作用和实现方式有所不同。binlog是MySQL操作的记录日志，而redolog是保证数据一致性和持久性的日志。此外，binlog是逻辑日志，redolog是物理日志。binlog可以跨平台使用，而eredolog不行。undolog和redolog区别是：undolog用于回滚操作，redolog用于回复数据。</p><h2 id="Spring-框架是什么？使用-Spring-框架有哪些好处？"><a href="#Spring-框架是什么？使用-Spring-框架有哪些好处？" class="headerlink" title="Spring 框架是什么？使用 Spring 框架有哪些好处？"></a>Spring 框架是什么？使用 Spring 框架有哪些好处？</h2><p>Spring框架是一个开源的Java企业应用程序框架，它通过依赖注入（DI：Dependency Injection）和面向切面编程（Aspect Oriented Proframming）等技术为开发者提供了一个全面的编程和配置模型。它可以降低Java开发的复杂度，提高代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。</p><p>使用Spring框架有以下好处：</p><ol><li>依赖注入（DI）：通过Spring框架的依赖注入功能，开发者可以将应用程序中的不同组件之间的依赖关系交给Spring来管理，从而降低组件之间的耦合度，并方便后续的组件替换和维护。</li><li>支持切面编程（AOP：Aspect Oriented Programming）：Spring框架提供了面向切面编程的支持，可以将不同组件关联起来，从而降低了应用程序中的重复代码量，并提高了代码的可重用性和可维护性。</li><li>提供了多种技术整合方案：Spring框架可以与其他的Java企业引用程序框架和技术进行整合，如Hibernate，Mybatis，Struts，JSF等，从而降低了技术整合的复杂度</li><li>支持声明式事务管理：Spring框架提供了声明事务管理的支持，开发者可以通过配置来管理应用程序中的事务，从而简化了事务管理的过程。</li><li>提供了Ioc容器：Spring框架提供了一个Ioc容器，可以实现对应程序的不同组件进行管理，并支持对组件进行AOP增强，从而实现了应用程序中的组件解耦和高度可配置性。</li><li>便于配置：Spring框架可以方便的进行单元测试和集成测试，提高了代码的可测试性和可靠性</li></ol><h2 id="Java-中-final-关键字有什么用"><a href="#Java-中-final-关键字有什么用" class="headerlink" title="Java 中 final 关键字有什么用"></a>Java 中 final 关键字有什么用</h2><p>在Java中，final关键字用于表示一个不可变的常量或一个不可变的变量，final关键字开源修饰类、方法和变量</p><ol><li>final修饰类，表示该类不能被继承。final类中的方法都是默认final，不能被子类重写</li><li>final修饰方法，表示该方法不能被子类重写</li><li>final修饰变量，表示该变量只能被赋予一次。final修饰的变量必须在申明时或构造函数中初始化，且不能再被改变。常用于定义变量。</li></ol><p>除此之外，使用final修饰的变量在编译时就确定了其值，因此在运行时访问比非final变量更快</p><p>使用final关键字可以带来的好处：</p><ol><li>安全性：将变量声明为final可以防止它被改变，从而提高安全性</li><li>可读性：将常量声明为final可以提高代码的可读性，因为常量的值不会被改变</li><li>优化：final变量在编译时被转变为常量，这可以提高程序的性能</li></ol><h2 id="HTTP-是哪一层的协议？简述它的作用？"><a href="#HTTP-是哪一层的协议？简述它的作用？" class="headerlink" title="HTTP 是哪一层的协议？简述它的作用？"></a>HTTP 是哪一层的协议？简述它的作用？</h2><p>HTTP是应用层协议，主要用于Web浏览器和Web服务器之间的传递数据。它是一种无状态的协议，即服务器不会保存关于客户端的任何信息，每次客户端发送请求，服务器都会返回响应。HTTP协议通常基于TCP协议，使用TCP的80端口作为默认的传输端口。HTTP协议主要作用包括：</p><ol><li>建立连接：客户端与服务器建立TCP链接，然后发送HTTP请求，服务器接收请求并处理</li><li>发送请求：客户端发送HTTP请求到服务器，包括请求方法（GET，POST，PUT等），请求头（如User-Agent，Accept等）和请求正文（可选）等信息。</li><li>请求处理：服务器接收并解析HTTP请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端</li><li>返回响应：服务器返回HTTP响应，包括响应状态码（如200 OK，404 Not Found等），响应头（如Content-Type,Cache_Control等）和响应正文（可选）等信息。</li><li>关闭连接：客户端接收到响应后，关闭TCP连接</li></ol><p>HTTP的响应报文主要包括以下几个部分：</p><ol><li>状态行：包含HTTP协议版本，状态码和状态消息。</li><li>响应头：包含一些响应头部信息，例如Server，Control-Type，Content_Length等</li><li>空行：表示响应头结束</li><li>响应体：实际响应数据，例如网页的HTML代码，图片，音频等。</li></ol><p>HTTP的状态码指示了服务器对请求的处理结果。常见的状态码包括200 OK（请求成功），301 MovedPermanently（永久重定向），404 Not Found（未找到资源）和500 Internal Server Error（服务器内部错误）等</p><p>总之，HTTP协议的作用是规定了Web应用程序中客户端和服务器之间的通讯方式和数据传输格式，是支持Web应用开发的基础协议。</p><h2 id="什么是进程和线程？它们有哪些区别和联系？"><a href="#什么是进程和线程？它们有哪些区别和联系？" class="headerlink" title="什么是进程和线程？它们有哪些区别和联系？"></a>什么是进程和线程？它们有哪些区别和联系？</h2><p>在操作系统中，<strong>进程是指一个正在执行的程序</strong>，而<strong>线程是进程的一部分，是一个程序中执行的代码片段</strong></p><p><strong>进程是操作系统资源分配的最小单位</strong>，一个进程至少包括一个线程，进程拥有自己的内存空间，文件句柄，环境变量等资源系统。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通讯需要通过进程间通信机制（IPC）来实现</p><p><strong>线程是程序执行的最小单位</strong>，一个进程中可以包含多个线程，它们共享进程的内存空间和资源系统。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通讯可以通过共享内存，信号量等机制实现</p><p>进程与线程的区别与联系如下：</p><ol><li>资源分配：进程拥有自己的内存空间等系统资源，而是线程共享进程的资源</li><li>独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源</li><li>调度：进程间调度开销比线程大，线程调度开销小，可以并发执行</li><li>并发性：多个进程之间相互独立，多个线程可以并发执行</li><li>同步：进程间通讯需要通过IPC机制，线程间同步可以通过共享内存，信号量等机制实现、</li></ol><p>实际开发中，多线程应用更加常见，因为线程开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。</p><h2 id="Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？"><a href="#Java-中-hashCode-和-equals-方法是什么？它们和-x3D-x3D-各有什么区别？" class="headerlink" title="Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？"></a>Java 中 hashCode 和 equals 方法是什么？它们和 &#x3D;&#x3D; 各有什么区别？</h2><p>在Java中mhashCode和equals方法都是Object类的方法。它们作用如下：</p><p>hashCode方法返回对象的哈希码，用于支持基于哈希表的集合，如HashMap，HashSet等。如果两个对象的equals方法返回true，则它们的hashCode方法必然返回相同的值，反之则不必然</p><p>equals方法用于比较对象是否相等。默认情况下，equals方法使用的是 &#x3D;&#x3D; 操作符，即只有两个对象引用指向同一个对象时才会返回true。但是，大部分情况下，我们需要重写equals方法来实现自己定义的相等规则。</p><p>两者之间的区别在于hashCode方法返回的是一个int类型的数值，而equals方法返回的是一个boolean类型的值。</p><p>hashCode方法用于快速比较两个对象是否不同，毕竟如果哈希码不同，那么它们肯定不相等。equals方法用于判断两个对象是否真正相等，这个判断比较复杂，需要根据对象的实际情况来定义</p><p>另外，需要注意的是， &#x3D;&#x3D; 操作符用于比较两个对象的引用是否相等，即它们是否指向同一个对象，而equals方法则用于比较两个对象的值是否相等</p><p>在Java中，对象值的比较往往需要更具对象实际情况来定义，因此一般需要重写equals方法</p><h2 id="Spring-的两大核心概念是什么？简单讲一下你对它们的理解"><a href="#Spring-的两大核心概念是什么？简单讲一下你对它们的理解" class="headerlink" title="Spring 的两大核心概念是什么？简单讲一下你对它们的理解"></a>Spring 的两大核心概念是什么？简单讲一下你对它们的理解</h2><p>Spring 框架的两大核心概念是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）</p><p><strong>控制反转</strong>指的是将对象的创建和依赖注入由应用代码转移到Spring容器中进行，即由Spring容器负责创建对象和管理它们之间的依赖关系。这样，应用代码只需要关注业务逻辑的实现，而不是关注对象的创建和管理，降低了应用代码的复杂度，提高了代码的可重用性和可维护性。</p><p><strong>面向切面编程</strong>是指将业务逻辑无关的代码（如日志，安全，事务等）从业务逻辑中剥离出来，以便于统一管理和维护。通过AOP，我们可以将这些业务逻辑无关的横切关注点（Cross-cutting Concerns）定义切面（Aspect），并将它们织入到业务逻辑中，从而实现了业务逻辑与横切关注点的解耦</p><p>这两个概念是Spring框架的核心，它们使得Spring框架具有了高度的可用性，灵活性和模块性，极大的提高了应用程序的开发效率和代码的可维护性</p><h2 id="死锁是什么？如何预防和避免死锁？"><a href="#死锁是什么？如何预防和避免死锁？" class="headerlink" title="死锁是什么？如何预防和避免死锁？"></a>死锁是什么？如何预防和避免死锁？</h2><p>死锁是指两个或多个进程在执行过程中因争夺资源而造成的一种僵局，当进程处于死锁状态时，它们将无法继续执行，而只能相互等待，直到被外部程序干预或者自行放弃。</p><p>预防和避免死锁需要采取一些措施，包括：</p><ol><li><strong>避免资源独占</strong>：尽量避免一个进程在获得了某些资源后再次请求其他资源，而采取应用所需资源一次性申请到位。</li><li><strong>避免资源持有和等待</strong>：当一个进程占用了一些资源并等待另一些资源时，其他进程就无法使用这些资源，容易发送死锁。因此，尽可能减少资源的持有和等待时间。</li><li><strong>避免资源互斥</strong>：有些资源在同一时间只能被一个进程占用，比如打印机，磁带机等，需要采用一些技术手段来避免资源的互斥问题。</li><li><strong>引入资源掠夺策略</strong>：当一个进程请求的资源被其他进程占用时，可以采取掠夺资源的策略，即暂停占用该资源的进程，直到该资源被释放后再恢复该进程的执行。</li><li><strong>引入进程抢占策略</strong>：当一个进程等待时间过长时，可以采取抢占其他资源的策略，即终端正在执行的进程，强制释放其占用的资源</li></ol><p>以上是一些避免和预防死锁的方法，具体选择哪种方法需要根据具体情况进行分析和判断。</p><h2 id="什么是反射机制？说说反射机制的优缺点、应用场景？"><a href="#什么是反射机制？说说反射机制的优缺点、应用场景？" class="headerlink" title="什么是反射机制？说说反射机制的优缺点、应用场景？"></a>什么是反射机制？说说反射机制的优缺点、应用场景？</h2><p>Java反射机制是指在运行时动态的获取了类的信息、创建对象以及调用对象的属性和方法的机制。Java反射机制提供了运行时检查Java类信息的能力，让Java程序可以通过程序获取其本身的信息。</p><p>Java反射机制的优点：</p><ol><li>可以动态的获取类的信息，不需要在编译时就知道类的信息</li><li>可以动态的创建对象，不需要在编译时就知道对象的类型</li><li>可以动态的调用对象的属性和方法，可以在运行时动态的改变对象的行为</li></ol><p>Java反射机制的缺点：</p><ol><li>由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性</li><li>由于反射是动态的，所以它会破坏Java的封装性，可能会使代码变得复杂和不稳定</li></ol><p>Java反射机制的应用场景：</p><ol><li>动态代理。动态代理可以使用反射机制在运行时动态的创建代理对象，而不需要在编译时就知道接口的实现类</li><li>单元测试。JUnit等单元测试框架可以使用在反射机制在运行时动态的获取类的方法信息，实现自动化测试</li><li>配置文件加载。许多框架（如Spring）使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。</li></ol><h2 id="数据库索引是什么，有什么作用，什么场景适合使用索引？"><a href="#数据库索引是什么，有什么作用，什么场景适合使用索引？" class="headerlink" title="数据库索引是什么，有什么作用，什么场景适合使用索引？"></a>数据库索引是什么，有什么作用，什么场景适合使用索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大的提高数据检索的效率。</p><p>索引的作用是通过构建一个额外的数据结构（B-tree，哈希表等）来加速数据的检索。它是在数据库表上查询的一种数据结构，它包含一些指向表中数据的指针，可以快速定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列缩影，组合缩影，全文索引等待多种方式来创建</p><p>适合使用索引的场景包括：</p><ol><li>频繁查询的列，如主键，外键等。</li><li>经常作为查询条件的列，如WHERE，ORDER BY，GROUP BY等语句中的列。</li><li>经常需要连接的列，如多表联合查询时的列</li><li>数据量较大的表，通过索引可以加快数据的检索速度</li></ol><p>索引的优点是可以提高数据库的查询速度，缩短数据检索的时间，提高系统的性能。但是索引也有缺点：</p><ol><li>占用额外的存储空间，增加了存储成本</li><li>建立索引需要时间，增加了系统的开销</li><li>数据库的更新操作（增删改）会导致索引的重建，避免过度索引导致系统性能下降</li></ol><h2 id="HTTP-有哪些常见的状态码？"><a href="#HTTP-有哪些常见的状态码？" class="headerlink" title="HTTP 有哪些常见的状态码？"></a>HTTP 有哪些常见的状态码？</h2><p>HTTP（超文本传输协议）常见的状态码有以下几种：</p><ul><li><p>1XX（信息类状态码）：指示已经收到请求，正在继续处理</p></li><li><p>2XX（成功状态码）：请求已经被接收，理解和接受</p><ul><li>200 OK：请求已经成功处理</li><li>201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li><li>204 No Content：服务器依据成功处理了请求，但是没有返回任何实体内容</li></ul></li><li><p>3XX（重定向状态码）：需要镜像附加操作以完成请求</p><ul><li>301 Moced Oermanently：请求的网页已永久移动到新位置</li><li>302 Found：请求的网页已经临时移动到新的位置</li><li>304 Not Modified：客服端发送了一个带条件的请求，服务器允许请求访问资源，但是请求为满足条件</li></ul></li><li><p>4XX（客户端错误状态码）：请求包含错误语法或不能被执行</p><ul><li>400 Bad Request：请求报文存在语法错误</li><li>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息</li><li>403 Forbidden：表示对请求资源的访问被服务器拒绝</li><li>404 Not Found：请求的资源不存在。</li></ul></li><li><p>5XX（服务器错误状态码）：服务器在处理请求的过程中发生了错误</p><ul><li>500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。</li><li>502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效请求。</li><li>503 Service Unavailable：服务器暂时处于超负荷或正在停机维护，无法处理请求</li></ul></li></ul><p>状态码是服务器读客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理</p><h2 id="访问修饰符-public、private、protected，以及无修饰符（默认）时的区别"><a href="#访问修饰符-public、private、protected，以及无修饰符（默认）时的区别" class="headerlink" title="访问修饰符 public、private、protected，以及无修饰符（默认）时的区别"></a>访问修饰符 public、private、protected，以及无修饰符（默认）时的区别</h2><p>在Java中，访问修饰符指的是控制类，接口，方法，属性等成员的访问范围。Java提供了四种访问修饰符，分别是public，private，protected和默认（无修饰符）</p><ul><li>public：可以被任何类或对象访问</li><li>private：只能被定义该成员的类访问，其他类无法访问</li><li>protected：可以被当前类，子类和同一个包中的类访问</li><li>默认（无修饰符）：可以被同一个包中的类访问</li></ul><p>各个修饰符的特点：</p><ul><li>public可以被任何类或对象访问，因此其访问范围最大，但也可能会存在安全问题。</li><li>private限制了访问范围，可以有效保护数据的安全，但是可能会增加代码的耦合度</li><li>protected提供了一种在继承中使用的访问控制方式，但是可能会导致模块间的耦合</li><li>默认（无修饰符）访问范围比protected更小，只能被同一个包中的类访问，可以减小模块间的耦合</li></ul><p>访问修饰符的选择需要根据具体情况来考虑，不能一概而论。通常情况下，应该尽可能的将成员设置为private，只在需要的情况下使用 public 或 protected</p><p>在同一个类中，成员可以直接访问其他成员，无论其访问修饰符是什么</p><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p>线程间通信是多线程编程中非常重要的一个概念。在多线程编程中，有时候需要让线程之间进行数据交换，协作工作。以下是几种线程间的通信方式：</p><ol><li>共享内存：线程之间通过访问同一块共享内存区域来实现数据交换</li><li>消息队列：一个线程向消息队列中放入一条消息，另一个线程从消息队列中取出消息。</li><li>管道（Pipe）：管道是一种半双工的通信方式，一个进程可以向管道中写入数据，另一个进程可以从管道中读取数据</li><li>信号（Signal）：信号是一种异步通信的方式，进程收到信号后，会根据信号的类型做出相应的处理</li><li>互斥锁（Mutex）：用于同步访问共享资源，防止多个线程同时访问共享资源，产生冲突</li><li>条件变量（Condition Variable）：用于线程之间的协调和通信，一个线程可以通过条件变量等待某个·条件的出现，另一个线程可以通过条件变量通知正在等待的线程</li></ol><h2 id="什么是分布式？为什么需要分布式？"><a href="#什么是分布式？为什么需要分布式？" class="headerlink" title="什么是分布式？为什么需要分布式？"></a>什么是分布式？为什么需要分布式？</h2><p>分布式是指在堕胎计算机上协同完成工作的系统，这些计算机通过网络连接在一起，共同完成一个任务。</p><p>分布式系统能够有效解决单台计算机处理能力不足，系统容易宕机，数据存储容量有限等问题，同时能够提高系统的可靠性，可用性和性能，适用于数据量较大，并发量高，访问平凡的场景。此外，分布式系统还可以通过横向扩展的方式提高系统的性能和可靠性，同时降低单点故障的风险，提高了系统的可伸缩性，方便进行升级和维护。</p><p>在分布式系统中，由于数据和计算任务被分布在多台计算器上，不同计算机之间需要进行通信和协调，因此需要解决分布式一致性，负载均衡，故障回复，数据共享和安全等问题，同时需要考虑数据的一致性和可靠性。因此，分布式系统的设计和实现比单机系统更加复杂和困难，需要考虑到多个因素的综合影响。</p><h2 id="你是怎么做-MySQL-数据备份的？比如怎么恢复半个月前的数据？"><a href="#你是怎么做-MySQL-数据备份的？比如怎么恢复半个月前的数据？" class="headerlink" title="你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？"></a>你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？</h2><p>MySQL数据备份是一个非常重要的工作，保证数据的安全性和可靠性。</p><p><strong>备份数据库文件：</strong></p><p>使用mysqldump工具来备份MySQL数据库，该工具可以生成SQL脚本文件，包含数据库中所有表和数据的语句。在终端中运行以下命令：</p><pre><code class="mysql">mysqldump -u [username] -p [password] --[database_name] &gt; [backup_file].sql// [username]:MySQL用户名// [password]:密码// [database_name]:需要备份的数据库名称// [backup_file]:备份的文件名</code></pre><p>该命令会将SQL脚本文件导出到当前目录下。</p><p><strong>回复MySQL数据库：</strong></p><pre><code class="mysql">mysql -u [username] -p [password] --[database_name] &lt; [backup_file].sql// [username]:MySQL用户名// [password]:密码// [database_name]:需要恢复的数据库名称// [backup_file]:备份的文件名</code></pre><p>该命令会将备份文件中的SQL语句执行，从而将数据恢复到指定的数据库中。</p><p>如果需要恢复半个月以上的数据，可以选择备份文件中的某个时间点之前的数据，并使用以上方法进行恢复</p><p>此外使用mysql自带的mysqlbinlog工具进行增量备份或者第三方备份软件进行备份。</p><h2 id="什么是消息队列？消息队列有哪些应用场景？"><a href="#什么是消息队列？消息队列有哪些应用场景？" class="headerlink" title="什么是消息队列？消息队列有哪些应用场景？"></a>什么是消息队列？消息队列有哪些应用场景？</h2><p>消息队列是一种异步通信机制，用于在应用程序之间传递消息。它可以将消息暂时存储在队列中，然后按照一定的顺序和条件将消息传递给消费者。</p><p>消息队列有以下几个主要应用场景：</p><ol><li>异步处理：通过将任务转换为消息，异步的进行处理，可以提高系统的吞吐量和响应速度</li><li>系统解耦：在不同的系统或模块之间使用消息队列进行通信，可以实现系统的解耦，提高系统的灵活性和可扩展性</li><li>流量控制：消息队列可以对消息进行缓存和限流，保证系统稳定性和高可用性</li><li>应用解耦：在同一个应用程序中，不同模块之间使用消息队列进行通信，可以实现模块之间的解耦，提高代码的可维护性</li><li>日志处理：通过将日志转换为消息，可以实现日志的异步处理，提高系统的性能和可维护性</li></ol><p>常见的消息队列包括：Kafka，Rabbit MQ，ActiveMQ，RocketMQ等</p><h2 id="设计模式是什么？为什么要学习和使用设计模式？"><a href="#设计模式是什么？为什么要学习和使用设计模式？" class="headerlink" title="设计模式是什么？为什么要学习和使用设计模式？"></a>设计模式是什么？为什么要学习和使用设计模式？</h2><p>设计模式是一套被反复使用，经过验证的，通用的解决特定问题的设计思想，是一种被设计师反复使用的技术方案</p><p>设计模式主要作用在于：</p><ol><li>提高代码的可维护性，可扩展性，可读性，提高代码的质量</li><li>通过共享经验，提高开发人员的设计能力，缩短学习时间，增强团队合作效率；</li><li>提高开发效率，缩短开发周期</li></ol><p>设计模式主要分为三大类：</p><ol><li>创建型模式：用于描述创建对象的方式</li><li>结构性模式：用于描述如何组合对象，形成更大的结构</li><li>行为型模式：用于描述对象之间的协作和职责分配。</li></ol><p>在具体的应用设计模式时，需要更具实际场所选用合适的设计模式。常用的设计模式包括单例模式，工厂模式，观察者模式，适配器模式，装饰器模式，策略模式。</p><h2 id="一条-SQL-语句在-MySQL-中的执行过程是怎样的？"><a href="#一条-SQL-语句在-MySQL-中的执行过程是怎样的？" class="headerlink" title="一条 SQL 语句在 MySQL 中的执行过程是怎样的？"></a>一条 SQL 语句在 MySQL 中的执行过程是怎样的？</h2><p>在MySQL中，一条SQL语句的执行过程通常可以分为以下几个步骤：</p><ol><li><strong>词法分析和语法分析</strong>：MySQL的SQL解析器会对输入的SQL语句进行词法分析和语法分析，以确定语句的结构和语法是否正确</li><li><strong>查询优化</strong>：MySQL会对SQL语句进行优化，以确定最优的执行计划。在这个过程中，MySQL会考虑许多因素，例如索引，表连接，统计信息等，以找到执行查询的最有效方式</li><li><strong>查询执行</strong>：在查询优化后，MySQL开始执行查询，读取和处理数据。在执行过程中，MySQL会根据查询中所涉及的表和列等信息，从磁盘中读取相应的数据，并进行计算和过滤操作。</li><li><strong>结果返回</strong>：最后，MySQL会将查询结果返回给客户端，完成整个查询过程</li></ol><p>需要注意的是：实际执行过程可能会应为多种因素而不同，例如数据量，硬件配置等。另外，在并发环境下，多个查询可能会同时进行，需要使用<strong>锁和事务</strong>等机制来保证数据的一致性和正确性。</p><h2 id="什么是-IOC，简单讲一下-Spring-IOC-的实现机制"><a href="#什么是-IOC，简单讲一下-Spring-IOC-的实现机制" class="headerlink" title="什么是 IOC，简单讲一下 Spring IOC 的实现机制"></a>什么是 IOC，简单讲一下 Spring IOC 的实现机制</h2><p>IOC（Inversion of Control），中文译为<strong>控制反转</strong>，是一种<strong>编程思想</strong>，它将程序中的对象的创建，组装，管理等控制权从代码中转移到框架中，实现了<strong>松耦合和可重用性</strong>的设计。</p><p>Spring IOC 是Spring 框架的一个核心特征，它实现机制主要包括以下几个步骤：</p><ol><li><strong>定义Bean</strong>：在Spring IOC 中，所有对象都被看做是 Bean，需要在配置文件或者使用注解的方式中进行定义和配置</li><li><strong>创建Bean工厂</strong>：在Spring中，Bean工厂负责管理Bean的创建，组装和销毁等任务。Spring IOC 容器就是Bean工厂的一种实现。</li><li><strong>读取配置文件</strong>：Spring IOC容器会读取配置文件或者使用注解的方式来获取 Bean 的定义和配置信息。</li><li><strong>创建Bean实例</strong>：Spring IOC 容器根据配置文件中的信息，使用反射技术来创建 Bean 实例，并将其保存在容器中。</li><li><strong>组装Bean</strong>：Spring IOC 容器根据配置文件中的信息，将不同的Bean实例组装起来，形成一个完整的应用程序</li><li><strong>注入依赖</strong>：Spring IOC 容器根据配置文件中的信息，自动为Bean注入依赖的对象或者值</li><li><strong>提供Bean实例</strong>：应用程序通过Spring IOC容器获取需要的Bean实例，从而使用其中的方法和属性等</li></ol><p>需要注意的是，Spring IOC还提供了多种作用域，例如单例，原型，会话，请求等作用域，可以根据具体的需求来选择。同时，Spring IOC容器也支持AOP，事务管理等功能，可以为应用程序提供更完整的服务。</p><h2 id="并发和并行有什么区别？同步和异步有什么区别？"><a href="#并发和并行有什么区别？同步和异步有什么区别？" class="headerlink" title="并发和并行有什么区别？同步和异步有什么区别？"></a>并发和并行有什么区别？同步和异步有什么区别？</h2><p>并发和并行是两个计算机领域经常被提到的概念：</p><ol><li><strong>并发</strong>（Concurrency）：指的是系统中同时存在多个正在执行的任务，并且这些任务之间可能会相互影响。并发通常用来处理多个任务共享资源的情况。在单核CPU上，多个任务会轮流使用CPU时间片，变现为看似同时执行的情况，但实际上只有一个任务在进行。</li><li><strong>并行</strong>（Parallelism）：指的是系统中同时存在多个并且相互独立的任务，并且这些任务可以在多个处理器上同时执行，真正意义上的同时处理多个任务</li><li><strong>同步</strong>（Synchronous）：指的是程序按照代码的执行顺序，一行一行的执行，知道当前执行完成后才能继续执行下一行。同步通常会阻塞调用者，直到任务完成才能返回。</li><li><strong>异步</strong>（Asynchronous）：指的是程序在执行某个任务时，不会一直等待任务完成，而是继续执行下一行代码，当任务完成后再进行相应的处理。异步通常不会阻塞调用者，可以提高系统的并发性能。</li></ol><p>总的来说，“并行”和“并发”是针对对各任务的执行方式。“同步”和“异步”是针对任务执行的阻塞方式和返回方式。在实际应用中，可以根据不同需求来选择合适的并发同步方式，以提高系统的性能和可靠性。</p><h2 id="String-和-StringBuffer、StringBuilder-的区别是什么？"><a href="#String-和-StringBuffer、StringBuilder-的区别是什么？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别是什么？"></a>String 和 StringBuffer、StringBuilder 的区别是什么？</h2><p>String 和 StringBuffer&#x2F;StringBuilder 是 Java中两种不同的字符串处理方式，主要区别在于String是不可变的（immutable）对象，而StringBuffer 和 StringBuilder 则是可变的（mutable）对象</p><p>String对象一旦被创建，就不可修改，任何的字符串操作都会返回一个新的 String 对象，这可能导致频繁的对象创建和销毁，影响性能。而StringBuffer和StringBuilder允许进行修改，提供了一种更加高效的字符串处理方式。</p><p>StringBuffer和StringBuilder的主要区别在于线程安全和性能方面。StringBuffer是线程安全的，所有方法都是同步的，因此可以被多个线程同时访问和修改。而StringBuilder不是线程安全的，适用于单线程环境下的字符处理，但是相比于StringBufer，StringBuilder具有更高性能。</p><p>因此，当字符串处理需要频繁修改时，建议使用StringBuffer或StringBuilder，而当字符串处理不需要修改时，可以使用String</p><h2 id="MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，为什么-MySQL-要用-B-树？"><a href="#MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，为什么-MySQL-要用-B-树？" class="headerlink" title="MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？"></a>MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？</h2><p>MySQL中的索引是通过B+树实现的。B+树是一种多叉树，它可以将数据按照一定的顺序组织起来，从而提高查询效率。</p><p>B+树和B树区别在于：B+树的所有数据都存储在叶子节点上，而非叶子节点只存储索引，这样可以提高数据查询效率。B+树的叶子节点之间使用指针相连，这样可以实现区间查找，也就是说，可以快速定位某个区间内的数据。</p><p>之所以使用B+树，是因为B+树有以下特点：</p><ol><li>能够支持高效的范围查找和排序</li><li>叶子节点之间使用指针相连，能够支持高效的区间查询</li><li>B+树具有较高的数据密度，可以减少磁盘I&#x2F;O次数，提高查询效率</li><li>B+树对于插入和删除操作也比较高效</li></ol><p>在MySQL中，B+树的实现主要是通过InnoDB存储引擎来实现的，InnoDB存储引擎中的索引主要有聚簇索引和辅助索引两种类型，聚簇索引是根据主键来创建的索引，而辅助索引是根据非主键列创建的索引，MySQL中会同时创建一个对应的聚簇索引，这样可以提高查询效率</p><h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><p>Spring框架中使用了许多设计模式，例如：</p><ol><li>单例模式：Spring的Bean默认是单例模式，通过Spring容器管理Bean的生命周期，保证每个Bean只被创建一次，并在整个应用程序中重用</li><li>工厂模式：Spring使用工厂模式通过BeanFactory和ApplicationContext 创建并管理Bean对象</li><li>代理模式：Spring AOP基于动态代理技术，使用代理模式实现切面编程，提供了对AOP编程支持</li><li>观察者模式： Spring中事件机制基于观察者模式，通过ApplicationEventPublisher发布事件，由ApplicationListener监听事件，将一些固定的流程封装在父类中，子类只需要实现一些抽象方法即可。</li><li>策略模式：Spring中HandlerInterceptor和HandlerExrcutionChain使用了策略模式，允许开发者自定义处理器拦截器，按照一定顺序执行</li><li>责任链模式：Spring中过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并作出相应的处理</li></ol><p>总之，Spring框架中充分利用了许多设计模式，提供了良好的扩展性和灵活性，降低了代码的耦合度，提高了代码的可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
