<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql连接本地数据库时报网络问题"><a href="#MySql连接本地数据库时报网络问题" class="headerlink" title="MySql连接本地数据库时报网络问题"></a>MySql连接本地数据库时报网络问题</h1><p>今早起床学习大佬面经时，发现自己数据库都登不上去了<img src="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\63aae1ca1cac76b665567fb840a6da6.png" alt="63aae1ca1cac76b665567fb840a6da6"></p><p>不论是命令行还是Navicat登录都是报以上错误，可我这是个本地的数据库，不应该存在网络错误呀。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>经过大佬的指点，重启服务中的Mysql，数据库的访问就正常了<img src="/2022/11/30/Mysql%E6%9C%AC%E5%9C%B0%E9%93%BE%E6%8E%A5%E6%8A%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/blog\source_posts\Mysql本地链接报网络问题\image-20221130103336695.png" alt="image-20221130103336695"></p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>尽管问题很快被解决，但是我依然想不通为什么会报这种错误，认识到自己的不足，也就有了下面的学习，鉴于以往没有过这种错误，无从下手，我决定先翻译这段报错：</p><p><strong>‘‘读取初始通信数据包时失去与MySQL服务器的连接，系统错误: 0”</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6常见问题</title>
      <link href="/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/11/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片学习内容整理至b站 <a href="https://space.bilibili.com/526653251">IT老哥</a> 的视频 <a href="https://www.bilibili.com/video/BV1sR4y1c7Ni?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">《会了这些面试题后，可以挑战一下字节了》</a></p></blockquote><ul><li>单线程的Redis为什么快</li><li>五种基本数据类型底层采用什么数据结构</li><li>缓存雪崩，缓存穿透，缓存击穿，附加</li><li>Redis的过期淘汰机制</li><li>redis与memcached的区别</li><li>redis线程模型</li><li>哨兵Sentinel</li><li>如何实现redis事务</li></ul><h2 id="单线程的Redis为什么快？"><a href="#单线程的Redis为什么快？" class="headerlink" title="单线程的Redis为什么快？"></a>单线程的Redis为什么快？</h2><p>Redis有多快？官方给出的读写速度是10w&#x2F;s，在单线程的前提下跑出这个好成绩，原因有以下几点：</p><ul><li><strong>Redis是完全基于内存</strong>的，因此读写效率高，同时Redis的持久化操作是通过fork子进程和Linux系统的页面缓存技术完成，并不会影响Redis</li><li><strong>单线程操作</strong>：单线程避免了频繁上下文切换导致的性能开销</li><li>合理高效的<strong>数据结构</strong></li><li>采用了<strong>非阻塞的IO多路复用机制</strong>：多路I&#x2F;O复用模型是利用select，poll，epoll可以同时监察多个流的IO事件的能力，在空闲时阻塞当前线程，当有一个或多个流有IO事件时，就从阻塞中唤醒，程序再依次轮询所有的流，并且只依次顺序处理就绪的流，这种做法避免了大量无用操作</li></ul><h2 id="五种基本数据类型底层采用什么数据结构"><a href="#五种基本数据类型底层采用什么数据结构" class="headerlink" title="五种基本数据类型底层采用什么数据结构"></a>五种基本数据类型底层采用什么数据结构</h2><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>存储数字时：int存储长度大于39字节字符：raw存储长度小于39字节字符：embstr</p><p>raw与embstr都是由SDS动态字符串构成的。唯一区别是raw分配存储时，redisobject 和 sds 各分配一块，而 embstr 是 redisobject 在一块内存中</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：双向链表</p><h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>列表所有对象长度均小于64字节，且元素数量小于512：ziplist否则：哈希表</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>列表所有对象都是整数，且元素数量小于512：inset否则：哈希表</p><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset:"></a>Zset:</h4><p>列表所有对象长度均小于64字节，且元素数量小于128：ziplist否则：跳表</p><h2 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h2><p>在高并发下，大量缓存key在同一时间集体失效，大量请求直接落在数据库上，导致数据库宕机</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><ul><li>随机设置key失效时间，避免大量key集体失效</li></ul><pre><code class="redis">setRedis(Key, value, time+Math.random()*10000);</code></pre><ul><li>如果是集群部署，可以将热点数据均匀分布在不同的Redis库中避免key全部失效</li><li>跑定时任务，在缓存失效前刷新新缓存</li><li>不设置过期时间（不推荐）</li></ul><h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><p>redis缓存没有数据库中没有相关数据（如用户查询携带id&#x3D;-1的相关数据并不断发起请求），redis中没有数据，无法进行阻拦，请求直接穿透到数据库，导致数据库压力过大宕机</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>对不存在的数据将其缓存到redis中，设置key，value值为null（不论是数据未null还是系统bug），设置一个短期过期时间，避免影响用户正常使用</li><li>拉黑用户IP</li><li>对参数进行校验，不合法参数进行拦截</li><li>布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap (位图) 中，一个一定不存在的数据会被这个bitmap拦截掉，减少对底层存储系统的查询压力</li></ul><h2 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h2><p>某一个热点key，在不停的扛着高并发，当这个热点key在失效的一瞬间，持续的高并发访问就击破缓存直接访问数据库，导致数据库宕机</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>设置热点数据“永不过期”</li><li>加上互斥锁：对于多个线程同时去查询数据库的热点数据，我们可以在第一个查询数据上的请求使用互斥锁锁住它</li></ul><p>其他线程需要使用就得等待，第一个线程查询到了数据，将数据放置redis中缓存起来，后面的进程就可以直接使用缓存数据</p><h2 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h2><p>提前避免以上三问题：将redis，mysql等搭建成高可用集群，放置单点</p><p>出现错误如何修补    ：服务中进行限流 + 降级，放置mysql被打崩溃</p><p>实在严重到宕机补救：Redis持久化 RDB + AOF，宕机重启，自动从磁盘加载数据，快速回复缓存数据</p><h2 id="Redis的过期淘汰机制："><a href="#Redis的过期淘汰机制：" class="headerlink" title="Redis的过期淘汰机制："></a>Redis的过期淘汰机制：</h2><p>Redis中数据过期策略采用定期删除 + 惰性删除策略</p><h4 id="1-定期删除，惰性删除策略是什么："><a href="#1-定期删除，惰性删除策略是什么：" class="headerlink" title="1.定期删除，惰性删除策略是什么："></a>1.定期删除，惰性删除策略是什么：</h4><ul><li>定期删除：Redis启用一个定时器定时监听所有key，判定key是否过期，过期就删除。尽管可以保证所有的过期key都会被删除，但是十分浪费cpu资源，且对于以及过期但是定时器还没启动的key，它任然可以使用。</li><li>惰性删除：在获得key时，先判断key是否以及过期过期就删除，缺点：如果这个key一直没被使用，那么它一直在内存，即便已经过期，这会浪费大量空间。</li></ul><h4 id="2-定期删除-惰性删除是如何工作的："><a href="#2-定期删除-惰性删除是如何工作的：" class="headerlink" title="2.定期删除 + 惰性删除是如何工作的："></a>2.定期删除 + 惰性删除是如何工作的：</h4><p>每次随机抽取一部分key进行检查，减少CPU资源的损耗，惰性删除策略互补了未检查到的key，基本上满足了所有要求</p><h4 id="3-补充的内存淘汰机制："><a href="#3-补充的内存淘汰机制：" class="headerlink" title="3.补充的内存淘汰机制："></a>3.补充的内存淘汰机制：</h4><ul><li><p>volatile - lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile - ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile - random：从已设置过期时间的数据集（server.db[i].expires）中挑选任意数据淘汰</p></li><li><p>allkeys - lru：当内存不足以容纳新写入的数据时，在键空间内，移除最近最少使用的key<strong>（这个最常用）</strong></p></li><li><p>allkeys - random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-eviction：禁止驱逐数据，永不过期，也就是当内存不足以写入新数据时，写入操作会报错<strong>（默认）</strong></p></li><li><p>volatile - lfu：4.0后加入，从已设过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p></li><li><p>allkeys - lfu：4.0后加入，当内存不足以写入新数据时，在键空间中，移除最不经常使用的key</p></li></ul><h2 id="Redis与memcached的区别："><a href="#Redis与memcached的区别：" class="headerlink" title="Redis与memcached的区别："></a>Redis与memcached的区别：</h2><p>存储方式上：memcached会将全部数据存入内存中，如果发生断电则会挂掉，数据不可以超过内存大小；redis有部分存在硬盘中，能保证数据的持久性</p><p>数据支持类型：memcached支持的数据类型相对简单；redis有复杂的数据类型</p><p>使用的底层模型不同：它们之间的底层实现，客户端之间通讯的应用协议不一样，redis自己构建了vm机制，因为一般的系统调用系统函数会浪费一定时间去移动和请求。value值大小不同，redis最大可到1gb；memcached只有1mb</p><h2 id="Redis线程模型："><a href="#Redis线程模型：" class="headerlink" title="Redis线程模型："></a>Redis线程模型：</h2><p>redis内部使用文件处理器 file event handler，这个文件事件处理器是单线程的，所以redis才叫单线程处理器模型。它采用IO多路复用机制监听多个socket，根据socket上事件处理器进行处理</p><p>文件事件处理器的结构包括4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）</li></ul><p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应事件处理器进行处理。</p><h2 id="哨兵Sentinel："><a href="#哨兵Sentinel：" class="headerlink" title="哨兵Sentinel："></a>哨兵Sentinel：</h2><p>哨兵是Redis高可用的解决方案，可以运行多个Sentinel组成一个哨兵分布式系统</p><p>哨兵主要解决的问题：故障转移，如果主节点挂掉，就进行主从切换，让从节点升级为主节点，继续对外提供服务</p><p>使用流言协议（gossip protocols）来接收主机是否下线；并使用投票协议（agreeement protocols）来决定是否执行自动故障转移；以及选择哪个服务器作为新的主服务器</p><h4 id="哨兵职责如下："><a href="#哨兵职责如下：" class="headerlink" title="哨兵职责如下："></a>哨兵职责如下：</h4><ul><li><p>监控：Sentinel会不断定期检查主服务器和从服务器是否运作正常</p></li><li><p>提醒：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或其他应用程序发送通知</p></li><li><p>自动故障迁移：当一个主服务器不能正常工作时，Sentinel会开启一次自动故障迁移操作，将失效服务器的其中一个从服务器升级为新的主服务器，并让失效服务器的其他服务器改为复制新的主服务器，当客户端连接失败主服务器时，集群也会向客户端返回新服务器地址，使得集群可以使用新主服务器替代失效服务器</p></li><li><p>统一配置管理：连接者询问Sentinel取得主从的地址</p></li></ul><h2 id="如何实现redis事务："><a href="#如何实现redis事务：" class="headerlink" title="如何实现redis事务："></a>如何实现redis事务：</h2><p>redis通过MULTI，EXEC，WATCH等命令来实现事务（transaction）功能，事务提供了一种将多个命令请求打包，然后一次性，按顺序的执行多个命令的机制，且在事务执行期间，服务器不会中断事务而改去执行其他客户端的请求，只有到这多个命令执行完毕后，才会接收其他命令</p><p>Redis事务也具有：原子性，一致性，隔离性；在特定情况下具有持久性</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap常见问题</title>
      <link href="/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/20/------%E6%9A%82%E5%AE%9A%E6%96%87%E4%BB%B6/Hashmap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Hashmap是否线程安全？为什么？"><a href="#Hashmap是否线程安全？为什么？" class="headerlink" title="Hashmap是否线程安全？为什么？"></a>Hashmap是否线程安全？为什么？</h3><p>不安全，JDK7存在死循环和数据丢失问题。</p><p><strong>数据丢失</strong>：</p><ol><li><strong>并发赋值被覆盖</strong>：在createEntry方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖</li><li><strong>已遍历区间新增元素丢失</strong>：当某个线程在transfer方法迁移时，其他线程新增的元素可能以及落在已经遍历过的哈希槽上。遍历完成后，table数组引用指向了newTable，新增元素丢失</li><li><strong>新表被覆盖</strong>：如果resize完成，执行了table &#x3D; newTable，则后续元素就可以在新表上进行插入。但如果多线程同时resize，每个线程都会new一个数组，这是线程内的局部对象，线程之间不可见。迁移后resize的线程会赋值给table线程共享变量，可能会覆盖其他线程操作，在新表中插入的对象都会被丢弃。</li></ol><p><strong>死循环</strong>：</p><p>扩容时resize调用transfer使用头插法迁移元素，虽然newTable是局部变量，但原先的table中Entry链表是共享的，问题根源是Entry的next指针并发修改，某线程还没有将table设为newTable时用完了CPU时间片，导致数据丢失或死循环。</p><p>JDK8在resize方法中完成了扩容，并改为尾插法，不会产生死循环，但并发下仍可能丢失数据。可用ConcurrentHashMap 或 Collections.synchronizedMap包装成同步集合。</p><h3 id="JDK7与JDK8的hashmap有什么区别："><a href="#JDK7与JDK8的hashmap有什么区别：" class="headerlink" title="JDK7与JDK8的hashmap有什么区别："></a>JDK7与JDK8的hashmap有什么区别：</h3><p>JDK7是数组 + 链表，JDK8是数组 + 链表&#x2F;红黑树</p><ol><li><strong>链表插入方式不同</strong>：1.7之前，链表元素插入采用头插法，每当有新节点进入时，会插入在链表头部，由于不用遍历链表，这种插入方式效率高；1.8以后当节点插入时，因为需要判断元素个数而遍历链表（是否达到转为树的阈值），所以顺带改为尾插，即插到链表尾部，这解决了多线程下可能引发的死锁问题，因为头插法的链表在扩容移动时，会被逆序，即后插入的先处理，如果这时候有另一线程进行get操作，就可能引发死锁</li><li><strong>插入时机不同</strong>：1.7之前是扩容后再插入新的数据，并且不会先计算值的哈希值，最后单独计算；1.8之后是先插入再扩容，插入值和大家一起计算新的哈希值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get使用</title>
      <link href="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/"/>
      <url>/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/</url>
      
        <content type="html"><![CDATA[<p>原链接：<a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">视频同步笔记：狂神聊Git (qq.com)</a></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>在开发过程中用于管理我们的文件，目录或工程等内容的修改历史，方便查看历史记录，备份以便回复以前的版本的软件工程技术</p><ul><li>实现跨域多人协同开发</li><li>追踪和记载一个或多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量‘</li><li>并行开发，提高工作效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说；一种管理多人协同开发项目的技术</p><blockquote><p>常见版本控制工具：</p><p>GitSVNCVSVSSTFS</p></blockquote><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><blockquote><p>安装：</p></blockquote><p>进入官网，下载git（windows 64-bit.exe）&#x2F;  使用镜像下载 , 无脑下一步（<a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a>）</p><p>注：环境变量只是为了全局使用而已，不是必需品</p><blockquote><p>卸载：</p></blockquote><p>环境变量中删除Git , 再去卸载中心卸载程序</p><blockquote><p>使用：</p></blockquote><p>安装成功后，右键任意文件夹都会出现Git Bash（Unix与Linux风格命令行）和Git CMD（Windows风格命令行）</p><h3 id="Linux简单口令"><a href="#Linux简单口令" class="headerlink" title="Linux简单口令"></a>Linux简单口令</h3><pre><code class="Linux">cd改变目录cd..退回到上一级目录,直接cd进入默认目录pwd显示当前所在路径ls(||)ls和ls||都是列出当前目录中的所有文件,只不过后者列出的内容更为详细touch新建一个文件夹,如：touch index.js就会在当前目录下新建一个index.js文件rm删除一个文件,rm index.js就会删除index.js文件mkdir新建一个目录,就是新建一个文件夹rm -r 删除一个文件夹,rm -r src就是删除src文件夹mv移动文件,如mv index.html src 那么index.html就是移动的文件，src为目标文件夹（两者在同一目录下）reset重新初始化终端/清屏clear清理屏幕history查看历史命令exit退出#注释</code></pre><h5 id="Git配置：-所有的配置文件，其实都保存在本地"><a href="#Git配置：-所有的配置文件，其实都保存在本地" class="headerlink" title="Git配置：(所有的配置文件，其实都保存在本地)"></a>Git配置：(所有的配置文件，其实都保存在本地)</h5><h6 id="查看配置：git-config-l"><a href="#查看配置：git-config-l" class="headerlink" title="查看配置：git config -l"></a>查看配置：git config -l</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231706647.png" alt="image-20220603231706647"></p><h6 id="查看系统配置：git-config-–system-–list"><a href="#查看系统配置：git-config-–system-–list" class="headerlink" title="查看系统配置：git config –system –list"></a>查看系统配置：git config –system –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231858917.png" alt="image-20220603231858917"></p><h6 id="查看全局配置：git-config-–global-–list"><a href="#查看全局配置：git-config-–global-–list" class="headerlink" title="查看全局配置：git config –global –list"></a>查看全局配置：git config –global –list</h6><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220603231922188.png" alt="image-20220603231922188"></p><pre><code class="linux">git config --global user.name &quot;设置名字&quot;git config --global user.email 邮箱地址</code></pre><h4 id="Git相关配置文件："><a href="#Git相关配置文件：" class="headerlink" title="Git相关配置文件："></a>Git相关配置文件：</h4><p>1)，Git&#x2F;etc&#x2F;gitconfig：Git安装目录下的gitconfig–system系统配置</p><p>2)，C:&#x2F;User&#x2F;Administrator（当前用户）&#x2F;.gitconfig：只适用于当前登录用户的配置–global全局配置</p><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）,暂存区（Stage&#x2F;Index）,资源库（Repository&#x2F;Git Directory）加上远程Git仓库（Remote Directory）</p><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604102832395.png" alt="image-20220604102832395"></p><ul><li>Workspace：工作区，就是平时存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放改动，实际上只是一个文件，保存了即将提交到文件列表的信息</li><li>Repository：仓库区（本地仓库），安全存放数据的位置，这里有提交到所有版本的数据，其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器（一般用github或者gitee）</li></ul><p><img src="/2022/08/18/%E7%8B%82%E7%A5%9E%E8%81%8AGit/image-20220604103432739.png" alt="image-20220604103432739"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>在工作目录添加,修改文件;</li><li>将需要的进行版本管理的文件放入暂存仓库</li><li>将暂存区文件提交到git仓库</li></ol><p>所以,git管理的文件有三种状态:已修改（modified），已暂存（staged），已提交（committed）</p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h3 id="仓库搭建"><a href="#仓库搭建" class="headerlink" title="仓库搭建"></a>仓库搭建</h3><p>创建本地仓库方法有两种：创建全新的仓库，克隆远程仓库</p><h5 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h5><pre><code class="git"># 在当前目录下新建一个Git代码库$ git init</code></pre><p>执行后在项目文件夹会多出一个.git的隐藏目录，关于版本等信息都在目录中</p><h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><pre><code class="git"># 克隆一个项目和它的全部代码历史（版本信息）$ git clone [url]</code></pre><p>前往gitee &#x2F; github上测试；</p><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<strong>git add</strong> 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用    <strong>git rm</strong>移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<strong>git checkout</strong> 则丢弃修改过, 返回到unmodify状态, 这个<strong>git checkout</strong>即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行<strong>git commit</strong>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行<strong>git reset HEAD filename</strong>取消暂存, 文件状态为Modified</li></ul><pre><code class="git"># 查看全部文件状态git status# 查看指定文件状态git status [filename]# 添加全部文件到暂存区git add .# 将暂存区内容提交至本地 -m为提交时编写备注git commit -m&quot;消息内容&quot;</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在项目文件夹中，并非所有数据都要我们上传和提交，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore“文件，此文件有以下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><pre><code class="git"># 为注解*.txt# 忽略所有.txt结尾的文件，上传的总文件中不会包含这些文件!lib.txt    # 但是lib.txt文件除外/temp# 仅忽略build/目录下的所有文件build/# 忽略bulid/目录下的所有文件doc/*.txt# 忽略doc/notes.txt等文件,单不包括doc/server/arch.txt</code></pre><h3 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h3><pre><code class=".gitignore">*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/#idea.idea/*.iml*velocity.log*### STS ###.apt_generated.factorypath.springBeans### IntelliJ IDEA ###*.iml*.ipr*.iws.idea.classpath.project.settings/bin/*.logtmp/#rebel*rebel.xml*</code></pre><h1 id="使用码云（Gitee）"><a href="#使用码云（Gitee）" class="headerlink" title="使用码云（Gitee）"></a>使用码云（Gitee）</h1><p>设置本机SSH公钥，实现免密码登录！</p><pre><code class="git"># 进入C:/user/Administraror/.ssh 目录# (右键进入git命令行)生产公钥ssh-keygen</code></pre><p>将生产的id_rsa.pub文件中的信息复制，在码云<strong>安全设置</strong>的<strong>SSH公钥</strong>中粘贴即可</p><p>接下来就是创建仓库去使用了！</p><h1 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h1><p>1.新建项目，绑定git</p><ul><li>直接将远程的git文件拷贝到项目中（在别处get clone [url]，将产生的文件夹剪切）</li></ul><p>2.修改文件，提交文件</p><ul><li>左下角有<strong>Version Control</strong>显示版本信息，右上角有快捷图标</li></ul><h1 id="Git分支说明"><a href="#Git分支说明" class="headerlink" title="Git分支说明"></a>Git分支说明</h1><p>git分支中常见指令：</p><pre><code class="git"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支吧git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h1 id="Git后续操作"><a href="#Git后续操作" class="headerlink" title="Git后续操作"></a>Git后续操作</h1><blockquote><p>gitee官网中有命令大全和操作指南</p></blockquote><blockquote><p>团队很重要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层原理</title>
      <link href="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇知识梳理参考了B站up : <a href="https://space.bilibili.com/439213321">黑马程序员上海中心</a> 的视频 : <a href="https://www.bilibili.com/video/BV1FE411t7M7?share_source=copy_web&vd_source=9b42e96f6cc201a1ee177f1b86bb0b77">HashMap集合介绍+面试题讲解</a></p></blockquote><h1 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h1><ul><li>hashMap集合介绍</li><li>HashMap集合底层数据结构</li><li>hashMap继承关系</li><li>hashMap集合类成员</li><li>如何设计多个非重复的键值对要存储HashMap的初始化</li></ul><h3 id="HashMap集合介绍"><a href="#HashMap集合介绍" class="headerlink" title="HashMap集合介绍"></a>HashMap集合介绍</h3><p><img src="/2022/08/18/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20220814101149681.png" alt="image-20220814101149681"></p><p><img src="https://img-blog.csdnimg.cn/20200628084624157.png#pic_center" alt="HashMap"></p>]]></content>
      
      
      <categories>
          
          <category> 代码底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http分析</title>
      <link href="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/"/>
      <url>/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/252370220">图灵诸葛官方号</a>) 课程 <a href="https://www.bilibili.com/video/BV1V54y1y7c4?spm_id_from=333.337.search-card.all.click&vd_source=ad19a531d1fe118602dfd75ff3c6db57">程序员入门必备教程—HTTP协议详解</a>)</p></blockquote><ul><li>HTTP分层请求</li><li>HTTP协议</li><li>HTTP请求过程</li><li>TCP协议</li><li>HTTPS协议</li></ul><h1 id="Http分层"><a href="#Http分层" class="headerlink" title="Http分层:"></a>Http分层:</h1><p>网络需要完成的任务：防止数据丢包，避免数据重复，数据完整性校验，数字转模拟信号，…，信号衰减</p><p>为了完成不同层面的各个任务，简化网络的复杂度，网络通信被分解为多层次结构，每一层都紧挨着上层或下层进行交互，这样在修改甚至替换某一层的软件时，只需要层与层之间的接口保持不变，就不会影响其他层。</p><ul><li>OSI七层网络模型</li><li>TCP&#x2F;IP协议簇</li></ul><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819105355252.png" alt="image-20220819105355252"></p><h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><p>超文本传输协议（HyperText Transfer Protocol , HTTP）</p><p>一种无状态，以请求、应答方式运行的协议。它使用可扩展语义和子描述消息格式，与基于网络的草文本消息系统可以灵活互动</p><h5 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h5><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）:描述请求或响应的基本信息</li><li>头部字段集合（header）:使用key-value形式更详细的说明报文</li><li>空行</li><li>消息正文（entity）:实际传输的数据，不一定是文本，可以是图片，视频等二进制数据</li></ul><h5 id="请求行报文格式："><a href="#请求行报文格式：" class="headerlink" title="请求行报文格式："></a>请求行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110831735.png" alt="image-20220819110831735"></p><ul><li>请求方法（METHOD）：如 GET &#x2F; HEAD &#x2F; PUT &#x2F; POST，表示对资源的操作</li><li>请求目标 ：通常是一个URL，标记了请求方法要操作的资源</li><li>版本号：表示报文使用的HTTP协议版本</li></ul><h5 id="响应行报文格式："><a href="#响应行报文格式：" class="headerlink" title="响应行报文格式："></a>响应行报文格式：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819110855815.png" alt="image-20220819110855815"></p><ul><li>版本号 ：表示报文使用的HTTP协议版本</li><li>状态码（STATUS CODE）: 一个三位数，用代码的形式表示处理结果，比如200是成功，403是客户端访问被拒，500是服务器错误</li><li>原因（READON）：作为数字状态码补充，是更加详细的解释文字，协助理解原因</li></ul><h5 id="HTTP头字段："><a href="#HTTP头字段：" class="headerlink" title="HTTP头字段："></a>HTTP头字段：</h5><p>头部字段是key-value形式，key和value间使用 “  ：”做分隔，比如前后端分离时常遇到的要与后端协商传输数据类型 “ <strong>Content-type:application&#x2F;json</strong> ” ，最后用CRLF换行表示字段结束，HTTP头字段的使用比较灵活，不仅可以用Host,Connection等已有头字段，也可以任意添加自定义头，这就给HTTP协议带来了无限扩展可能。 </p><p><strong>注意事项</strong></p><ul><li>字段名称不区分大小写，但不允许出现空格和下划线“_”,可以使用连字符“-”，字段后必须紧跟“:”，中间不许有空格，但“:”后允许多个空格</li><li>字段顺序没有意义，任意排列不影响语序</li><li>字段原则上不允许重复，除非字段本身允许：Set-Cookie</li></ul><h5 id="常用头字段："><a href="#常用头字段：" class="headerlink" title="常用头字段："></a>常用头字段：</h5><p>HTTP协议有很多头字段，基本可以分为四大类：</p><ul><li>请求字段：请求头中的头字段：如Host，Referer</li><li>响应字段：响应头中的头字段：如Server，Date</li><li>通用字段：在响应头和请求头都可以出现的：Content-type，Connection</li></ul><h1 id="HTTP请求过程："><a href="#HTTP请求过程：" class="headerlink" title="HTTP请求过程："></a>HTTP请求过程：</h1><p>当用户在浏览器中输入网址后，网络协议都做了哪些工作？</p><ol><li>首先依据浏览器应用程序，解析出URL中的域名</li><li>依据域名获得的ip地址，首先从浏览器缓存中查看，没有就去本机域名解析文件hosts中查看，LDNS，Rootserver，国际定级域名服务商层层解析，直至找到</li><li>拿到ip地址后，浏览器发起对服务器的三次握手</li><li>握手建立连接后，开始组装http请求，发送报文</li><li>服务器收到请求报文后，开始请求报文解析，生成响应数据，发送响应数据</li><li>浏览器收到响应后，开始渲染页面</li></ol><blockquote><p> chrome:&#x2F;&#x2F;net-internals&#x2F;#events             查看浏览器缓存ip地址</p></blockquote><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220819120503128.png" alt="image-20220819120503128"></p><h1 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h1><p>TCP协议是面向连接的，可靠的，基于字节流的传输层协议</p><h4 id="TCP属性："><a href="#TCP属性：" class="headerlink" title="TCP属性："></a>TCP属性：</h4><ul><li>基于连接：数据传输之间需要建立连接</li><li>全双工：双向传输</li><li>字节流：不限制数据大小，打包成为报文段，保证有序接收，重复报文自动丢弃</li><li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性</li><li>拥塞控制：防止网络出现恶性拥塞</li></ul><h4 id="TCP报文："><a href="#TCP报文：" class="headerlink" title="TCP报文："></a>TCP报文：</h4><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821101526541.png" alt="image-20220821101526541"></p><p>Source port：源端口Dest port：目的端口</p><p>Seq：请求数   ACK：应答数</p><p>Header length：首部长度Unused：保留字段</p><p>Receive window：当前可接收值 Urgent data：紧急报文指针</p><p>Options：可选参数   Data：数据</p><h4 id="TCP连接管理："><a href="#TCP连接管理：" class="headerlink" title="TCP连接管理："></a>TCP连接管理：</h4><p>TCP连接：四元组【源地址，源端口，目的地址，目的端口】</p><p>确认连接：三次握手</p><p>​a.同步通信双方的初始序列号（ISN）</p><p>​b.协商TCP通信参数（MSS，窗口信息，指定校验和算法）</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102017022.png" alt="image-20220821102017022"></p><p>内核操作：</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102108877.png" alt="image-20220821102108877"></p><p>关闭连接：四次挥手</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102157493.png" alt="image-20220821102157493"></p><h4 id="字节流协议："><a href="#字节流协议：" class="headerlink" title="字节流协议："></a>字节流协议：</h4><p>MSS：Max Segment Size：默认536byte实际数据</p><p>TCP会依据Seq报文序列号进行排序，使得文件被划分为小信息发送时不会乱序</p><h4 id="可靠性-x2F-重传机制："><a href="#可靠性-x2F-重传机制：" class="headerlink" title="可靠性&#x2F;重传机制："></a>可靠性&#x2F;重传机制：</h4><h5 id="1-ack丢失："><a href="#1-ack丢失：" class="headerlink" title="1.ack丢失："></a>1.ack丢失：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102424659.png" alt="image-20220821102424659"></p><h5 id="2-请求报文丢失"><a href="#2-请求报文丢失" class="headerlink" title="2.请求报文丢失"></a>2.请求报文丢失</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102536666.png" alt="image-20220821102536666"></p><h5 id="3-滑动窗口协议："><a href="#3-滑动窗口协议：" class="headerlink" title="3.滑动窗口协议："></a>3.滑动窗口协议：</h5><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821102644054.png" alt="image-20220821102644054"></p><p>每次发送一组报文，并确定最后的报文是否收到回信，如果收到，表示报文全部被接收，直接跳至下一组，不必有重复</p><p>如果没有收到最后的报文，则往前推，直至从收到回信的部分（如图，3，5没有回信只收到12的回信，则12确认发送成功，不论4是否成功，3，4，5都和后面数据一起发送）</p><h1 id="HTTPS协议："><a href="#HTTPS协议：" class="headerlink" title="HTTPS协议："></a>HTTPS协议：</h1><p>HTTP具有”明文“特点，整个传输过程完全透明，任何人都可以在链路中截获、修改和伪造，数据具有不可信性</p><p>使用HTTPS，所有HTTP请求都会在请求和响应之前进行加密</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/image-20220821103501204.png" alt="image-20220821103501204"></p><h3 id="SSL-x2F-TSL："><a href="#SSL-x2F-TSL：" class="headerlink" title="SSL&#x2F;TSL："></a>SSL&#x2F;TSL：</h3><p>SSL即安全套接层，由网景公司于1994年发明，IETF在1999年将其改名为TLS传输层安全，三个主流版本为2006的1.1，2008的1.2，2018的1.3，每个版本都紧跟密码学的发展和互联网现状，持续强化安全和性能，已经成为信息安全领域的权威标准</p><h3 id="摘要算法："><a href="#摘要算法：" class="headerlink" title="摘要算法："></a>摘要算法：</h3><p>将任意长度的数据”压缩“为固定长度，且独一无二的”摘要“字符，可以将其与明文一起发送，接收端解压字符后可以对比查看明文是否被篡改</p><p>如：md5</p><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><h5 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h5><p>编码使用相同的密钥进行加密解密（AES，RC4,ChaCha20）</p><h5 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h5><p>有两个密钥，一个”公钥“，一个”私钥“。前者可以给任何人使用，随意分发。后者需要保密，网站秘密保存</p><p><img src="/2022/08/17/%E5%89%96%E6%9E%90Http%E8%AF%B7%E6%B1%82/blog\source_posts\剖析Http请求\image-20220821104242155.png" alt="image-20220821104242155"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6事事务以及集群</title>
      <link href="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>事物，锁机制</li><li>事物冲突问题</li><li>redis事物三特性</li><li>持久化框架</li><li>Redis主从复制</li><li>Redis集群</li><li>Redis应用问题解决</li></ul><h3 id="事物，锁机制："><a href="#事物，锁机制：" class="headerlink" title="事物，锁机制："></a>事物，锁机制：</h3><p>Redis事物：一个单独的隔离操作；事物中所有命令都会序列化，按顺序执行。事物执行过程中不会被其他客户端发送过来的命令请求打断</p><p>Redis事物主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p><h4 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi | Exec | discard"></a>Multi | Exec | discard</h4><p>输入Multi开启事务，此时被成为组队阶段，<strong>输入的命令不会马上执行</strong>，而是<strong>依次进入命令队列</strong>，直到输入Exec后，将命令队列中命令依次执行，组队过程中可以通过discard来放弃组队</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817101242222.png" alt="image-20220817101242222"></p><h4 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h4><ol><li>组队时命令发生错误，事物无法执行Exec后的命令语句，<strong>一个都不执行</strong></li><li>组队时无误，执行时出现部分错误，<strong>错误的不执行，其他的执行</strong></li></ol><h4 id="为什么需要做成事物："><a href="#为什么需要做成事物：" class="headerlink" title="为什么需要做成事物："></a>为什么需要做成事物：</h4><p>同一份数据被多处调用时，可能会使得值变得不合理，例如多人登录同一台TB账户购买东西，余额同时读取后再依次修改是不合理的</p><h3 id="事务冲突问题："><a href="#事务冲突问题：" class="headerlink" title="事务冲突问题："></a>事务冲突问题：</h3><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h4><p>每次拿数据时都认为别人会修改，所以每次拿取数据时就上锁，其他人拿数据时就会black（阻塞）直至开锁，<strong>牺牲性能换效果</strong></p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p><strong>添加版本信息</strong>，仅在修改信息时匹配版本是否一致，一致则成功修改，否则更新数据再执行</p><p><img src="/2022/08/16/Redis_6%E4%BA%8B%E5%8A%A1/image-20220817103825221.png" alt="image-20220817103825221"></p><h4 id="WATCH-K"><a href="#WATCH-K" class="headerlink" title="WATCH  K:"></a>WATCH  K:</h4><p>在执行multi之前，<strong>先执行watch k监视一个或多个key值</strong>，如果在事物执行之前这个key被改动，那么事务将会被打断</p><h3 id="Redis事务的三特性："><a href="#Redis事务的三特性：" class="headerlink" title="Redis事务的三特性："></a>Redis事务的三特性：</h3><ul><li>单独的隔离操作：事务中所有命令都会序列化，按顺序执行。事务在执行过程中不会被其他客户端发送的命令请求打断</li><li>没有隔离级别概念：队列中的命令没有提交之前都不会实际执行，因为事务提交前任何指令都不会执行</li><li>不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h3 id="持久化框架："><a href="#持久化框架：" class="headerlink" title="持久化框架："></a>持久化框架：</h3><h4 id="RDB（Redis-DataBase）："><a href="#RDB（Redis-DataBase）：" class="headerlink" title="RDB（Redis DataBase）："></a>RDB（Redis DataBase）：</h4><p>将指定时间间隔内将内存中数据集快照写入磁盘</p><h4 id="AOF（Append-Of-File）："><a href="#AOF（Append-Of-File）：" class="headerlink" title="AOF（Append Of File）："></a>AOF（Append Of File）：</h4><h3 id="主从复制："><a href="#主从复制：" class="headerlink" title="主从复制："></a>主从复制：</h3><h3 id="集群："><a href="#集群：" class="headerlink" title="集群："></a>集群：</h3><h3 id="应用问题："><a href="#应用问题：" class="headerlink" title="应用问题："></a>应用问题：</h3><h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><h4 id="分布式锁："><a href="#分布式锁：" class="headerlink" title="分布式锁："></a>分布式锁：</h4>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6基础</title>
      <link href="/2022/08/15/Redis_6/"/>
      <url>/2022/08/15/Redis_6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本片笔记适用于 <a href="https://space.bilibili.com/302417610">b站尚硅谷</a> 课程 <a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1">Redis 6 入门到精通 超详细 教程</a></p></blockquote><ul><li>NoSQl概述</li><li>行式&#x2F;列式数据库（大数据时代）</li><li>key键操作</li><li>5种基本数据类型</li><li>配置文件</li><li>发布与订阅</li><li>3种新数据类型</li></ul><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p><strong>基于K-V的高性能NoSQl数据库，提供了各种数据结构存储，具有高性能的多线功能</strong>，支持String（字符串） , list（链表） , set （集合）, zset（sorted set：有序集合） 和 hash（哈希类型）</p><p>Redis支持各种方式的<strong>排序</strong>，为了保证效率，<strong>数据都是存储在缓存中的</strong>，但Redis会<strong>周期性</strong>把更新的数据写入磁盘，在此基础上<strong>实现了master-slave（主从）同步</strong></p><p>Redis是 <strong>单线程 + 多路复用IO</strong> 技术；使用 <strong>6379端口</strong></p><h3 id="NoSql-数据库"><a href="#NoSql-数据库" class="headerlink" title="NoSql 数据库"></a>NoSql 数据库</h3><p>NoSQL （Not Only SQL）：意为“不仅仅是SQL”，泛指<strong>非关系型数据库</strong></p><p>NoSQL 不依赖业务逻辑存储方式，而是以简单的<strong>key-value</strong>模式存储，因此增加了数据库的扩展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><p>适用场景：</p><ul><li>对数据高并发读写</li><li>海量数据的读写</li><li>对数据高可扩展性</li></ul><p>不适用场景</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储</li></ul><p><strong>总之：用不着sql和用了sql也不行的情况，考虑Nosql</strong></p><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><p><img src="/2022/08/15/Redis_6/image-20220816091921656.png" alt="image-20220816091921656"></p><h3 id="列式数据库："><a href="#列式数据库：" class="headerlink" title="列式数据库："></a>列式数据库：</h3><p><img src="/2022/08/15/Redis_6/image-20220816092128015.png" alt="image-20220816092128015"></p><h3 id="Key键操作"><a href="#Key键操作" class="headerlink" title="Key键操作"></a>Key键操作</h3><pre><code class="redis">keys *//查看全部keyexists K//查找key是否存在，返回1：存在；返回0：不存在type K//查看key是什么类型del K//删除对应K-V,返回1：成功unlink K//非阻塞删除对应K-Vexpire K int//为给定的K设置过期时间ttl K//查看还有多久数据过期（取不到）返回-1:永不过期,返回-2：已经过期select int//切换库dbsize//查看当前数据库的key数量flushdb//清空当前库flushall//通杀全部库</code></pre><h3 id="5种基本数据类型："><a href="#5种基本数据类型：" class="headerlink" title="5种基本数据类型："></a>5种基本数据类型：</h3><ul><li>String（字符串）</li><li>List（链表）</li><li>Set（集合）</li><li>Hash（哈希）</li><li>Zset（有序集合）</li></ul><h4 id="String（字符串）："><a href="#String（字符串）：" class="headerlink" title="String（字符串）："></a>String（字符串）：</h4><p>string是 <strong>二进制安全</strong> 的,意味着Redis的string可以包含任何数据，包括jpg图片或者序列化对象。</p><p>string是Redis中最基本的数据类型，一个·Redis中的value最多可以是 <strong>512M</strong></p><p>string底层数据结构就是<strong>简单的动态字符串</strong>，结构上类似Java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配</p><p>在字符串长度小于1M时，扩容为每次扩大一倍，大于1M时，每次扩容1M</p><p><strong>常见命令</strong></p><pre><code class="redis">set K V//设置键值对/覆盖已有的K-V键值对get K//取出K对应的Vappend K V//在原有K对应的V`后添加Vstrlen K//获取K对应V的长度setnx K V//设置键值对，如果已有K，返回0：设置失败，否则返回1：设置成功mset K1 V1 K2 V2..//设置一个或多个键值对mget K1 k2..//取出一个或多个V值getrange K int1 int2//获取K对应V的int1-int2部分内容：从0开始setrange K int V//将K对应V的int之后部分添加V再接原字符setex K int V//设置K-V同时设置过期时间getset K V //获取旧值，同时将新值写入// 原子操作*incr K//将K对应V值+1；如果V不是数字类型返回0，否则返回+1后的值decr K//将K对应V值-1；...否则返回-1的值incrby K int//将K对应V值+int;...decrby K int//...-int...msetnx K1 V1 K2 V2//同时设置多个K-V,当且仅当key都不存在</code></pre><h6 id="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"><a href="#原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）" class="headerlink" title="原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）"></a>原子操作：不会被进程调度机制打断的操作，一旦开始就会运行到结束（能单条语句运行完的操作都是原子操作）</h6><p>注：java中的i++并非是原子操作</p><p>![image-20220816101653161](.&#x2F;Redis 6&#x2F;image-20220816101653161.png)</p><h4 id="List（链表）："><a href="#List（链表）：" class="headerlink" title="List（链表）："></a>List（链表）：</h4><p><strong>单键多值</strong> ，即一个K对应多个V。底层实现是 <strong>双向链表</strong> ，数据结构为 <strong>快速链表</strong>（quickList）即在列表元素较少时使用的结构式ziplist（压缩列表），它将所有元素挨在一起存储，分配一块连续的内存。当数据量较大时才会改为quicklist</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><pre><code class="redis">lpush K V1 V2...//从左边(头节点)加入一个或多个值rpush K V1 V2... //从右边(尾节点)加入一个或多个值lrange K int1 int2  //从左边取出int1-int2的数据(顺序)：0是第一个，-1是最后一个lpop K //从左边吐出一个值,值在键在，值光键亡rpop K //从右边吐出一个值,...rpoplpush K1 K2//从K1右边取出值加到K2左边lindex K int //按照索引下标获得元素llen K//获得列表长度linsert K before V1 V2 //在V1前添加一个V2linsert K after V1 V2 //在V1后添加一个V2lrem K int V//从左边删除int个Vlset K int V//将列表K下标为int的值替换为V</code></pre><h4 id="Set（集合）："><a href="#Set（集合）：" class="headerlink" title="Set（集合）："></a>Set（集合）：</h4><p>set可以 <strong>自动排重</strong> ，且提供了<strong>判断某个成员是否在一个set集合</strong>的接口。</p><p>Redis的set是String类型的<strong>无序集合</strong>，底层是一个<strong>value为null的hash表</strong>，所以添加，删除，查找复杂度都是O(1)</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">sadd K V1 V2...//将一个或多个members元素添加至key中，已存在的会被忽略smembers K//取出该集合的所有值sismember K V//判断K集合中是否右V值，有返回1，否则返回0scard K//返回集合元素个数srem K V1 V2//删除集合中的一个或多个元素spop K//随机从集合中取出一个值，值完键亡srandmemberK int//随机取出int个值，不会在集合中删除smove K1 K2 V1 V2...//将K1中元素V1，v2..移动到K2中，返回移动元素个数sinter K1 K2//返回两个集合的交集元素sunion K1 K2//返回两个集合的并集元素sdiff K1 K2//返回两个集合的差集元素（在K1而不在K2）</code></pre><h4 id="Hash（哈希）："><a href="#Hash（哈希）：" class="headerlink" title="Hash（哈希）："></a>Hash（哈希）：</h4><p>Redis Hash是一个<strong>键值对集合</strong>，其value对应一个<strong>String类型的field</strong>和value映射表，适合用于存储对象，类似Java中的Map&lt;String, Object&gt;</p><p>![image-20220816150802600](.&#x2F;Redis 6&#x2F;image-20220816150802600.png)</p><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">hset K field value//在K中添加一个field-value对hget K field//返回K中field对应的值hmset K f1 v1 f2 v2//在K中批量设置field-value对hexists K field//查看中是否存在fieldhkeys K//列出K集合中全部的fieldhvals K//列出K集合中全部的valuehincrby K field int //给K中的field对应value值hsetnx K field value//为K添加field-value对，如果field原本存在则不会添加</code></pre><h4 id="Zset（有序集合）："><a href="#Zset（有序集合）：" class="headerlink" title="Zset（有序集合）："></a>Zset（有序集合）：</h4><p>Zset与set相同，是 <strong>没有重复元素</strong> 的字符串集合。不同之处是Zset每个成员都关联了一个<strong>评分（score）</strong>,score用于按照从低到高的方式对集合成员进行排序。</p><p><strong>集合成员是唯一的，但评分可以重复</strong></p><h5 id="常用命令：-1"><a href="#常用命令：-1" class="headerlink" title="常用命令："></a><strong>常用命令：</strong></h5><pre><code class="redis">zadd K score1 v1 s2 v2//添加一个或多个评分-值zrange K int1 int2 //返回排序从int1到int2的值zrange K int1 int2 withscores //返回排序从int1到int2的值，同时返回评分zrangebyscore K int1 int2//返回score在int1至int2中间的值，可以加withscoreszrevrangebyscore K int1 int2//逆序返回score在int1至int2中间的值，可以加with...zincrby K int V//给K中V的score增加intzrem K V//删除指定值zcount K int1 int2//统计集合中在int1-int2中的元素个数zrank K V//返回该值在集合中的排名，从0开始</code></pre><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>配置文件：redis.conf</p><blockquote><p>vi &#x2F;etc&#x2F;redis.conf</p></blockquote><pre><code class="redis">bind 127.0.0.1#限制仅本地连接protected-mode yes#仅本地访问，改为no即可允许非本地访问port:6379#端口tcp-backlog 511#目前已经完成三次握手以及正在三次握手的队列timeout0#超时时限，设为0则永不超时tcp-keepalive 300#心跳监测连接，每隔300s检查一次daemonize yes#允许后台启动pidfile...#保存进程号的位子loglevel notice#log保护级别：debug&gt;verbose&gt;notice&gt;warninglogfile &quot;&quot;#日志输出路径，默认为空database 16#redis默认16个数据库，用户默认使用0号库#密码requirepass与客户端LIMITSmaxmemory 10000#最大内存maxmemory-sample 5#样本数量maxclients 10000#最大连接数#持久化设置</code></pre><h3 id="发布与订阅："><a href="#发布与订阅：" class="headerlink" title="发布与订阅："></a>发布与订阅：</h3><pre><code class="redis"># /usr/local/bin/redis-cliSUBSCRIBE channel1#订阅channel1频道publicsh  channels hello#使channel1发布消息“hello”</code></pre><p>一种消息的沟通模式：<strong>频道收到消息后，所有订阅的对象都会收到对应消息</strong></p><h3 id="3种新数据类型："><a href="#3种新数据类型：" class="headerlink" title="3种新数据类型："></a>3种新数据类型：</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps:"></a>Bitmaps:</h4><p>BitMaps本身就是字符串Key-Value，但是可以对字符串进行位运算，可以把Bitmaps想象为一个以位为单位的数组，数组只能存储0和1，数组下标在BotMaps中被成为偏移量，最左边为0.</p><h5 id="常用命令：-2"><a href="#常用命令：-2" class="headerlink" title="常用命令："></a>常用命令：</h5><pre><code class="redis">setbit K int1 int2#对K中int1号位子上改为int2（0/1）getbit K int#获取K中偏移量int中的值bitcount K#统计K中被设为1的数量bitcount K int1 int2 #统计K中int1到int2之间1的数量bitop and K1 K2#对K1，K2中为1的偏移量取与集，返回统计值bitop or K1 K2#对K1，K2中为1的偏移量取并集，...bitop not K1 K2#对K1，K2中为1的偏移量取差集，...bitop xor K1 K2#对K1，K2中为1的偏移量取异或，...</code></pre><p>![image-20220817090407369](.&#x2F;Redis 6&#x2F;image-20220817090407369.png)</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog:"></a>HyperLogLog:</h4><p>HyperLogLog只会根据输入元素计算*<strong>基数</strong>，不会存储输入元素本身</p><p><strong>基数</strong>：集合中不重复元素的总值被称为基数，如{1，6，3，4，3，9}，不重复元素为1，3，4，6，9 基数为5</p><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">pfadd K V1 V2#添加一个或多个元素pfcount K#统计基数pfmerge K1 K2 K3#将K2,K3中的值全部合并至K1</code></pre><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial:"></a>Geospatial:</h4><p>GEO:Geographic地理位置信息的缩写，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等操作</p><p>有效范围：经度：-180——180；纬度：-85——85</p><h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="redis">geoadd K int1 int2 V  #设置K中的V：经度为int1，纬度为int2geopos K V#获取K中V的经纬度geodist K V1 V2m#获取V1到V2的直线距离，以米做单位（km千米，mi英里,ft英尺）georadius K int1 int2 int3 km#对K中处于经度int1纬度int2方圆int3km内的信息返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法题</title>
      <link href="/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2022/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点："><a href="#1-给定两个树的节点node1和node2，找到他们最低的公共祖先节点：" class="headerlink" title="1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点："></a>1.给定两个树的节点node1和node2，找到他们最低的公共祖先节点：</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ol><li>遍历整个二叉树，将所有节点的父节点以&lt;Node，Node&gt;形式存入hashmap中</li><li>创建HashSet，从node1开始依据HashMap依次将自己的父节点存入HashSet中</li><li>从node2开始溯洄父节点，一旦存在HashSet中就停止，此时就是首个公共祖先节点</li></ol><pre><code class="java">//主函数public static Node finFather(Node head, Node node1, Node2) &#123;    HashMap&lt;Node,Node&gt; hashmap = new HashMap&lt;&gt;();    hashmap.put(head,head);     process(head,hashmap);    HashSet&lt;Node&gt; set1 = new HashSet&lt;&gt;();        Node o1 = node1;    //循环至头节点停下    while(o1 != hashmap.get(o1))&#123;        set1.add(o1);        o1 = hashmap.get(o1);    &#125;    //将头节点添加    set1.add(head);        Node o2 = node2;    while(set1.get(o2)==null)&#123;        o2 = hashmap.get(o2);    &#125;    return o2;&#125;//存储父节点函数public static void process(Node head, HashMap&lt;Node.Node&gt; hashmap) &#123;    if(hashmap == null) return;    hashmap.put(head.left,head);    hashmap.put(head.right,head);    process(head.left,hashmap);    process(head.right,hashmap);&#125;</code></pre><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>分析node1与node2可能的关系：</p><ol><li>node1是node2的祖先 &#x2F; node2是node1的祖先：返回node1 &#x2F; node2</li><li>node1与node2彼此不互为公共祖先，返回向上汇聚的祖先节点</li></ol><pre><code class="java">public static Node findFather(Node head, Node node1, Node node2) &#123;    if(head == null || head == node1 || head == node2) &#123;        return head;    &#125;    Node left = findFather(head.left, node1, node2);    Node right = findFather(head.right, node1, node2);    if(left != null &amp;&amp; right != null) &#123;        return head;    &#125;    return left != null ? left : right;&#125;</code></pre><h3 id="2-二叉树找到一个节点的后继节点："><a href="#2-二叉树找到一个节点的后继节点：" class="headerlink" title="2.二叉树找到一个节点的后继节点："></a>2.二叉树找到一个节点的后继节点：</h3><pre><code class="java">public class Node &#123;    public Node left;    public Node right;    public Node parent;//指向父节点    public int value;        public Node(int val) &#123;        this.value = val;    &#125;&#125;</code></pre><p><strong>后继节点</strong>：中序遍历二叉树后，每个节点的下一个节点是此节点的后继节点</p><p>（中序遍历打印每一位节点，相邻的后一个打印的节点是前一位的后继节点，相邻的前一节点是后一节点的前驱节点）</p><h5 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h5><p>中序遍历生成列表，依次查询列表找到后继节点</p><h5 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h5><p>分析后继节点的可能情况：</p><ol><li>当前节点存在右树：后继节点是右树的最左节点</li><li>当前节点没有右树：判断是否为父节点的左孩子：是，父节点为后继；不是，继续看父节点（没有右数说明已经是某左子树最后一个节点）</li><li>前两者无法找到后继节点：后继节点为空，这个节点是二叉树中序遍历的最后一个节点</li></ol><pre><code class="java">//主程序public static Node getNextNode(Node node) &#123;    if(node == null) return node;    if(node.right != null) &#123;//情况1        return getLeftMost(node);    &#125;else &#123;        Node parent = node.parent;        while(parent != null &amp;&amp; parent.left != node) &#123;//情况2和3            node = parent;            parent = node.parent;        &#125;        return parent;    &#125;&#125;//走左子树public static Node getLeftMost(Node node) &#123;    if(node == null) &#123;        return node;    &#125;    while(node.left != null) &#123;        node = node.left;    &#125;    return node;&#125;</code></pre><h3 id="3-二叉树序列化与反序列化"><a href="#3-二叉树序列化与反序列化" class="headerlink" title="3.二叉树序列化与反序列化"></a>3.二叉树序列化与反序列化</h3><p>内存 → 字符串 ：序列化</p><p>字符串 → 内存：反序列化</p><h5 id="先序序列化："><a href="#先序序列化：" class="headerlink" title="先序序列化："></a>先序序列化：</h5><pre><code class="java">public static String serialTree(Node head) &#123;    if(head == null) return &quot;#_&quot;;    String res = head.value + &quot;_&quot;;    res += serialTree(head.left);    res += serialTree(head.right);    return res;&#125;</code></pre><h5 id="先序反序列化："><a href="#先序反序列化：" class="headerlink" title="先序反序列化："></a>先序反序列化：</h5><pre><code class="java">//排序public static Node reconSerialTree(String str) &#123;    String[] values = str.split(&quot;_&quot;);    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    for(int i = 0; i != values.length; i++) &#123;        queue.add(values[i]);    &#125;    return reconOrder(queue);&#125;//组成树public static Node reconOrder(Queue&lt;String&gt; queue) &#123;    String value = queue.poll();    if(value.equals(&quot;#&quot;))&#123;        return null;    &#125;    Node head = new Node(Integer.valueOf(value));    head.left = reconOrder(queue);    head.right = reconOrder(queue);    return head;&#125;</code></pre><h5 id="中序，后序同理"><a href="#中序，后序同理" class="headerlink" title="中序，后序同理"></a>中序，后序同理</h5>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉数："><a href="#二叉数：" class="headerlink" title="二叉数："></a>二叉数：</h1><ul><li><p>二叉树递归遍历</p></li><li><p>二叉树非递归遍历</p></li><li><p>宽度优先遍历</p></li><li><p>搜索二叉树</p></li><li><p>完全二叉树</p></li><li><p>满二叉树</p></li><li><p>平衡二叉树</p><hr></li></ul><pre><code class="java">// 二叉树节点class Node&lt;V&gt; &#123;    V value;    Node left;    Node right;&#125;</code></pre><p>头节点：也叫根节点，二叉树最顶端的节点（无无父结点）</p><p>叶节点：左右子节点都为null</p><p>子树：以任意一节点为根，其衍生下可以直接相连或经过节点相连的全部节点组成的树</p><h3 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h3><h4 id="使用递归方式实现："><a href="#使用递归方式实现：" class="headerlink" title="使用递归方式实现："></a>使用递归方式实现：</h4><pre><code class="java">// 二叉树每个节点遍历时都有三次访问public static void f(Node head) &#123;    //1:start    if (head == null) &#123;        return null;    &#125;    ...    // 1:end    f(head.left);    // 2:start    ...    // 2:end    f(head.right);    // 3:start    ...    // 3:end&#125;</code></pre><p>*<strong>先序，中序，后序遍历即是在第一次，第二次，第三次访问节点时做反应</strong></p><p><img src="/2022/08/12/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220812185607833.jpg" alt="image-20220812185607833"></p><h5 id="遍历打印（每次访问打印一次value）："><a href="#遍历打印（每次访问打印一次value）：" class="headerlink" title="遍历打印（每次访问打印一次value）："></a>遍历打印（每次访问打印一次value）：</h5><p>1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1</p><h5 id="先序访问顺序（对每颗子树-头左右）："><a href="#先序访问顺序（对每颗子树-头左右）：" class="headerlink" title="先序访问顺序（对每颗子树 头左右）："></a>先序访问顺序（对每颗子树 头左右）：</h5><p>1 2 4 5 3 6 7</p><h5 id="中序访问顺序（对每颗子树-左头右）："><a href="#中序访问顺序（对每颗子树-左头右）：" class="headerlink" title="中序访问顺序（对每颗子树 左头右）："></a>中序访问顺序（对每颗子树 左头右）：</h5><p>4 2 5 1 6 3 7</p><h5 id="后序访问顺序（对每颗子树-左右头）："><a href="#后序访问顺序（对每颗子树-左右头）：" class="headerlink" title="后序访问顺序（对每颗子树 左右头）："></a>后序访问顺序（对每颗子树 左右头）：</h5><p>4 5 2 6 7 3 1</p><hr><h3 id="使用非递归方式实现二叉树："><a href="#使用非递归方式实现二叉树：" class="headerlink" title="使用非递归方式实现二叉树："></a>使用非递归方式实现二叉树：</h3><h5 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h5><ol><li>创建一个栈（Stack）对象，将头节点压入栈列</li><li>弹出栈顶节点 Car</li><li>打印处理 Car</li><li>先压入右节点，再压入左节点（有就压）</li><li>返回第二步，直至栈空</li></ol><pre><code class="java">//代码实现public static void preOrder(Node head) &#123;    if(head != null)&#123;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();        stack.push(head);        while(!stack.isEmpty()) &#123;            head = stack.pop();            System.out.println(head.value());            if(head.right != null) &#123;                stack.push(head.right);            &#125;            if(head.left != null) &#123;                stack.push(head.left);                    &#125;        &#125;    &#125;&#125;</code></pre><h5 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h5><ol><li>创建一个栈，将数的最左边界依次压入</li><li>弹出打印栈顶元素，若栈顶存在右子树，将右子树的最左边界依次压入</li><li>循环2，直至栈空</li></ol><pre><code class="java">public static void (Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();        while(!stack.isEmpty() || head != null) &#123;            if(head != null) &#123;                stack.push(head);                head = head.left;            &#125;else &#123;            head = stack.pop();            System.out.println(head.value());               head = head.right;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h5><ol><li>创建两个栈（存储栈和收集栈）</li><li>弹出存储栈头节点，压入收集栈</li><li>将2中弹出的节点，以先压左节点再压右节点的顺序压入存储栈</li><li>返回2，直到存储栈为空</li><li>依次打印收集栈顺序</li></ol><pre><code class="java">public static void posOrder(Node head) &#123;    if(head != null) &#123;        Stack&lt;Node&gt; st1 = new Stack&lt;&gt;();        Stacj&lt;Node&gt; st2 = new Stack&lt;&gt;();        st1.push(head);        while(!st1.isEmpty())&#123;            head = st1.pop();            st2.push(head);            if(head.left != null)&#123;                st1.push(head.left);            &#125;            if(head.right != null) &#123;                st1.push(head.right);            &#125;        &#125;        while(!st2.isEmpty())&#123;            System.out.println(st2.pop().value);        &#125;    &#125;&#125;</code></pre><hr><h3 id="实现二叉树的宽度优先遍历："><a href="#实现二叉树的宽度优先遍历：" class="headerlink" title="实现二叉树的宽度优先遍历："></a>实现二叉树的宽度优先遍历：</h3><h5 id="使用队列："><a href="#使用队列：" class="headerlink" title="使用队列："></a>使用队列：</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>弹出打印队列首个对象，将其左子树先放入队列，再放其右子树（如果有）</li><li>循环2，直到队列为空</li></ol><pre><code class="java">public static void widthOrder(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        System.out.println(head.value);        if(head.left != null) &#123;            queue.add(head.left);        &#125;        if(head.right != null) &#123;            queue.add(head.right);        &#125;    &#125;&#125;</code></pre><h5 id="算法题：求一个二叉树的最大宽度？"><a href="#算法题：求一个二叉树的最大宽度？" class="headerlink" title="算法题：求一个二叉树的最大宽度？"></a>算法题：求一个二叉树的最大宽度？</h5><ol><li>创建一个队列（Queue）对象，将头节点放入队列</li><li>创建一个hashMap对象，用于记录节点与当前所在深度，将&lt;head, 1&gt;记录</li><li>创建初始深度（int）设为1，初始节点数（int）设为0，初始最大值（int）设为Integer.MIN_VALUE;</li><li>弹出队列首个对象，并根据HashMap判断该节点是否是当前深度的节点，是：节点数++，否：最大值&#x3D;max（max，节点数），深度++，节点数设为1</li><li>将其左子树先放入队列，hashMap放入&lt;head.left，深度+1&gt;；再放其右子树，hashMap放入&lt;head.right，深度+1&gt;（如果有）</li><li>循环2-5，直到队列为空</li><li>调用Max函数计算最后一行节点个数和最大节点的比较</li></ol><pre><code class="java">public static void getMaxWidth(Node head) &#123;    if(head == null) return;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    HashMap&lt;Node,Integer&gt; levelMap = new HashMap&lt;&gt;();    levelMap.put(head,1);    int curlevel = 1;//当前层数    int curNodeNum = 0;//当前节点数    int max = Integer.MIN_VALUE;//最大节点值    while(!queue.isEmpty()) &#123;        head = queue.poll();        int levelNode = levelMap.get(head);        if(levelNode == curlevel) &#123;//判断是否变层            cerNodeNum ++;//未变层，节点数++        &#125;else &#123;            max = Math.max(max, curNodeNum);//下一层，结算上一层的max，重置当前节点数            curLevel ++;            curNodeNum = 1;        &#125;        if(head.left != null) &#123;            queue.add(head.left);            levelMap.put(head.left,curlevel+1)//记录左子树以及其对应层，用于后续判断        &#125;        if(head.right != null) &#123;            queue.add(head.right);            levelMap.put(head.right,curlevel+1)//记录右子树以及其对应层，用于后续判断        &#125;    &#125;    max = Math(max, curNodeNum);&#125;</code></pre><h5 id="不使用哈希表完成上述题目："><a href="#不使用哈希表完成上述题目：" class="headerlink" title="*不使用哈希表完成上述题目："></a>*不使用哈希表完成上述题目：</h5><p>使用两个Node变量替代哈希表（当前层最后的节点，下一层最后的节点）</p><p>将head赋予当前层最后节点，在每次新添左右节点时，分别更新下一层最后节点为左右节点</p><p>每次队列弹出都检查是否是当前层最后节点，是：更新最大值，拷贝下一层最后节点至当前层最后节点，层数++；否：节点数++</p><h3 id="二叉树深度优先遍历：先序遍历"><a href="#二叉树深度优先遍历：先序遍历" class="headerlink" title="二叉树深度优先遍历：先序遍历"></a>二叉树深度优先遍历：先序遍历</h3><hr><h3 id="搜索二叉树："><a href="#搜索二叉树：" class="headerlink" title="搜索二叉树："></a>搜索二叉树：</h3><p>对于每一个子树，都满足其左树值比根节点值小，右树值比根节点大（一般不存在重复值）</p><h5 id="如何判断是否是搜索二叉树：中序遍历为升序"><a href="#如何判断是否是搜索二叉树：中序遍历为升序" class="headerlink" title="如何判断是否是搜索二叉树：中序遍历为升序"></a>如何判断是否是搜索二叉树：中序遍历为升序</h5><pre><code class="java">public static int prevalue = Integer.MIN_VALUE;public static boolean isBSt(Node head) &#123;    if(head == null) return true;    boolean isLeftBst = isBST(head.left);//左子树是否为搜索二叉树    if(!isLeftBst) return false;    if(head.value &lt;= preValue) &#123;//升序判断，动态检查        return false;    &#125;else &#123;        preValue = head.value;    &#125;    return isBST(head.right);//左子树是搜索二叉树，右子树是否为搜索二叉树&#125;</code></pre><p>非遍历判断同理</p><h5 id="总结返回信息："><a href="#总结返回信息：" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左子树：1.左树应是搜索二叉树2.获取左数的最大值（用于与根比较）</p><p>对于右子树：1.右树应是搜索二叉树2.获取右数的最小值（用于与根比较）</p><p>统一左右子树返回信息：是否是搜索二叉树，最小值，最大值</p><h5 id="判断是否为搜索二叉树："><a href="#判断是否为搜索二叉树：" class="headerlink" title="判断是否为搜索二叉树："></a>判断是否为搜索二叉树：</h5><pre><code class="java">public static boolean checkBST(Node head) &#123;    return process(head).isBST;&#125;//返回类型public static class ReturnType &#123;    public boolean isBST;    public int min;    public int max;        public ReturnData(boolean isb, int min, int max)&#123;        this.isBST = isb;        this.min = min;        this.max = max;    &#125;&#125;public static ReturnType process(Node x) &#123;    if(x == null) return null;    ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);    //获得整个子树的最大最小值    int min = x.value;    int max = x.value;    if(leftData != null) &#123;        min = Math.min(min,leftData.min);        max = Math.max(max,leftData.max);    &#125;    if(rightData != null) &#123;        min = Math.min(min,rightData.min);        max = Math.max(max,rightData.max);    &#125;           boolean isBST = true;    if(leftData != null &amp;&amp; (!leftData.isBST || leftData.max &gt;= x.value) &#123;        isBST = false;    &#125;    if(rightData != null &amp;&amp; (!rightData.isBST || x.value &gt;= rightData.min) &#123;        isBST = false;    &#125;       return new ReturnType(isBST,min,max);&#125;</code></pre><h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p>所有节点依次按从左往右依次放入的二叉树属于完全二叉树</p><ol><li>任意一节点有右孩子无左孩子 → 不是完全二叉树</li><li><strong>宽度优先遍历</strong>且在<strong>不违反1</strong>前提下，出现首个左右孩子不双全时，之后的节点都应该是叶子节点</li></ol><pre><code class="java">public static boolean isCBT(Node head) &#123;    if(head == null) return true;    //是否遇到过左右孩子不双全的判断    boolean leaf = false;    Node l = null;    Node r = null;    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();    queue.add(head);    while(!queue.isEmpty()) &#123;        head = queue.poll();        l = head.left;        r = head.right;        if((leaf &amp;&amp; (l!=null || r!=null))//条件2          ||           (l == null &amp;&amp; r == null)//条件1          )&#123;            return false;        &#125;        if(l != null) &#123;            queue.add(l);        &#125;        if(r != null) &#123;            queue.add(r);        &#125;        if(l == null || r == null) &#123;            //leaf 为不可逆改变            leaf = true;        &#125;       &#125;    return true;&#125;</code></pre><h3 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h3><p>子节点要么都有，要么都没有，不存在只存在一边节点的二叉树</p><h5 id="判断是否为满二叉树："><a href="#判断是否为满二叉树：" class="headerlink" title="判断是否为满二叉树："></a>判断是否为满二叉树：</h5><pre><code class="java">public static boolean isFBT(Node head) &#123;    if(head == null) &#123;        return true;    &#125;    info data = process(head);    return data.nodes == ((1&lt;&lt;data.height) - 1);&#125;//返回信息public static class Info &#123;    public int height;//高度    public int nodes;//节点数        public Info(int hei, int nod) &#123;        this.height = hei;        this.nodes = nod;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static Info process(Node x) &#123;    if(x == null) &#123;        return new Info(0, 0);    &#125;        Info leftData = process(x.left);    Info rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    int nodes = leftData.nodes + rightData.nodes + 1;        return new Info(height, nodes);&#125;</code></pre><h3 id="平衡二叉树："><a href="#平衡二叉树：" class="headerlink" title="平衡二叉树："></a>平衡二叉树：</h3><p>对于任意一颗子树，其左树高度和右树高度差不少过1</p><ol><li>节点左树是平衡二叉树</li><li>节点右树是平衡二叉树</li><li>|节点左树高度 - 节点右数高度| &lt;&#x3D; 1</li></ol><p>以上条件对每个节点都成立，这个树就是平衡二叉树，否则不是</p><h5 id="总结返回信息：-1"><a href="#总结返回信息：-1" class="headerlink" title="总结返回信息："></a>总结返回信息：</h5><p>对于左树，我们希望知道：1.左树是否是平衡二叉树2.左树高度</p><p>对于右数，我们希望知道：1.右树是否是平衡二叉树2.右数高度</p><p>左右树需要的信息一致；</p><h5 id="判断是否为平衡二叉树："><a href="#判断是否为平衡二叉树：" class="headerlink" title="判断是否为平衡二叉树："></a>判断是否为平衡二叉树：</h5><pre><code class="java">//返回值的变动，调用其他方法返回public static boolean isBT(Node head) &#123;    return process(head).isBalanced;&#125;//返回信息public static class ReturnType &#123;    public boolean isBalanced;//是否是平衡二叉树    public int height;//高度        public ReturnType(boolean isB, int hei) &#123;        this.isBalanced = isB;        this.height = hei;    &#125;&#125;//过程函数，返回类型为ReturnTypepublic static ReturnType process(Node x) &#123;    if(x == null) &#123;        return new ReturnType(true, 0);    &#125;        ReturnType leftData = process(x.left);    ReturnType rightData = process(x.right);        int height = Math.max(leftData.height,rightData.height)+1;    boolean isBalance = leftData.isBalanced &amp;&amp; rightData.isBalanced                        &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; 2;        return new ReturnType(isBalance, height);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%803_%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h1><ul><li>类，超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装器与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射</li><li>继承的设计技巧</li></ul><h3 id="类，超类和子类："><a href="#类，超类和子类：" class="headerlink" title="类，超类和子类："></a>类，超类和子类：</h3><h5 id="使用关键字：extends-表示继承"><a href="#使用关键字：extends-表示继承" class="headerlink" title="使用关键字：extends 表示继承"></a>使用关键字：extends 表示继承</h5><pre><code class="java">public class A extends B &#123;    ...&#125;</code></pre><p>超类 &#x3D; 基类 &#x3D; 父类子类 &#x3D; 孩子类</p><h5 id="使用父类的方法：-super"><a href="#使用父类的方法：-super" class="headerlink" title="使用父类的方法： super"></a>使用父类的方法： super</h5><pre><code class="java">super.fun();//使用父类的fun方法super();//使用父类的构造器方法</code></pre><h5 id="多态：可将子类对象赋予给超类变量"><a href="#多态：可将子类对象赋予给超类变量" class="headerlink" title="多态：可将子类对象赋予给超类变量"></a>多态：可将子类对象赋予给超类变量</h5><pre><code class="java">Employee e;//Manager extends Employeee = new Employee();//OKe = new Manager();      //ok</code></pre><p>强制类型转换：A a &#x3D; (A) b;后续使用可能会报错</p><p>在超类强转为子类前可以使用：instanceof 监测是否能强转</p><pre><code class="java">if(b instanceof a)&#123;//如果b能强转为a，就可以将b转为a给予其他变量使用    c = (a)b;&#125;</code></pre><h5 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h5><p>使用abstract关键字的方法不需要具体实现</p><p>含有抽象方法的对象必须为抽象对象，抽象对象不可以被实例化</p><h3 id="Object：所有子类的超类"><a href="#Object：所有子类的超类" class="headerlink" title="Object：所有子类的超类"></a>Object：所有子类的超类</h3><h5 id="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"><a href="#equals方法：监测对象是否相等，比较对象的各个属性而非具体地址" class="headerlink" title="equals方法：监测对象是否相等，比较对象的各个属性而非具体地址"></a>equals方法：监测对象是否相等，比较对象的各个属性而非具体地址</h5><h5 id="hashCode方法：散列码，由对象导出的整型数"><a href="#hashCode方法：散列码，由对象导出的整型数" class="headerlink" title="hashCode方法：散列码，由对象导出的整型数"></a>hashCode方法：散列码，由对象导出的整型数</h5><p>每个对象的散列码基本不相同，可以用作区分不同对象的标识</p><h5 id="toString方法：返回字符串类型对象信息"><a href="#toString方法：返回字符串类型对象信息" class="headerlink" title="toString方法：返回字符串类型对象信息"></a>toString方法：返回字符串类型对象信息</h5><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><h5 id="ArrayList：自定义类型数组"><a href="#ArrayList：自定义类型数组" class="headerlink" title="ArrayList：自定义类型数组"></a>ArrayList：自定义类型数组</h5><pre><code class="java">ArrayList&lt;ClassName&gt; a = new ArrayLisrt&lt;&gt;();//ArrayList数组中全是ClassName类型对象var b = new ArrayList&lt;ClassName&gt;();//效果同上，java 10以后可以使用var避免重复书写类名</code></pre><p>使用trimToSIze()方法裁剪数组多余部分</p><h5 id="数组列表访问对象："><a href="#数组列表访问对象：" class="headerlink" title="数组列表访问对象："></a>数组列表访问对象：</h5><pre><code class="java">var A = new ArrayList&lt;ClassB&gt;();A.set(i,Obj);//使用set方法赋值，第几位，赋什么A.get(i);//获得第几位的信息A.size();//获取列表数量，不可以用length</code></pre><h3 id="对象包装器和自动包装"><a href="#对象包装器和自动包装" class="headerlink" title="对象包装器和自动包装"></a>对象包装器和自动包装</h3><p>有时会需要将int这样的基本类转换为对象，我们称这样的类为包装器：<br><strong>int - Integetlong - Longfloat - Floatdouble - Doubleshort - Shortchar -  Characterboolean - Boolean</strong></p><p>前六个类派生于公类Number</p><p>包装器类是不可变的，一旦构造便不允许更改其包装在其中的值，同时包装器也是final，不可以派生子类</p><pre><code class="java">ArrayList&lt;int&gt; ... //是错误的ArrayList&lt;Integer&gt; ... //是正确的</code></pre><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>在类后加上… 即可</p><pre><code class="java">public static double max(double... values)&#123;    double larger = Double.NEGATIVE_INFINITY    for(double v : values) if (v&gt;larger) larger = v;    return larger;&#125;double a = max(3.1, 40.2, -5);</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code class="java">public enum Size &#123; SMALL, MEDIUM, LAGER, EXTRA_LARGE &#125;;//枚举的各个方法static Enum valueOf(Class enumClass, String name)//返回给定类中有指定名字的枚举常量String toString()//返回枚举常量名int ordinal()//返回枚举常量在enum声明中的位子，从0开始记数int compareTo(E other)//如果枚举常量在other之前，返回负整数；如果other==this,返回0；否则返回正整数。枚举常量次序在enum声明中给出</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序被成为反射</p><h5 id="Class类："><a href="#Class类：" class="headerlink" title="Class类："></a>Class类：</h5><pre><code class="java">Employee A;Class cl = a.getClass();//保存一个Class类型实例，可以使用对应方法，如getName()String name = cl.getName();//name = &quot;Employee&quot;String ckassName = &quot;java.util.Random&quot;;Class cl = Class.forName(className);//效果同上Class c1 = Employee.class;//效果同上</code></pre><h5 id="异常：非检查型异常（unchecked），检查型异常（checked）"><a href="#异常：非检查型异常（unchecked），检查型异常（checked）" class="headerlink" title="异常：非检查型异常（unchecked），检查型异常（checked）"></a>异常：非检查型异常（unchecked），检查型异常（checked）</h5><p>异常可以通过在类名后添加 throws … 对应语句</p><h5 id="资源-："><a href="#资源-：" class="headerlink" title="资源 ："></a>资源 ：</h5><pre><code class="java">Class cl = ResourceTest.class;URL url = cl.getResource(&quot;b.gif&quot;);...//多种方法</code></pre><h5 id="检查类的结构：FIeld，Method，Constructor"><a href="#检查类的结构：FIeld，Method，Constructor" class="headerlink" title="检查类的结构：FIeld，Method，Constructor"></a>检查类的结构：FIeld，Method，Constructor</h5><p>java.lang.reflect 中的三个方法：FIeld，Method，Constructor 分别用于返回 字段，方法 和 构造器 的名称</p><p>其中：getDeclareFields，getDeclareMethods，getDeclareConstructors 返回声明中的全部字段，方法，构造器的数组</p><p>通过setAccessible方法可以覆盖Java的访问控制，避免私有属性调用报错</p><h5 id="newInstance方法："><a href="#newInstance方法：" class="headerlink" title="newInstance方法："></a>newInstance方法：</h5><p>提供Array的元素类型，提供数组长度即可生成对应数组</p><h5 id="invoke方法："><a href="#invoke方法：" class="headerlink" title="invoke方法："></a>invoke方法：</h5><p>允许调用Method中的方法</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%804_%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口，lambda表达式与内部类"><a href="#接口，lambda表达式与内部类" class="headerlink" title="接口，lambda表达式与内部类"></a>接口，lambda表达式与内部类</h1><ul><li>接口</li><li>lambda表达式</li><li>内部类</li><li>服务加载器 (null)</li><li>代理</li></ul><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>使用关键字： interface (定义接口)， implements (实现接口)</p><p>接口中的方法自动为public，写接口时不需要赋予public权限词</p><h5 id="实现接口需要实现其全部方法"><a href="#实现接口需要实现其全部方法" class="headerlink" title="实现接口需要实现其全部方法"></a>实现接口需要实现其全部方法</h5><pre><code class="java">interface A;class B implements A;A a = new A();//错误A b;b = new B();//正确,可以声明接口变量，实例化为实现接口的对象</code></pre><h5 id="java是单继承，每个类只能有一个超类，但能实现很多接口"><a href="#java是单继承，每个类只能有一个超类，但能实现很多接口" class="headerlink" title="java是单继承，每个类只能有一个超类，但能实现很多接口"></a>java是单继承，每个类只能有一个超类，但能实现很多接口</h5><p>*使用 static ，private 关键词创造静态私有方法</p><p>使用 default 关键字创造默认方法，可以直接在接口中提供默认实现</p><pre><code class="java">public interface Comparable&lt;T&gt;&#123;    default int compareTo(T other)&#123; return 0; &#125;&#125;</code></pre><h5 id="默认方法冲突："><a href="#默认方法冲突：" class="headerlink" title="默认方法冲突："></a>默认方法冲突：</h5><ol><li>超类优先：如果超类提供了一个具体方法，同名且有相同参数的默认方法会被忽略</li><li>接口冲突：两个接口提供了同名同参的方法时，必须覆盖这个方法依解决问题（声明实现其中一个）</li></ol><h3 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="*lambda表达式："></a>*lambda表达式：</h3><p>目的： 方便的传递代码块</p><pre><code class="java">// 有参数lambda表达式(String first, String second) -&gt;&#123;    if(first.length() &lt; second.length()) return -1;    else if(first.length() &gt; second.length) return 1;    else return 0;&#125;// 无参数lambda表达式() -&gt;&#123;    for(int i=0; i&lt;100; i++)        System.out.println(i);&#125;//方法引用 (::)...//构造器引用 (new)</code></pre><h5 id="Comparing比较器"><a href="#Comparing比较器" class="headerlink" title="Comparing比较器"></a>Comparing比较器</h5><h3 id="内部类："><a href="#内部类：" class="headerlink" title="*内部类："></a>*内部类：</h3><p>内部类是定义在另一个类中的类，可以简洁的回调：</p><ol><li>内部类对同一个包中的其他类隐藏</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原有的私有数据</li></ol><h5 id="外围类引用：OuterClass-this"><a href="#外围类引用：OuterClass-this" class="headerlink" title="外围类引用：OuterClass.this"></a>外围类引用：OuterClass.this</h5><h5 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h5><p>不仅在类中，同时在局部（方法）中定义类，被称为局部内部类</p><h5 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h5><p>直接new对象并给定义（属性方法）不用设类名</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><p>将内部类声明为static就不会产生引用</p><h3 id="服务加载器："><a href="#服务加载器：" class="headerlink" title="服务加载器："></a>服务加载器：</h3><p>null</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理类包含以下方法：</p><ul><li>指定接口所需要的全部方法</li><li>Object类中的全部方法，如toString，equals等</li></ul><p>创建代理对象需要使用 Proxy 类的newProxyInstance方法，对应的三个参数为：</p><ul><li>一个类加载器 （class loader）</li><li>一个Class对象数组</li><li>一个调用处理器</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与类</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%802_%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="对象与类："><a href="#对象与类：" class="headerlink" title="对象与类："></a>对象与类：</h1><ul><li>面向对象程序设计概述</li><li>适用预定义类</li><li>用户自定义方法</li><li>静态字段与静态方法</li><li>方法参数</li><li>对象构造</li><li>包</li><li>JAR文件</li><li>文档注释</li><li>类设计技巧</li></ul><h3 id="面向对象程序设计概述-OOP"><a href="#面向对象程序设计概述-OOP" class="headerlink" title="面向对象程序设计概述(OOP)"></a>面向对象程序设计概述(OOP)</h3><h5 id="类：存储数据字段和方法的摸具"><a href="#类：存储数据字段和方法的摸具" class="headerlink" title="类：存储数据字段和方法的摸具"></a>类：存储数据字段和方法的摸具</h5><h5 id="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"><a href="#封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法" class="headerlink" title="封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法"></a>封装：是处理对象的一个重要概念，将数据与行为组合在一个包中，并对对象使用者隐藏具体实现的方法</h5><h5 id="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"><a href="#对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）" class="headerlink" title="对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）"></a>对象：（行为：可以做什么方法，状态：使用不同方法对象会如何响应，标识：如何区分相同信息的不同对象）</h5><h5 id="识别类：Item，Order等为人熟悉的人为设计类"><a href="#识别类：Item，Order等为人熟悉的人为设计类" class="headerlink" title="识别类：Item，Order等为人熟悉的人为设计类"></a>识别类：Item，Order等为人熟悉的人为设计类</h5><h5 id="类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a"><a href="#类之间的关系：依赖（uses-a），聚合-has-a-，继承-is-a" class="headerlink" title="类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)"></a>类之间的关系：依赖（uses-a），聚合(has-a)，继承(is-a)</h5><h3 id="使用预定义类："><a href="#使用预定义类：" class="headerlink" title="使用预定义类："></a>使用预定义类：</h3><p>使用构造器（constructor 构造函数）在目标类前加上 new 操作符</p><p>表示时间点的Date类</p><p>*表示日历的LocalDate类</p><h3 id="用户自定义类与自定义方法："><a href="#用户自定义类与自定义方法：" class="headerlink" title="用户自定义类与自定义方法："></a>用户自定义类与自定义方法：</h3><p>使用class关键字自定义类</p><p>“javac className*.java”与”javac classNameTest.java”都可以视为编译className类</p><h5 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h5><ul><li>构造器需要与类名同名</li><li>每个类可以有一个以上的构造器（0，1，2…个不同参数）</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作符一起调用</li></ul><p>var声明局部变量：仅能用于方法中，参数与字段仍需要声明</p><h5 id="实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"><a href="#实例字段-final-类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改" class="headerlink" title="实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改"></a>实例字段 final:类中的属性添加final后，这样的字段必须在构造对象时初始化，且不可再修改</h5><h3 id="静态字段与静态方法："><a href="#静态字段与静态方法：" class="headerlink" title="静态字段与静态方法："></a>静态字段与静态方法：</h3><p>静态常量：static final</p><p>静态方法：static</p><p>工厂方法：使用静态方法构造对象</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>形参与实参</p><h3 id="对象构造："><a href="#对象构造：" class="headerlink" title="对象构造："></a>对象构造：</h3><h5 id="重载：多个方法具有相同的函数名，不同的参数"><a href="#重载：多个方法具有相同的函数名，不同的参数" class="headerlink" title="重载：多个方法具有相同的函数名，不同的参数"></a>重载：多个方法具有相同的函数名，不同的参数</h5><h5 id="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）"><a href="#默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0-false-null等）" class="headerlink" title="默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）"></a>默认字段初始化：构造器中未赋予初值的对象会被赋予默认值（0,false,null等）</h5><h5 id="调用其他构造器：this-…"><a href="#调用其他构造器：this-…" class="headerlink" title="调用其他构造器：this(…)"></a>调用其他构造器：this(…)</h5><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><h5 id="英特网域名的作用之一就是保证-包名的唯一性"><a href="#英特网域名的作用之一就是保证-包名的唯一性" class="headerlink" title="英特网域名的作用之一就是保证 包名的唯一性"></a>英特网域名的作用之一就是保证 包名的唯一性</h5><h5 id="引入类的方法："><a href="#引入类的方法：" class="headerlink" title="引入类的方法："></a>引入类的方法：</h5><ol><li>直接使用 包名.类名</li><li>提前使用import声明引入包类</li></ol><p>包访问权限（public-全部，private-本类，protected-本包与子类，默认-本包）</p><h5 id="包-类路径：设置类路径-classpath（命令行指令）"><a href="#包-类路径：设置类路径-classpath（命令行指令）" class="headerlink" title="包.类路径：设置类路径 -classpath（命令行指令）"></a>包.类路径：设置类路径 -classpath（命令行指令）</h5><h3 id="JAR文件（java归档文件）："><a href="#JAR文件（java归档文件）：" class="headerlink" title="JAR文件（java归档文件）："></a>JAR文件（java归档文件）：</h3><p>jar文件是一种zip压缩文件</p><p>*目前常使用maven等协助打包</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>注释要写全，写细</p><h3 id="类设计技巧："><a href="#类设计技巧：" class="headerlink" title="类设计技巧："></a>类设计技巧：</h3><ol><li>保证数据私有</li><li>对数据进行初始化</li><li>不要在类中使用过多的基本类型</li><li>不是所有字段都需要单独的字段访问器和字段更改器</li><li>分解有过多指责的类</li><li>类名与方法名要能体现他们的职责</li><li>优先使用不可变的类</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计结构</title>
      <link href="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序设计结构"><a href="#Java程序设计结构" class="headerlink" title="Java程序设计结构"></a>Java程序设计结构</h1><ul><li>数据类型</li><li>变量与常量</li><li>运算符</li><li>字符串</li><li>输入输出</li><li>控制流</li><li>大数</li><li>数组</li></ul><h4 id="保留字与关键字："><a href="#保留字与关键字：" class="headerlink" title="保留字与关键字："></a>保留字与关键字：</h4><p>关键字：目前已经有特殊作用的单词字符，例如static，class等</p><p>保留字：包括关键字，同时还有部分目前未被使用，但未来可能会被使用的单词字符</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>八种基本类型，包括</p><ul><li><p>四种整型：int（四字节，正负21e），short（二字节，正负三万二），</p><p>​long（八字节，正负900ee），byte（一字节，-128—127）</p></li><li><p>两种浮点型：float（四字节），double（八字节）</p></li><li><p>一种字符型：char（二字节），用于表示Unicode编码的代码单元</p></li><li><p>一种用于表真值：boolean</p></li></ul><p>浮点数遵循IEEE 754规范：</p><p>NAN为非数字，例如0&#x2F;0会得到Double.NAN；</p><p>无穷大（正负）是特殊浮点Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY</p><h3 id="变量与常量："><a href="#变量与常量：" class="headerlink" title="变量与常量："></a>变量与常量：</h3><h5 id="变量：需要显式初始化变量"><a href="#变量：需要显式初始化变量" class="headerlink" title="变量：需要显式初始化变量"></a>变量：需要显式初始化变量</h5><pre><code class="java">boolean flag = false;</code></pre><h5 id="常量：使用关键字-static-final-设置常量，"><a href="#常量：使用关键字-static-final-设置常量，" class="headerlink" title="常量：使用关键字 static final 设置常量，"></a>常量：使用关键字 static final 设置常量，</h5><pre><code class="java">public static final int age = 18;</code></pre><h5 id="枚举类型：在有限集合内取值可以自定义枚举类型"><a href="#枚举类型：在有限集合内取值可以自定义枚举类型" class="headerlink" title="枚举类型：在有限集合内取值可以自定义枚举类型"></a>枚举类型：在有限集合内取值可以自定义枚举类型</h5><pre><code class="java">enum Size &#123; SMALL，MEDIUM，LARGE，EXTRA_LARGE &#125;;Size a = SIze.SMALL;</code></pre><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><h5 id="算数运算符（加减乘除余）：-x2F"><a href="#算数运算符（加减乘除余）：-x2F" class="headerlink" title="算数运算符（加减乘除余）：+ - * &#x2F; %"></a>算数运算符（加减乘除余）：+ - * &#x2F; %</h5><p>int类型会向下取整</p><h5 id="数学函数："><a href="#数学函数：" class="headerlink" title="数学函数："></a>数学函数：</h5><p>Math.sqrt（int a）：对a求平方根</p><p>Math.abs（int a） ：对a取绝对值</p><p>Math.round（double a）：对a四舍五入转为整型int</p><h5 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h5><p><img src="/2022/08/11/java%E5%9F%BA%E7%A1%801_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/changeSize.jpg" alt="changeSize"></p><p>实线为无信息丢失的转换，虚线为存在精度丢失的转换</p><h5 id="关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D"><a href="#关系运算符：-x3D-x3D-，！-x3D-，-，-amp-amp-，-lt-，-gt-，-lt-x3D-，-gt-x3D" class="headerlink" title="关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;"></a>关系运算符：&#x3D;&#x3D;，！&#x3D;，||，&amp;&amp;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;</h5><h5 id="位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt"><a href="#位运算符（与，或，非，反，左移，右移）：-amp-a-，-a-，-a-，-a-，-lt-lt-，-gt-gt" class="headerlink" title="位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;"></a>位运算符（与，或，非，反，左移，右移）：&amp;(a)，|(a)，^(a)，~(a)，&lt;&lt;，&gt;&gt;</h5><h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><h5 id="子串：（subString方法）"><a href="#子串：（subString方法）" class="headerlink" title="子串：（subString方法）"></a>子串：（subString方法）</h5><pre><code class="java">String str = &quot;Hello&quot;;String s = str.subString(0,3);//s = &quot;Hel&quot;,即0到2</code></pre><h5 id="相等：-equals方法"><a href="#相等：-equals方法" class="headerlink" title="相等：(equals方法)"></a>相等：(equals方法)</h5><pre><code class="java">if(str.equals(s))&#123;    return false;&#125;</code></pre><h5 id="空串与Null串："><a href="#空串与Null串：" class="headerlink" title="空串与Null串："></a>空串与Null串：</h5><pre><code class="java">if(str.length() == 0)//判断是否为空串：“”if(str == null)//判断是否为null串</code></pre><h5 id="构建字符串：（Stringbuilder类）"><a href="#构建字符串：（Stringbuilder类）" class="headerlink" title="构建字符串：（Stringbuilder类）"></a>构建字符串：（Stringbuilder类）</h5><pre><code class="java">//节省空间和时间的字节构建类型，直接append添加,toString成符StringBuilder bs = new StringBuilder();bs.append(&quot;a&quot;);bs.append(&quot;b&quot;);String s = bs.toString();</code></pre><h3 id="输入和输出："><a href="#输入和输出：" class="headerlink" title="输入和输出："></a>输入和输出：</h3><h5 id="Util-Scanner类："><a href="#Util-Scanner类：" class="headerlink" title="Util.Scanner类："></a>Util.Scanner类：</h5><pre><code class="java">Scanner in = new Scanner(System.in);String name = in.nextLine();int age = in.nextInt();</code></pre><h5 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h5><pre><code class="java">double x = 10000 / 3.0;System.out.printf(&quot;%8.2f&quot;,x);//返回八个字符，小数点算一个，且返回小数点后两位，不够八位在前补充空格                                //x = 3333.33      </code></pre><h5 id="转换符："><a href="#转换符：" class="headerlink" title="转换符："></a>转换符：</h5><p>d：十进制x：十六进制o：八进制f：定点浮点数e：指数浮点数    ….</p><h3 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h3><h5 id="块作用域：-…"><a href="#块作用域：-…" class="headerlink" title="块作用域：{…}"></a>块作用域：{…}</h5><p>块内变量不会带到块外使用，块外已定义变量不允许块内重复定义</p><h5 id="判断：if，if-else，if-else-if-else"><a href="#判断：if，if-else，if-else-if-else" class="headerlink" title="判断：if，if-else，if-else if-else"></a>判断：if，if-else，if-else if-else</h5><h5 id="循环：for，-while，-do-while"><a href="#循环：for，-while，-do-while" class="headerlink" title="循环：for， while， do-while"></a>循环：for， while， do-while</h5><h5 id="多重选择：switch-case-default"><a href="#多重选择：switch-case-default" class="headerlink" title="多重选择：switch-case-default"></a>多重选择：switch-case-default</h5><h5 id="跳出：return，break，continue"><a href="#跳出：return，break，continue" class="headerlink" title="跳出：return，break，continue"></a>跳出：return，break，continue</h5><h3 id="大数："><a href="#大数：" class="headerlink" title="大数："></a>大数：</h3><p>java.Math包下的：BigInteger和Bigdecimal（比int和double都更加精确）</p><pre><code class="java">BigDecimal a = new BigDecimal(&quot;0.1&quot;);//String转Big,精确BigDecimal a = new BigDecimal(0.1);//Double转Big,不精确，可能变成0.0999999998之类的</code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h5 id="声明与初始化："><a href="#声明与初始化：" class="headerlink" title="声明与初始化："></a>声明与初始化：</h5><pre><code class="java">int[] a;//声明int[] b = new int[100];//初始化a = &#123;1,2,3,4,5&#125;//赋值</code></pre><h5 id="循环：for，for-each"><a href="#循环：for，for-each" class="headerlink" title="循环：for，for-each"></a>循环：for，for-each</h5><h5 id="数组拷贝：Arrays-copyOf-：生成新数组的深拷贝"><a href="#数组拷贝：Arrays-copyOf-：生成新数组的深拷贝" class="headerlink" title="数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝"></a>数组拷贝：Arrays.copyOf() ：生成新数组的深拷贝</h5><pre><code class="java">int[] c = Arrays.copyOf(a,a.length);//第一个参数为拷贝对象，第二个参数为创建数组c的长度</code></pre><h5 id="数组排序：Arrays-sort-：快速排序"><a href="#数组排序：Arrays-sort-：快速排序" class="headerlink" title="数组排序：Arrays.sort()：快速排序"></a>数组排序：Arrays.sort()：快速排序</h5>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java技术卷 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
